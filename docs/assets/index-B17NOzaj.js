var Ve=Object.defineProperty;var ze=(n,e,t)=>e in n?Ve(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var y=(n,e,t)=>ze(n,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var lib$1={},types={};Object.defineProperty(types,"__esModule",{value:!0});var ee={},taskCollection$1={},taskCollection={},utils$1={};Object.defineProperty(utils$1,"__esModule",{value:!0});utils$1._fast_remove_single=void 0;function _fast_remove_single(n,e){e!==-1&&(e===0?n.shift():e===n.length-1?n.length=n.length-1:n.splice(e,1))}utils$1._fast_remove_single=_fast_remove_single;var bakeCollection={};(function(exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=function(){};var FORLOOP_FALLBACK=1500;function generateArgsDefCode(n){var e="";if(n===0)return e;for(var t=0;t<n-1;++t)e+="arg"+String(t)+", ";return e+="arg"+String(n-1),e}function generateBodyPartsCode(n,e){for(var t="",r="",s=0;s<e;++s)t+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,"(").concat(n,`)
`);return{funcDefCode:t,funcCallCode:r}}function generateBodyPartsVariadicCode(n){for(var e="",t="",r=0;r<n;++r)e+="var f".concat(r," = collection[").concat(r,`];
`),t+="f".concat(r,`.apply(undefined, arguments)
`);return{funcDefCode:e,funcCallCode:t}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic})(bakeCollection);var __spreadArray$1=commonjsGlobal&&commonjsGlobal.__spreadArray||function(n,e,t){if(t||arguments.length===2)for(var r=0,s=e.length,o;r<s;r++)(o||!(r in e))&&(o||(o=Array.prototype.slice.call(e,0,r)),o[r]=e[r]);return n.concat(o||Array.prototype.slice.call(e))};Object.defineProperty(taskCollection,"__esModule",{value:!0});taskCollection.TaskCollection=void 0;var utils_1$1=utils$1,bake_collection_1=bakeCollection;function push_norebuild(n,e){var t=this.length;if(t>1)if(e){var r;(r=this._tasks).push.apply(r,arguments),this.length+=arguments.length}else this._tasks.push(n),this.length++;else if(e){if(t===1){var s=Array(1+arguments.length);s.push(s),s.push.apply(s,arguments),this._tasks=s}else{var s=Array(arguments.length);s.push.apply(s,arguments),this._tasks=s}this.length+=arguments.length}else t===1?this._tasks=[this._tasks,n]:this._tasks=n,this.length++}function push_rebuild(n,e){var t=this.length;if(t>1)if(e){var r;(r=this._tasks).push.apply(r,arguments),this.length+=arguments.length}else this._tasks.push(n),this.length++;else if(e){if(t===1){var s=Array(1+arguments.length);s.push(s),s.push.apply(s,arguments),this._tasks=s}else{var s=Array(arguments.length);s.push.apply(s,arguments),this._tasks=s}this.length+=arguments.length}else t===1?this._tasks=[this._tasks,n]:this._tasks=n,this.length++;this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}function removeLast_norebuild(n){this.length!==0&&(this.length===1?this._tasks===n&&(this.length=0):((0,utils_1$1._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(n)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function removeLast_rebuild(n){if(this.length!==0){if(this.length===1)if(this._tasks===n&&(this.length=0),this.firstEmitBuildStrategy){this.call=bake_collection_1.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,utils_1$1._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(n)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}}function insert_norebuild(n){for(var e,t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this.length===0?(this._tasks=t,this.length=1):this.length===1?(t.unshift(this._tasks),this._tasks=t,this.length=this._tasks.length):((e=this._tasks).splice.apply(e,__spreadArray$1([n,0],t,!1)),this.length=this._tasks.length)}function insert_rebuild(n){for(var e,t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this.length===0?(this._tasks=t,this.length=1):this.length===1?(t.unshift(this._tasks),this._tasks=t,this.length=this._tasks.length):((e=this._tasks).splice.apply(e,__spreadArray$1([n,0],t,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild()}function rebuild_noawait(){this.length===0?this.call=bake_collection_1.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,bake_collection_1.bakeCollection)(this._tasks,this.argsNum)}function rebuild_await(){this.length===0?this.call=bake_collection_1.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,bake_collection_1.bakeCollectionAwait)(this._tasks,this.argsNum)}function rebuild_on_first_call(){this.rebuild(),this.call.apply(void 0,arguments)}var TaskCollection=function(){function n(e,t,r,s){t===void 0&&(t=!0),r===void 0&&(r=null),s===void 0&&(s=!1),this.awaitTasks=s,this.call=bake_collection_1.BAKED_EMPTY_FUNC,this.argsNum=e,this.firstEmitBuildStrategy=!0,s?this.rebuild=rebuild_await.bind(this):this.rebuild=rebuild_noawait.bind(this),this.setAutoRebuild(t),r?typeof r=="function"?(this._tasks=r,this.length=1):(this._tasks=r,this.length=r.length):(this._tasks=null,this.length=0),t&&this.rebuild()}return n}();taskCollection.TaskCollection=TaskCollection;function fastClear(){this._tasks=null,this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC}function clear(){this._tasks=null,this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC}function growArgsNum(n){this.argsNum<n&&(this.argsNum=n,this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild())}function setAutoRebuild(n){n?(this.push=push_rebuild.bind(this),this.insert=insert_rebuild.bind(this),this.removeLast=removeLast_rebuild.bind(this)):(this.push=push_norebuild.bind(this),this.insert=insert_norebuild.bind(this),this.removeLast=removeLast_norebuild.bind(this))}function tasksAsArray(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function setTasks(n){n.length===0?(this.length=0,this.call=bake_collection_1.BAKED_EMPTY_FUNC):n.length===1?(this.length=1,this.call=n[0],this._tasks=n[0]):(this.length=n.length,this._tasks=n,this.firstEmitBuildStrategy?this.call=rebuild_on_first_call:this.rebuild())}TaskCollection.prototype.fastClear=fastClear;TaskCollection.prototype.clear=clear;TaskCollection.prototype.growArgsNum=growArgsNum;TaskCollection.prototype.setAutoRebuild=setAutoRebuild;TaskCollection.prototype.tasksAsArray=tasksAsArray;TaskCollection.prototype.setTasks=setTasks;(function(n){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),t=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(n,"__esModule",{value:!0}),t(taskCollection,n)})(taskCollection$1);var utils={};Object.defineProperty(utils,"__esModule",{value:!0});utils.nullObj=void 0;function nullObj(){var n={};return n.__proto__=null,n}utils.nullObj=nullObj;var __spreadArray=commonjsGlobal&&commonjsGlobal.__spreadArray||function(n,e,t){if(t||arguments.length===2)for(var r=0,s=e.length,o;r<s;r++)(o||!(r in e))&&(o||(o=Array.prototype.slice.call(e,0,r)),o[r]=e[r]);return n.concat(o||Array.prototype.slice.call(e))};Object.defineProperty(ee,"__esModule",{value:!0});ee.EventEmitter=void 0;var task_collection_1=taskCollection$1,utils_1=utils$1,utils_2=utils;function emit(n,e,t,r,s,o){var a=this.events[n];if(a){if(a.length===0)return!1;if(a.argsNum<6)a.call(e,t,r,s,o);else{for(var c=new Array(a.argsNum),l=0,u=c.length;l<u;++l)c[l]=arguments[l+1];a.call.apply(void 0,c)}return!0}return!1}function emitHasOnce(n,e,t,r,s,o){var a=this.events[n],c;if(a!==void 0){if(a.length===0)return!1;if(a.argsNum<6)a.call(e,t,r,s,o);else{c=new Array(a.argsNum);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1];a.call.apply(void 0,c)}}var f=this.onceEvents[n];if(f){if(typeof f=="function")if(this.onceEvents[n]=void 0,arguments.length<6)f(e,t,r,s,o);else{if(c===void 0){c=new Array(arguments.length-1);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1]}f.apply(void 0,c)}else{var h=f;if(this.onceEvents[n]=void 0,arguments.length<6)for(var l=0;l<h.length;++l)h[l](e,t,r,s,o);else{if(c===void 0){c=new Array(arguments.length-1);for(var l=0,u=c.length;l<u;++l)c[l]=arguments[l+1]}for(var l=0;l<h.length;++l)h[l].apply(void 0,c)}}return!0}return a!==void 0}var EventEmitter=function(){function n(){this.events=(0,utils_2.nullObj)(),this.onceEvents=(0,utils_2.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(n.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),n}();ee.EventEmitter=EventEmitter;function once(n,e){switch(this.emit===emit&&(this.emit=emitHasOnce),typeof this.onceEvents[n]){case"undefined":this.onceEvents[n]=e,typeof n=="symbol"&&this._symbolKeys.add(n);break;case"function":this.onceEvents[n]=[this.onceEvents[n],e];break;case"object":this.onceEvents[n].push(e)}return this}function addListener(n,e,t){if(t===void 0&&(t=e.length),typeof e!="function")throw new TypeError("The listener must be a function");var r=this.events[n];return r?(r.push(e),r.growArgsNum(t),this.maxListeners!==1/0&&this.maxListeners<=r.length&&console.warn('Maximum event listeners for "'.concat(String(n),'" event!'))):(this.events[n]=new task_collection_1.TaskCollection(t,!0,e,!1),typeof n=="symbol"&&this._symbolKeys.add(n)),this}function removeListener(n,e){var t=this.events[n];t&&t.removeLast(e);var r=this.onceEvents[n];return r&&(typeof r=="function"?this.onceEvents[n]=void 0:typeof r=="object"&&(r.length===1&&r[0]===e?this.onceEvents[n]=void 0:(0,utils_1._fast_remove_single)(r,r.lastIndexOf(e)))),this}function addListenerBound(n,e,t,r){t===void 0&&(t=this),r===void 0&&(r=e.length),this.boundFuncs||(this.boundFuncs=new Map);var s=e.bind(t);return this.boundFuncs.set(e,s),this.addListener(n,s,r)}function removeListenerBound(n,e){var t,r,s=(t=this.boundFuncs)===null||t===void 0?void 0:t.get(e);return(r=this.boundFuncs)===null||r===void 0||r.delete(e),this.removeListener(n,s)}function hasListeners(n){return this.events[n]&&!!this.events[n].length}function prependListener(n,e,t){if(t===void 0&&(t=e.length),typeof e!="function")throw new TypeError("The listener must be a function");var r=this.events[n];return!r||!(r instanceof task_collection_1.TaskCollection)?(r=this.events[n]=new task_collection_1.TaskCollection(t,!0,e,!1),typeof n=="symbol"&&this._symbolKeys.add(n)):(r.insert(0,e),r.growArgsNum(t),this.maxListeners!==1/0&&this.maxListeners<=r.length&&console.warn('Maximum event listeners for "'.concat(String(n),'" event!'))),this}function prependOnceListener(n,e){this.emit===emit&&(this.emit=emitHasOnce);var t=this.onceEvents[n];return t?typeof t!="object"?(this.onceEvents[n]=[e,t],typeof n=="symbol"&&this._symbolKeys.add(n)):(t.unshift(e),this.maxListeners!==1/0&&this.maxListeners<=t.length&&console.warn('Maximum event listeners for "'.concat(String(n),'" once event!'))):(this.onceEvents[n]=[e],typeof n=="symbol"&&this._symbolKeys.add(n)),this}function removeAllListeners(n){return n===void 0?(this.events=(0,utils_2.nullObj)(),this.onceEvents=(0,utils_2.nullObj)(),this._symbolKeys=new Set):(this.events[n]=void 0,this.onceEvents[n]=void 0,typeof n=="symbol"&&this._symbolKeys.delete(n)),this}function setMaxListeners(n){return this.maxListeners=n,this}function getMaxListeners(){return this.maxListeners}function listeners(n){return this.emit===emit?this.events[n]?this.events[n].tasksAsArray().slice():[]:this.events[n]&&this.onceEvents[n]?__spreadArray(__spreadArray([],this.events[n].tasksAsArray(),!0),typeof this.onceEvents[n]=="function"?[this.onceEvents[n]]:this.onceEvents[n],!0):this.events[n]?this.events[n].tasksAsArray():this.onceEvents[n]?typeof this.onceEvents[n]=="function"?[this.onceEvents[n]]:this.onceEvents[n]:[]}function eventNames(){var n=this;if(this.emit===emit){var e=Object.keys(this.events);return __spreadArray(__spreadArray([],e,!0),Array.from(this._symbolKeys),!0).filter(function(r){return r in n.events&&n.events[r]&&n.events[r].length})}else{var e=Object.keys(this.events).filter(function(s){return n.events[s]&&n.events[s].length}),t=Object.keys(this.onceEvents).filter(function(s){return n.onceEvents[s]&&n.onceEvents[s].length});return __spreadArray(__spreadArray(__spreadArray([],e,!0),t,!0),Array.from(this._symbolKeys).filter(function(s){return s in n.events&&n.events[s]&&n.events[s].length||s in n.onceEvents&&n.onceEvents[s]&&n.onceEvents[s].length}),!0)}}function listenerCount(n){return this.emit===emit?this.events[n]&&this.events[n].length||0:(this.events[n]&&this.events[n].length||0)+(this.onceEvents[n]&&this.onceEvents[n].length||0)}EventEmitter.prototype.emit=emit;EventEmitter.prototype.on=addListener;EventEmitter.prototype.once=once;EventEmitter.prototype.addListener=addListener;EventEmitter.prototype.removeListener=removeListener;EventEmitter.prototype.addListenerBound=addListenerBound;EventEmitter.prototype.removeListenerBound=removeListenerBound;EventEmitter.prototype.hasListeners=hasListeners;EventEmitter.prototype.prependListener=prependListener;EventEmitter.prototype.prependOnceListener=prependOnceListener;EventEmitter.prototype.off=removeListener;EventEmitter.prototype.removeAllListeners=removeAllListeners;EventEmitter.prototype.setMaxListeners=setMaxListeners;EventEmitter.prototype.getMaxListeners=getMaxListeners;EventEmitter.prototype.listeners=listeners;EventEmitter.prototype.eventNames=eventNames;EventEmitter.prototype.listenerCount=listenerCount;(function(n){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),t=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(n,"__esModule",{value:!0}),t(types,n),t(ee,n)})(lib$1);var browser={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var n=1e3,e=n*60,t=e*60,r=t*24,s=r*7,o=r*365.25;ms=function(f,h){h=h||{};var p=typeof f;if(p==="string"&&f.length>0)return a(f);if(p==="number"&&isFinite(f))return h.long?l(f):c(f);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(f))};function a(f){if(f=String(f),!(f.length>100)){var h=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(f);if(h){var p=parseFloat(h[1]),g=(h[2]||"ms").toLowerCase();switch(g){case"years":case"year":case"yrs":case"yr":case"y":return p*o;case"weeks":case"week":case"w":return p*s;case"days":case"day":case"d":return p*r;case"hours":case"hour":case"hrs":case"hr":case"h":return p*t;case"minutes":case"minute":case"mins":case"min":case"m":return p*e;case"seconds":case"second":case"secs":case"sec":case"s":return p*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return p;default:return}}}}function c(f){var h=Math.abs(f);return h>=r?Math.round(f/r)+"d":h>=t?Math.round(f/t)+"h":h>=e?Math.round(f/e)+"m":h>=n?Math.round(f/n)+"s":f+"ms"}function l(f){var h=Math.abs(f);return h>=r?u(f,h,r,"day"):h>=t?u(f,h,t,"hour"):h>=e?u(f,h,e,"minute"):h>=n?u(f,h,n,"second"):f+" ms"}function u(f,h,p,g){var b=h>=p*1.5;return Math.round(f/p)+" "+g+(b?"s":"")}return ms}function setup(n){t.debug=t,t.default=t,t.coerce=l,t.disable=a,t.enable=s,t.enabled=c,t.humanize=requireMs(),t.destroy=u,Object.keys(n).forEach(f=>{t[f]=n[f]}),t.names=[],t.skips=[],t.formatters={};function e(f){let h=0;for(let p=0;p<f.length;p++)h=(h<<5)-h+f.charCodeAt(p),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(f){let h,p=null,g,b;function m(...E){if(!m.enabled)return;const _=m,C=Number(new Date),I=C-(h||C);_.diff=I,_.prev=h,_.curr=C,h=C,E[0]=t.coerce(E[0]),typeof E[0]!="string"&&E.unshift("%O");let P=0;E[0]=E[0].replace(/%([a-zA-Z%])/g,(L,F)=>{if(L==="%%")return"%";P++;const K=t.formatters[F];if(typeof K=="function"){const U=E[P];L=K.call(_,U),E.splice(P,1),P--}return L}),t.formatArgs.call(_,E),(_.log||t.log).apply(_,E)}return m.namespace=f,m.useColors=t.useColors(),m.color=t.selectColor(f),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(g!==t.namespaces&&(g=t.namespaces,b=t.enabled(f)),b),set:E=>{p=E}}),typeof t.init=="function"&&t.init(m),m}function r(f,h){const p=t(this.namespace+(typeof h>"u"?":":h)+f);return p.log=this.log,p}function s(f){t.save(f),t.namespaces=f,t.names=[],t.skips=[];const h=(typeof f=="string"?f:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const p of h)p[0]==="-"?t.skips.push(p.slice(1)):t.names.push(p)}function o(f,h){let p=0,g=0,b=-1,m=0;for(;p<f.length;)if(g<h.length&&(h[g]===f[p]||h[g]==="*"))h[g]==="*"?(b=g,m=p,g++):(p++,g++);else if(b!==-1)g=b+1,m++,p=m;else return!1;for(;g<h.length&&h[g]==="*";)g++;return g===h.length}function a(){const f=[...t.names,...t.skips.map(h=>"-"+h)].join(",");return t.enable(""),f}function c(f){for(const h of t.skips)if(o(f,h))return!1;for(const h of t.names)if(o(f,h))return!0;return!1}function l(f){return f instanceof Error?f.stack||f.message:f}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var common=setup;(function(n,e){var t={};e.formatArgs=s,e.save=o,e.load=a,e.useColors=r,e.storage=c(),e.destroy=(()=>{let u=!1;return()=>{u||(u=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let u;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(u=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(u[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function s(u){if(u[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+u[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const f="color: "+this.color;u.splice(1,0,f,"color: inherit");let h=0,p=0;u[0].replace(/%[a-zA-Z%]/g,g=>{g!=="%%"&&(h++,g==="%c"&&(p=h))}),u.splice(p,0,f)}e.log=console.debug||console.log||(()=>{});function o(u){try{u?e.storage.setItem("debug",u):e.storage.removeItem("debug")}catch{}}function a(){let u;try{u=e.storage.getItem("debug")||e.storage.getItem("DEBUG")}catch{}return!u&&typeof process<"u"&&"env"in process&&(u=t.DEBUG),u}function c(){try{return localStorage}catch{}}n.exports=common(e);const{formatters:l}=n.exports;l.j=function(u){try{return JSON.stringify(u)}catch(f){return"[UnexpectedJSONParseError]: "+f.message}}})(browser,browser.exports);var browserExports=browser.exports;const createDebug5=getDefaultExportFromCjs(browserExports);function number$2(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes$2(n,...e){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(n.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`)}function hash$1(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(n.outputLen),number$2(n.blockLen)}function exists$2(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function output$2(n,e){bytes$2(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=n=>n instanceof Uint8Array,createView$3=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr$2=(n,e)=>n<<32-e|n>>>e,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$4(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$3(n){if(typeof n=="string"&&(n=utf8ToBytes$4(n)),!u8a$2(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes$3(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!u8a$2(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}let Hash$2=class{clone(){return this._cloneInto()}};function wrapConstructor$1(n){const e=r=>n().update(toBytes$3(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function randomBytes$2(n=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$3(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(t>>s&o),c=Number(t&o),l=r?4:0,u=r?0:4;n.setUint32(e+l,a,r),n.setUint32(e+u,c,r)}let SHA2$1=class extends Hash$2{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$3(this.buffer)}update(e){exists$2(this);const{view:t,buffer:r,blockLen:s}=this;e=toBytes$3(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$3(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists$2(this),output$2(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let h=a;h<s;h++)t[h]=0;setBigUint64$3(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$3(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,f=this.get();if(u>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,f[h],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%t&&e.buffer.set(r),e}};const Chi$2=(n,e,t)=>n&e^~n&t,Maj$2=(n,e,t)=>n&e^n&t^e&t,SHA256_K$2=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$2=new Uint32Array(64);let SHA256$2=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,t,r,s,o,a,c,l]}set(e,t,r,s,o,a,c,l){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,t){for(let h=0;h<16;h++,t+=4)SHA256_W$2[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const p=SHA256_W$2[h-15],g=SHA256_W$2[h-2],b=rotr$2(p,7)^rotr$2(p,18)^p>>>3,m=rotr$2(g,17)^rotr$2(g,19)^g>>>10;SHA256_W$2[h]=m+SHA256_W$2[h-7]+b+SHA256_W$2[h-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:f}=this;for(let h=0;h<64;h++){const p=rotr$2(c,6)^rotr$2(c,11)^rotr$2(c,25),g=f+p+Chi$2(c,l,u)+SHA256_K$2[h]+SHA256_W$2[h]|0,m=(rotr$2(r,2)^rotr$2(r,13)^rotr$2(r,22))+Maj$2(r,s,o)|0;f=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+m|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,u,f)}roundClean(){SHA256_W$2.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$3=wrapConstructor$1(()=>new SHA256$2);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$9=BigInt(0),_1n$9=BigInt(1),_2n$5=BigInt(2),u8a$1=n=>n instanceof Uint8Array,hexes$2=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$2(n){if(!u8a$1(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=hexes$2[n[t]];return e}function numberToHexUnpadded$1(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function hexToNumber$1(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function hexToBytes$2(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let r=0;r<t.length;r++){const s=r*2,o=n.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");t[r]=a}return t}function bytesToNumberBE$1(n){return hexToNumber$1(bytesToHex$2(n))}function bytesToNumberLE$1(n){if(!u8a$1(n))throw new Error("Uint8Array expected");return hexToNumber$1(bytesToHex$2(Uint8Array.from(n).reverse()))}function numberToBytesBE$1(n,e){return hexToBytes$2(n.toString(16).padStart(e*2,"0"))}function numberToBytesLE$1(n,e){return numberToBytesBE$1(n,e).reverse()}function numberToVarBytesBE(n){return hexToBytes$2(numberToHexUnpadded$1(n))}function ensureBytes$1(n,e,t){let r;if(typeof e=="string")try{r=hexToBytes$2(e)}catch(o){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${o}`)}else if(u8a$1(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(`${n} expected ${t} bytes, got ${s}`);return r}function concatBytes$2(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!u8a$1(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}function equalBytes$1(n,e){if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function utf8ToBytes$3(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function bitLen$1(n){let e;for(e=0;n>_0n$9;n>>=_1n$9,e+=1);return e}function bitGet(n,e){return n>>BigInt(e)&_1n$9}const bitSet=(n,e,t)=>n|(t?_1n$9:_0n$9)<<BigInt(e),bitMask$1=n=>(_2n$5<<BigInt(n-1))-_1n$9,u8n=n=>new Uint8Array(n),u8fr=n=>Uint8Array.from(n);function createHmacDrbg$1(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=u8n(n),s=u8n(n),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},c=(...h)=>t(s,r,...h),l=(h=u8n())=>{s=c(u8fr([0]),h),r=c(),h.length!==0&&(s=c(u8fr([1]),h),r=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const p=[];for(;h<e;){r=c();const g=r.slice();p.push(g),h+=r.length}return concatBytes$2(...p)};return(h,p)=>{a(),l(h);let g;for(;!(g=p(u()));)l();return a(),g}}const validatorFns={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function validateObject(n,e,t={}){const r=(s,o,a)=>{const c=validatorFns[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const l=n[s];if(!(a&&l===void 0)&&!c(l,n))throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(t))r(s,o,!0);return n}const ut=Object.freeze(Object.defineProperty({__proto__:null,bitGet,bitLen:bitLen$1,bitMask:bitMask$1,bitSet,bytesToHex:bytesToHex$2,bytesToNumberBE:bytesToNumberBE$1,bytesToNumberLE:bytesToNumberLE$1,concatBytes:concatBytes$2,createHmacDrbg:createHmacDrbg$1,ensureBytes:ensureBytes$1,equalBytes:equalBytes$1,hexToBytes:hexToBytes$2,hexToNumber:hexToNumber$1,numberToBytesBE:numberToBytesBE$1,numberToBytesLE:numberToBytesLE$1,numberToHexUnpadded:numberToHexUnpadded$1,numberToVarBytesBE,utf8ToBytes:utf8ToBytes$3,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$8=BigInt(0),_1n$8=BigInt(1),_2n$4=BigInt(2),_3n$3=BigInt(3),_4n$2=BigInt(4),_5n$1=BigInt(5),_8n$1=BigInt(8);BigInt(9);BigInt(16);function mod$1(n,e){const t=n%e;return t>=_0n$8?t:e+t}function pow(n,e,t){if(t<=_0n$8||e<_0n$8)throw new Error("Expected power/modulo > 0");if(t===_1n$8)return _0n$8;let r=_1n$8;for(;e>_0n$8;)e&_1n$8&&(r=r*n%t),n=n*n%t,e>>=_1n$8;return r}function pow2$1(n,e,t){let r=n;for(;e-- >_0n$8;)r*=r,r%=t;return r}function invert$1(n,e){if(n===_0n$8||e<=_0n$8)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=mod$1(n,e),r=e,s=_0n$8,o=_1n$8;for(;t!==_0n$8;){const c=r/t,l=r%t,u=s-o*c;r=t,t=l,s=o,o=u}if(r!==_1n$8)throw new Error("invert: does not exist");return mod$1(s,e)}function tonelliShanks$1(n){const e=(n-_1n$8)/_2n$4;let t,r,s;for(t=n-_1n$8,r=0;t%_2n$4===_0n$8;t/=_2n$4,r++);for(s=_2n$4;s<n&&pow(s,e,n)!==n-_1n$8;s++);if(r===1){const a=(n+_1n$8)/_4n$2;return function(l,u){const f=l.pow(u,a);if(!l.eql(l.sqr(f),u))throw new Error("Cannot find square root");return f}}const o=(t+_1n$8)/_2n$4;return function(c,l){if(c.pow(l,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,f=c.pow(c.mul(c.ONE,s),t),h=c.pow(l,o),p=c.pow(l,t);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let g=1;for(let m=c.sqr(p);g<u&&!c.eql(m,c.ONE);g++)m=c.sqr(m);const b=c.pow(f,_1n$8<<BigInt(u-g-1));f=c.sqr(b),h=c.mul(h,b),p=c.mul(p,f),u=g}return h}}function FpSqrt$1(n){if(n%_4n$2===_3n$3){const e=(n+_1n$8)/_4n$2;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%_8n$1===_5n$1){const e=(n-_5n$1)/_8n$1;return function(r,s){const o=r.mul(s,_2n$4),a=r.pow(o,e),c=r.mul(s,a),l=r.mul(r.mul(c,_2n$4),a),u=r.mul(c,r.sub(l,r.ONE));if(!r.eql(r.sqr(u),s))throw new Error("Cannot find square root");return u}}return tonelliShanks$1(n)}const FIELD_FIELDS$1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$1(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=FIELD_FIELDS$1.reduce((r,s)=>(r[s]="function",r),e);return validateObject(n,t)}function FpPow$1(n,e,t){if(t<_0n$8)throw new Error("Expected power > 0");if(t===_0n$8)return n.ONE;if(t===_1n$8)return e;let r=n.ONE,s=e;for(;t>_0n$8;)t&_1n$8&&(r=n.mul(r,s)),s=n.sqr(s),t>>=_1n$8;return r}function FpInvertBatch$1(n,e){const t=new Array(e.length),r=e.reduce((o,a,c)=>n.is0(a)?o:(t[c]=o,n.mul(o,a)),n.ONE),s=n.inv(r);return e.reduceRight((o,a,c)=>n.is0(a)?o:(t[c]=n.mul(o,t[c]),n.mul(o,a)),s),t}function nLength$1(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Field$1(n,e,t=!1,r={}){if(n<=_0n$8)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=nLength$1(n,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=FpSqrt$1(n),c=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:bitMask$1(s),ZERO:_0n$8,ONE:_1n$8,create:l=>mod$1(l,n),isValid:l=>{if(typeof l!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);return _0n$8<=l&&l<n},is0:l=>l===_0n$8,isOdd:l=>(l&_1n$8)===_1n$8,neg:l=>mod$1(-l,n),eql:(l,u)=>l===u,sqr:l=>mod$1(l*l,n),add:(l,u)=>mod$1(l+u,n),sub:(l,u)=>mod$1(l-u,n),mul:(l,u)=>mod$1(l*u,n),pow:(l,u)=>FpPow$1(c,l,u),div:(l,u)=>mod$1(l*invert$1(u,n),n),sqrN:l=>l*l,addN:(l,u)=>l+u,subN:(l,u)=>l-u,mulN:(l,u)=>l*u,inv:l=>invert$1(l,n),sqrt:r.sqrt||(l=>a(c,l)),invertBatch:l=>FpInvertBatch$1(c,l),cmov:(l,u,f)=>f?u:l,toBytes:l=>t?numberToBytesLE$1(l,o):numberToBytesBE$1(l,o),fromBytes:l=>{if(l.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${l.length}`);return t?bytesToNumberLE$1(l):bytesToNumberBE$1(l)}});return Object.freeze(c)}function getFieldBytesLength$1(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function getMinHashLength$1(n){const e=getFieldBytesLength$1(n);return e+Math.ceil(e/2)}function mapHashToField$1(n,e,t=!1){const r=n.length,s=getFieldBytesLength$1(e),o=getMinHashLength$1(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const a=t?bytesToNumberBE$1(n):bytesToNumberLE$1(n),c=mod$1(a,e-_1n$8)+_1n$8;return t?numberToBytesLE$1(c,s):numberToBytesBE$1(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$7=BigInt(0),_1n$7=BigInt(1);function wNAF$1(n,e){const t=(s,o)=>{const a=o.negate();return s?a:o},r=s=>{const o=Math.ceil(e/s)+1,a=2**(s-1);return{windows:o,windowSize:a}};return{constTimeNegate:t,unsafeLadder(s,o){let a=n.ZERO,c=s;for(;o>_0n$7;)o&_1n$7&&(a=a.add(c)),c=c.double(),o>>=_1n$7;return a},precomputeWindow(s,o){const{windows:a,windowSize:c}=r(o),l=[];let u=s,f=u;for(let h=0;h<a;h++){f=u,l.push(f);for(let p=1;p<c;p++)f=f.add(u),l.push(f);u=f.double()}return l},wNAF(s,o,a){const{windows:c,windowSize:l}=r(s);let u=n.ZERO,f=n.BASE;const h=BigInt(2**s-1),p=2**s,g=BigInt(s);for(let b=0;b<c;b++){const m=b*l;let E=Number(a&h);a>>=g,E>l&&(E-=p,a+=_1n$7);const _=m,C=m+Math.abs(E)-1,I=b%2!==0,P=E<0;E===0?f=f.add(t(I,o[_])):u=u.add(t(P,o[C]))}return{p:u,f}},wNAFCached(s,o,a,c){const l=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,l),l!==1&&o.set(s,c(u))),this.wNAF(l,u,a)}}}function validateBasic(n){return validateField$1(n.Fp),validateObject(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$1(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts(n){const e=validateBasic(n);validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER$1={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=DER$1;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:b2n(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=DER$1,t=typeof n=="string"?h2b(n):n;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=DER$1._parseInt(t.subarray(2)),{d:a,l:c}=DER$1._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:a}},hexFromSig(n){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const f=u.toString(16);return f.length&1?`0${f}`:f},r=e(t(n.s)),s=e(t(n.r)),o=r.length/2,a=s.length/2,c=t(o),l=t(a);return`30${t(a+o+4)}02${l}${s}02${c}${r}`}},_0n$6=BigInt(0),_1n$6=BigInt(1);BigInt(2);const _3n$2=BigInt(3);BigInt(4);function weierstrassPoints(n){const e=validatePointOpts(n),{Fp:t}=e,r=e.toBytes||((b,m,E)=>{const _=m.toAffine();return concatBytes$2(Uint8Array.from([4]),t.toBytes(_.x),t.toBytes(_.y))}),s=e.fromBytes||(b=>{const m=b.subarray(1),E=t.fromBytes(m.subarray(0,t.BYTES)),_=t.fromBytes(m.subarray(t.BYTES,2*t.BYTES));return{x:E,y:_}});function o(b){const{a:m,b:E}=e,_=t.sqr(b),C=t.mul(_,b);return t.add(t.add(C,t.mul(b,m)),E)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(b){return typeof b=="bigint"&&_0n$6<b&&b<e.n}function c(b){if(!a(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function l(b){const{allowedPrivateKeyLengths:m,nByteLength:E,wrapPrivateKey:_,n:C}=e;if(m&&typeof b!="bigint"){if(b instanceof Uint8Array&&(b=bytesToHex$2(b)),typeof b!="string"||!m.includes(b.length))throw new Error("Invalid key");b=b.padStart(E*2,"0")}let I;try{I=typeof b=="bigint"?b:bytesToNumberBE$1(ensureBytes$1("private key",b,E))}catch{throw new Error(`private key must be ${E} bytes, hex or bigint, not ${typeof b}`)}return _&&(I=mod$1(I,C)),c(I),I}const u=new Map;function f(b){if(!(b instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(m,E,_){if(this.px=m,this.py=E,this.pz=_,m==null||!t.isValid(m))throw new Error("x required");if(E==null||!t.isValid(E))throw new Error("y required");if(_==null||!t.isValid(_))throw new Error("z required")}static fromAffine(m){const{x:E,y:_}=m||{};if(!m||!t.isValid(E)||!t.isValid(_))throw new Error("invalid affine point");if(m instanceof h)throw new Error("projective point not allowed");const C=I=>t.eql(I,t.ZERO);return C(E)&&C(_)?h.ZERO:new h(E,_,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(m){const E=t.invertBatch(m.map(_=>_.pz));return m.map((_,C)=>_.toAffine(E[C])).map(h.fromAffine)}static fromHex(m){const E=h.fromAffine(s(ensureBytes$1("pointHex",m)));return E.assertValidity(),E}static fromPrivateKey(m){return h.BASE.multiply(l(m))}_setWindowSize(m){this._WINDOW_SIZE=m,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:m,y:E}=this.toAffine();if(!t.isValid(m)||!t.isValid(E))throw new Error("bad point: x or y not FE");const _=t.sqr(E),C=o(m);if(!t.eql(_,C))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:m}=this.toAffine();if(t.isOdd)return!t.isOdd(m);throw new Error("Field doesn't support isOdd")}equals(m){f(m);const{px:E,py:_,pz:C}=this,{px:I,py:P,pz:M}=m,L=t.eql(t.mul(E,M),t.mul(I,C)),F=t.eql(t.mul(_,M),t.mul(P,C));return L&&F}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:m,b:E}=e,_=t.mul(E,_3n$2),{px:C,py:I,pz:P}=this;let M=t.ZERO,L=t.ZERO,F=t.ZERO,K=t.mul(C,C),U=t.mul(I,I),O=t.mul(P,P),T=t.mul(C,I);return T=t.add(T,T),F=t.mul(C,P),F=t.add(F,F),M=t.mul(m,F),L=t.mul(_,O),L=t.add(M,L),M=t.sub(U,L),L=t.add(U,L),L=t.mul(M,L),M=t.mul(T,M),F=t.mul(_,F),O=t.mul(m,O),T=t.sub(K,O),T=t.mul(m,T),T=t.add(T,F),F=t.add(K,K),K=t.add(F,K),K=t.add(K,O),K=t.mul(K,T),L=t.add(L,K),O=t.mul(I,P),O=t.add(O,O),K=t.mul(O,T),M=t.sub(M,K),F=t.mul(O,U),F=t.add(F,F),F=t.add(F,F),new h(M,L,F)}add(m){f(m);const{px:E,py:_,pz:C}=this,{px:I,py:P,pz:M}=m;let L=t.ZERO,F=t.ZERO,K=t.ZERO;const U=e.a,O=t.mul(e.b,_3n$2);let T=t.mul(E,I),x=t.mul(_,P),v=t.mul(C,M),$=t.add(E,_),w=t.add(I,P);$=t.mul($,w),w=t.add(T,x),$=t.sub($,w),w=t.add(E,C);let k=t.add(I,M);return w=t.mul(w,k),k=t.add(T,v),w=t.sub(w,k),k=t.add(_,C),L=t.add(P,M),k=t.mul(k,L),L=t.add(x,v),k=t.sub(k,L),K=t.mul(U,w),L=t.mul(O,v),K=t.add(L,K),L=t.sub(x,K),K=t.add(x,K),F=t.mul(L,K),x=t.add(T,T),x=t.add(x,T),v=t.mul(U,v),w=t.mul(O,w),x=t.add(x,v),v=t.sub(T,v),v=t.mul(U,v),w=t.add(w,v),T=t.mul(x,w),F=t.add(F,T),T=t.mul(k,w),L=t.mul($,L),L=t.sub(L,T),T=t.mul($,x),K=t.mul(k,K),K=t.add(K,T),new h(L,F,K)}subtract(m){return this.add(m.negate())}is0(){return this.equals(h.ZERO)}wNAF(m){return g.wNAFCached(this,u,m,E=>{const _=t.invertBatch(E.map(C=>C.pz));return E.map((C,I)=>C.toAffine(_[I])).map(h.fromAffine)})}multiplyUnsafe(m){const E=h.ZERO;if(m===_0n$6)return E;if(c(m),m===_1n$6)return this;const{endo:_}=e;if(!_)return g.unsafeLadder(this,m);let{k1neg:C,k1:I,k2neg:P,k2:M}=_.splitScalar(m),L=E,F=E,K=this;for(;I>_0n$6||M>_0n$6;)I&_1n$6&&(L=L.add(K)),M&_1n$6&&(F=F.add(K)),K=K.double(),I>>=_1n$6,M>>=_1n$6;return C&&(L=L.negate()),P&&(F=F.negate()),F=new h(t.mul(F.px,_.beta),F.py,F.pz),L.add(F)}multiply(m){c(m);let E=m,_,C;const{endo:I}=e;if(I){const{k1neg:P,k1:M,k2neg:L,k2:F}=I.splitScalar(E);let{p:K,f:U}=this.wNAF(M),{p:O,f:T}=this.wNAF(F);K=g.constTimeNegate(P,K),O=g.constTimeNegate(L,O),O=new h(t.mul(O.px,I.beta),O.py,O.pz),_=K.add(O),C=U.add(T)}else{const{p:P,f:M}=this.wNAF(E);_=P,C=M}return h.normalizeZ([_,C])[0]}multiplyAndAddUnsafe(m,E,_){const C=h.BASE,I=(M,L)=>L===_0n$6||L===_1n$6||!M.equals(C)?M.multiplyUnsafe(L):M.multiply(L),P=I(this,E).add(I(m,_));return P.is0()?void 0:P}toAffine(m){const{px:E,py:_,pz:C}=this,I=this.is0();m==null&&(m=I?t.ONE:t.inv(C));const P=t.mul(E,m),M=t.mul(_,m),L=t.mul(C,m);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:P,y:M}}isTorsionFree(){const{h:m,isTorsionFree:E}=e;if(m===_1n$6)return!0;if(E)return E(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:m,clearCofactor:E}=e;return m===_1n$6?this:E?E(h,this):this.multiplyUnsafe(e.h)}toRawBytes(m=!0){return this.assertValidity(),r(h,this,m)}toHex(m=!0){return bytesToHex$2(this.toRawBytes(m))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const p=e.nBitLength,g=wNAF$1(h,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:l,weierstrassEquation:o,isWithinCurveOrder:a}}function validateOpts(n){const e=validateBasic(n);return validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function weierstrass$1(n){const e=validateOpts(n),{Fp:t,n:r}=e,s=t.BYTES+1,o=2*t.BYTES+1;function a(w){return _0n$6<w&&w<t.ORDER}function c(w){return mod$1(w,r)}function l(w){return invert$1(w,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:f,weierstrassEquation:h,isWithinCurveOrder:p}=weierstrassPoints({...e,toBytes(w,k,S){const N=k.toAffine(),A=t.toBytes(N.x),B=concatBytes$2;return S?B(Uint8Array.from([k.hasEvenY()?2:3]),A):B(Uint8Array.from([4]),A,t.toBytes(N.y))},fromBytes(w){const k=w.length,S=w[0],N=w.subarray(1);if(k===s&&(S===2||S===3)){const A=bytesToNumberBE$1(N);if(!a(A))throw new Error("Point is not on curve");const B=h(A);let R=t.sqrt(B);const D=(R&_1n$6)===_1n$6;return(S&1)===1!==D&&(R=t.neg(R)),{x:A,y:R}}else if(k===o&&S===4){const A=t.fromBytes(N.subarray(0,t.BYTES)),B=t.fromBytes(N.subarray(t.BYTES,2*t.BYTES));return{x:A,y:B}}else throw new Error(`Point of length ${k} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),g=w=>bytesToHex$2(numberToBytesBE$1(w,e.nByteLength));function b(w){const k=r>>_1n$6;return w>k}function m(w){return b(w)?c(-w):w}const E=(w,k,S)=>bytesToNumberBE$1(w.slice(k,S));class _{constructor(k,S,N){this.r=k,this.s=S,this.recovery=N,this.assertValidity()}static fromCompact(k){const S=e.nByteLength;return k=ensureBytes$1("compactSignature",k,S*2),new _(E(k,0,S),E(k,S,2*S))}static fromDER(k){const{r:S,s:N}=DER$1.toSig(ensureBytes$1("DER",k));return new _(S,N)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(k){return new _(this.r,this.s,k)}recoverPublicKey(k){const{r:S,s:N,recovery:A}=this,B=F(ensureBytes$1("msgHash",k));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const R=A===2||A===3?S+e.n:S;if(R>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const D=A&1?"03":"02",z=u.fromHex(D+g(R)),H=l(R),V=c(-B*H),j=c(N*H),q=u.BASE.multiplyAndAddUnsafe(z,V,j);if(!q)throw new Error("point at infinify");return q.assertValidity(),q}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$2(this.toDERHex())}toDERHex(){return DER$1.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$2(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const C={isValidPrivateKey(w){try{return f(w),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const w=getMinHashLength$1(e.n);return mapHashToField$1(e.randomBytes(w),e.n)},precompute(w=8,k=u.BASE){return k._setWindowSize(w),k.multiply(BigInt(3)),k}};function I(w,k=!0){return u.fromPrivateKey(w).toRawBytes(k)}function P(w){const k=w instanceof Uint8Array,S=typeof w=="string",N=(k||S)&&w.length;return k?N===s||N===o:S?N===2*s||N===2*o:w instanceof u}function M(w,k,S=!0){if(P(w))throw new Error("first arg must be private key");if(!P(k))throw new Error("second arg must be public key");return u.fromHex(k).multiply(f(w)).toRawBytes(S)}const L=e.bits2int||function(w){const k=bytesToNumberBE$1(w),S=w.length*8-e.nBitLength;return S>0?k>>BigInt(S):k},F=e.bits2int_modN||function(w){return c(L(w))},K=bitMask$1(e.nBitLength);function U(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(_0n$6<=w&&w<K))throw new Error(`bigint expected < 2^${e.nBitLength}`);return numberToBytesBE$1(w,e.nByteLength)}function O(w,k,S=T){if(["recovered","canonical"].some(W=>W in S))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:A}=e;let{lowS:B,prehash:R,extraEntropy:D}=S;B==null&&(B=!0),w=ensureBytes$1("msgHash",w),R&&(w=ensureBytes$1("prehashed msgHash",N(w)));const z=F(w),H=f(k),V=[U(H),U(z)];if(D!=null){const W=D===!0?A(t.BYTES):D;V.push(ensureBytes$1("extraEntropy",W))}const j=concatBytes$2(...V),q=z;function G(W){const Z=L(W);if(!p(Z))return;const ke=l(Z),X=u.BASE.multiply(Z).toAffine(),Y=c(X.x);if(Y===_0n$6)return;const De=c(ke*c(q+Y*H));if(De===_0n$6)return;let Fe=(X.x===Y?0:2)|Number(X.y&_1n$6),Me=De;return B&&b(De)&&(Me=m(De),Fe^=1),new _(Y,Me,Fe)}return{seed:j,k2sig:G}}const T={lowS:e.lowS,prehash:!1},x={lowS:e.lowS,prehash:!1};function v(w,k,S=T){const{seed:N,k2sig:A}=O(w,k,S),B=e;return createHmacDrbg$1(B.hash.outputLen,B.nByteLength,B.hmac)(N,A)}u.BASE._setWindowSize(8);function $(w,k,S,N=x){var X;const A=w;if(k=ensureBytes$1("msgHash",k),S=ensureBytes$1("publicKey",S),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:B,prehash:R}=N;let D,z;try{if(typeof A=="string"||A instanceof Uint8Array)try{D=_.fromDER(A)}catch(Y){if(!(Y instanceof DER$1.Err))throw Y;D=_.fromCompact(A)}else if(typeof A=="object"&&typeof A.r=="bigint"&&typeof A.s=="bigint"){const{r:Y,s:De}=A;D=new _(Y,De)}else throw new Error("PARSE");z=u.fromHex(S)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(B&&D.hasHighS())return!1;R&&(k=e.hash(k));const{r:H,s:V}=D,j=F(k),q=l(V),G=c(j*q),W=c(H*q),Z=(X=u.BASE.multiplyAndAddUnsafe(z,G,W))==null?void 0:X.toAffine();return Z?c(Z.x)===H:!1}return{CURVE:e,getPublicKey:I,getSharedSecret:M,sign:v,verify:$,ProjectivePoint:u,Signature:_,utils:C}}let HMAC$2=class extends Hash$2{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,hash$1(e);const r=toBytes$3(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return exists$2(this),this.iHash.update(e),this}digestInto(e){exists$2(this),bytes$2(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(n,e,t)=>new HMAC$2(n,e).update(t).digest();hmac$2.create=(n,e)=>new HMAC$2(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(n){return{hash:n,hmac:(e,...t)=>hmac$2(n,e,concatBytes$3(...t)),randomBytes:randomBytes$2}}function createCurve$1(n,e){const t=r=>weierstrass$1({...n,...getHash(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n$5=BigInt(1),_2n$3=BigInt(2),divNearest$1=(n,e)=>(n+e/_2n$3)/e;function sqrtMod$1(n){const e=secp256k1P,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),u=n*n*n%e,f=u*u*n%e,h=pow2$1(f,t,e)*f%e,p=pow2$1(h,t,e)*f%e,g=pow2$1(p,_2n$3,e)*u%e,b=pow2$1(g,s,e)*g%e,m=pow2$1(b,o,e)*b%e,E=pow2$1(m,c,e)*m%e,_=pow2$1(E,l,e)*E%e,C=pow2$1(_,c,e)*m%e,I=pow2$1(C,t,e)*f%e,P=pow2$1(I,a,e)*b%e,M=pow2$1(P,r,e)*u%e,L=pow2$1(M,_2n$3,e);if(!Fp.eql(Fp.sqr(L),n))throw new Error("Cannot find square root");return L}const Fp=Field$1(secp256k1P,void 0,void 0,{sqrt:sqrtMod$1}),secp256k1$1=createCurve$1({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=secp256k1N,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n$5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,a=BigInt("0x100000000000000000000000000000000"),c=divNearest$1(o*n,e),l=divNearest$1(-r*n,e);let u=mod$1(n-c*t-l*s,e),f=mod$1(-c*r-l*o,e);const h=u>a,p=f>a;if(h&&(u=e-u),p&&(f=e-f),u>a||f>a)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:h,k1:u,k2neg:p,k2:f}}}},sha256$3),_0n$5=BigInt(0),fe=n=>typeof n=="bigint"&&_0n$5<n&&n<secp256k1P,ge=n=>typeof n=="bigint"&&_0n$5<n&&n<secp256k1N,TAGGED_HASH_PREFIXES$1={};function taggedHash$1(n,...e){let t=TAGGED_HASH_PREFIXES$1[n];if(t===void 0){const r=sha256$3(Uint8Array.from(n,s=>s.charCodeAt(0)));t=concatBytes$2(r,r),TAGGED_HASH_PREFIXES$1[n]=t}return sha256$3(concatBytes$2(t,...e))}const pointToBytes$1=n=>n.toRawBytes(!0).slice(1),numTo32b=n=>numberToBytesBE$1(n,32),modP=n=>mod$1(n,secp256k1P),modN=n=>mod$1(n,secp256k1N),Point=secp256k1$1.ProjectivePoint,GmulAdd=(n,e,t)=>Point.BASE.multiplyAndAddUnsafe(n,e,t);function schnorrGetExtPubKey$1(n){let e=secp256k1$1.utils.normPrivateKeyToScalar(n),t=Point.fromPrivateKey(e);return{scalar:t.hasEvenY()?e:modN(-e),bytes:pointToBytes$1(t)}}function lift_x$1(n){if(!fe(n))throw new Error("bad x: need 0 < x < p");const e=modP(n*n),t=modP(e*n+BigInt(7));let r=sqrtMod$1(t);r%_2n$3!==_0n$5&&(r=modP(-r));const s=new Point(n,r,_1n$5);return s.assertValidity(),s}function challenge$1(...n){return modN(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge",...n)))}function schnorrGetPublicKey$1(n){return schnorrGetExtPubKey$1(n).bytes}function schnorrSign$1(n,e,t=randomBytes$2(32)){const r=ensureBytes$1("message",n),{bytes:s,scalar:o}=schnorrGetExtPubKey$1(e),a=ensureBytes$1("auxRand",t,32),c=numTo32b(o^bytesToNumberBE$1(taggedHash$1("BIP0340/aux",a))),l=taggedHash$1("BIP0340/nonce",c,s,r),u=modN(bytesToNumberBE$1(l));if(u===_0n$5)throw new Error("sign failed: k is zero");const{bytes:f,scalar:h}=schnorrGetExtPubKey$1(u),p=challenge$1(f,s,r),g=new Uint8Array(64);if(g.set(f,0),g.set(numTo32b(modN(h+p*o)),32),!schnorrVerify$1(g,r,s))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify$1(n,e,t){const r=ensureBytes$1("signature",n,64),s=ensureBytes$1("message",e),o=ensureBytes$1("publicKey",t,32);try{const a=lift_x$1(bytesToNumberBE$1(o)),c=bytesToNumberBE$1(r.subarray(0,32));if(!fe(c))return!1;const l=bytesToNumberBE$1(r.subarray(32,64));if(!ge(l))return!1;const u=challenge$1(numTo32b(c),pointToBytes$1(a),s),f=GmulAdd(a,l,modN(-u));return!(!f||!f.hasEvenY()||f.toAffine().x!==c)}catch{return!1}}const schnorr$1={getPublicKey:schnorrGetPublicKey$1,sign:schnorrSign$1,verify:schnorrVerify$1,utils:{randomPrivateKey:secp256k1$1.utils.randomPrivateKey,lift_x:lift_x$1,pointToBytes:pointToBytes$1,numberToBytesBE:numberToBytesBE$1,bytesToNumberBE:bytesToNumberBE$1,taggedHash:taggedHash$1,mod:mod$1}},crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=n=>n instanceof Uint8Array,u32$1=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView$2=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr$1=(n,e)=>n<<32-e|n>>>e,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes$1=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$1(n){if(!u8a(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=hexes$1[n[t]];return e}function hexToBytes$1(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const t=new Uint8Array(e/2);for(let r=0;r<t.length;r++){const s=r*2,o=n.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");t[r]=a}return t}function utf8ToBytes$2(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$2(n){if(typeof n=="string"&&(n=utf8ToBytes$2(n)),!u8a(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes$1(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!u8a(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}let Hash$1=class{clone(){return this._cloneInto()}};const isPlainObject=n=>Object.prototype.toString.call(n)==="[object Object]"&&n.constructor===Object;function checkOpts$1(n,e){if(e!==void 0&&(typeof e!="object"||!isPlainObject(e)))throw new Error("Options should be object or undefined");return Object.assign(n,e)}function wrapConstructor(n){const e=r=>n().update(toBytes$2(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function randomBytes$1(n=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function number$1(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bool$1(n){if(typeof n!="boolean")throw new Error(`Expected boolean, not ${n}`)}function bytes$1(n,...e){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(n.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`)}function hash(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(n.outputLen),number$1(n.blockLen)}function exists$1(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function output$1(n,e){bytes$1(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists:exists$1,output:output$1};function setBigUint64$2(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(t>>s&o),c=Number(t&o),l=r?4:0,u=r?0:4;n.setUint32(e+l,a,r),n.setUint32(e+u,c,r)}class SHA2 extends Hash$1{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$2(this.buffer)}update(e){assert.exists(this);const{view:t,buffer:r,blockLen:s}=this;e=toBytes$2(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$2(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){assert.exists(this),assert.output(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let h=a;h<s;h++)t[h]=0;setBigUint64$2(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$2(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,f=this.get();if(u>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,f[h],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%t&&e.buffer.set(r),e}}const Chi$1=(n,e,t)=>n&e^~n&t,Maj$1=(n,e,t)=>n&e^n&t^e&t,SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$1=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,t,r,s,o,a,c,l]}set(e,t,r,s,o,a,c,l){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,t){for(let h=0;h<16;h++,t+=4)SHA256_W$1[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const p=SHA256_W$1[h-15],g=SHA256_W$1[h-2],b=rotr$1(p,7)^rotr$1(p,18)^p>>>3,m=rotr$1(g,17)^rotr$1(g,19)^g>>>10;SHA256_W$1[h]=m+SHA256_W$1[h-7]+b+SHA256_W$1[h-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:f}=this;for(let h=0;h<64;h++){const p=rotr$1(c,6)^rotr$1(c,11)^rotr$1(c,25),g=f+p+Chi$1(c,l,u)+SHA256_K$1[h]+SHA256_W$1[h]|0,m=(rotr$1(r,2)^rotr$1(r,13)^rotr$1(r,22))+Maj$1(r,s,o)|0;f=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+m|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,u,f)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$1{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$2=wrapConstructor(()=>new SHA256$1);wrapConstructor(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(n){if(!Number.isSafeInteger(n))throw new Error(`Wrong integer: ${n}`)}function chain(...n){const e=(s,o)=>a=>s(o(a)),t=Array.from(n).reverse().reduce((s,o)=>s?e(s,o.encode):o.encode,void 0),r=n.reduce((s,o)=>s?e(s,o.decode):o.decode,void 0);return{encode:t,decode:r}}function alphabet(n){return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return e.map(t=>{if(assertNumber(t),t<0||t>=n.length)throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${n.length})`);return n[t]})},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("alphabet.decode input should be array of strings");return e.map(t=>{if(typeof t!="string")throw new Error(`alphabet.decode: not string element=${t}`);const r=n.indexOf(t);if(r===-1)throw new Error(`Unknown letter: "${t}". Allowed: ${n}`);return r})}}}function join(n=""){if(typeof n!="string")throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("join.encode input should be array of strings");for(let t of e)if(typeof t!="string")throw new Error(`join.encode: non-string input=${t}`);return e.join(n)},decode:e=>{if(typeof e!="string")throw new Error("join.decode input should be string");return e.split(n)}}}function padding(n,e="="){if(assertNumber(n),typeof e!="string")throw new Error("padding chr should be string");return{encode(t){if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of t)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;t.length*n%8;)t.push(e);return t},decode(t){if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of t)if(typeof s!="string")throw new Error(`padding.decode: non-string input=${s}`);let r=t.length;if(r*n%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&t[r-1]===e;r--)if(!((r-1)*n%8))throw new Error("Invalid padding: string has too much padding");return t.slice(0,r)}}}function normalize$1(n){if(typeof n!="function")throw new Error("normalize fn should be function");return{encode:e=>e,decode:e=>n(e)}}function convertRadix(n,e,t){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(t<2)throw new Error(`convertRadix: wrong to=${t}, base cannot be less than 2`);if(!Array.isArray(n))throw new Error("convertRadix: data should be array");if(!n.length)return[];let r=0;const s=[],o=Array.from(n);for(o.forEach(a=>{if(assertNumber(a),a<0||a>=e)throw new Error(`Wrong integer: ${a}`)});;){let a=0,c=!0;for(let l=r;l<o.length;l++){const u=o[l],f=e*a+u;if(!Number.isSafeInteger(f)||e*a/e!==a||f-u!==e*a)throw new Error("convertRadix: carry overflow");if(a=f%t,o[l]=Math.floor(f/t),!Number.isSafeInteger(o[l])||o[l]*t+a!==f)throw new Error("convertRadix: carry overflow");if(c)o[l]?c=!1:r=l;else continue}if(s.push(a),c)break}for(let a=0;a<n.length-1&&n[a]===0;a++)s.push(0);return s.reverse()}const gcd=(n,e)=>e?gcd(e,n%e):n,radix2carry=(n,e)=>n+(e-gcd(n,e));function convertRadix2(n,e,t,r){if(!Array.isArray(n))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(t<=0||t>32)throw new Error(`convertRadix2: wrong to=${t}`);if(radix2carry(e,t)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${radix2carry(e,t)}`);let s=0,o=0;const a=2**t-1,c=[];for(const l of n){if(assertNumber(l),l>=2**e)throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);if(s=s<<e|l,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=t;o-=t)c.push((s>>o-t&a)>>>0);s&=2**o-1}if(s=s<<t-o&a,!r&&o>=e)throw new Error("Excess padding");if(!r&&s)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&c.push(s>>>0),c}function radix(n){return assertNumber(n),{encode:e=>{if(!(e instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(e),2**8,n)},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(e,n,2**8))}}}function radix2(n,e=!1){if(assertNumber(n),n<=0||n>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,n)>32||radix2carry(n,8)>32)throw new Error("radix2: carry overflow");return{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(t),8,n,!e)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2(t,n,8,e))}}}function unsafeWrapper(n){if(typeof n!="function")throw new Error("unsafeWrapper fn should be function");return function(...e){try{return n.apply(null,e)}catch{}}}const base16=chain(radix2(4),alphabet("0123456789ABCDEF"),join("")),base32=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join(""),normalize$1(n=>n.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join("")),base64url=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join("")),genBase58=n=>chain(radix(58),alphabet(n),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(n){let e="";for(let t=0;t<n.length;t+=8){const r=n.subarray(t,t+8);e+=base58.encode(r).padStart(XMR_BLOCK_LEN[r.length],"1")}return e},decode(n){let e=[];for(let t=0;t<n.length;t+=11){const r=n.slice(t,t+11),s=XMR_BLOCK_LEN.indexOf(r.length),o=base58.decode(r);for(let a=0;a<o.length-s;a++)if(o[a]!==0)throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(o.slice(o.length-s)))}return Uint8Array.from(e)}},BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(n){const e=n>>25;let t=(n&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS.length;r++)(e>>r&1)===1&&(t^=POLYMOD_GENERATORS[r]);return t}function bechChecksum(n,e,t=1){const r=n.length;let s=1;for(let o=0;o<r;o++){const a=n.charCodeAt(o);if(a<33||a>126)throw new Error(`Invalid prefix (${n})`);s=bech32Polymod(s)^a>>5}s=bech32Polymod(s);for(let o=0;o<r;o++)s=bech32Polymod(s)^n.charCodeAt(o)&31;for(let o of e)s=bech32Polymod(s)^o;for(let o=0;o<6;o++)s=bech32Polymod(s);return s^=t,BECH_ALPHABET.encode(convertRadix2([s%2**30],30,5,!1))}function genBech32(n){const e=n==="bech32"?1:734539939,t=radix2(5),r=t.decode,s=t.encode,o=unsafeWrapper(r);function a(f,h,p=90){if(typeof f!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);if(!Array.isArray(h)||h.length&&typeof h[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof h}`);const g=f.length+7+h.length;if(p!==!1&&g>p)throw new TypeError(`Length ${g} exceeds limit ${p}`);return f=f.toLowerCase(),`${f}1${BECH_ALPHABET.encode(h)}${bechChecksum(f,h,e)}`}function c(f,h=90){if(typeof f!="string")throw new Error(`bech32.decode input should be string, not ${typeof f}`);if(f.length<8||h!==!1&&f.length>h)throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${h})`);const p=f.toLowerCase();if(f!==p&&f!==f.toUpperCase())throw new Error("String must be lowercase or uppercase");f=p;const g=f.lastIndexOf("1");if(g===0||g===-1)throw new Error('Letter "1" must be present between prefix and data only');const b=f.slice(0,g),m=f.slice(g+1);if(m.length<6)throw new Error("Data must be at least 6 characters long");const E=BECH_ALPHABET.decode(m).slice(0,-6),_=bechChecksum(b,E,e);if(!m.endsWith(_))throw new Error(`Invalid checksum in ${f}: expected "${_}"`);return{prefix:b,words:E}}const l=unsafeWrapper(c);function u(f){const{prefix:h,words:p}=c(f,!1);return{prefix:h,words:p,bytes:r(p)}}return{encode:a,decode:c,decodeToBytes:u,decodeUnsafe:l,fromWords:r,fromWordsUnsafe:o,toWords:s}}const bech32$1=genBech32("bech32");genBech32("bech32m");const utf8$1={encode:n=>new TextDecoder().decode(n),decode:n=>new TextEncoder().encode(n)},hex$1=chain(radix2(4),alphabet("0123456789abcdef"),join(""),normalize$1(n=>{if(typeof n!="string"||n.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof n} with length ${n.length}`);return n.toLowerCase()})),CODERS={utf8:utf8$1,hex:hex$1,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bool(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function isBytes$1(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function bytes(n,...e){if(!isBytes$1(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${n.length}`)}function exists(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function output(n,e){bytes(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView$1=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$1(n){if(typeof n!="string")throw new Error(`string expected, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$1(n){if(typeof n=="string")n=utf8ToBytes$1(n);else if(isBytes$1(n))n=n.slice();else throw new Error(`Uint8Array expected, got ${typeof n}`);return n}function checkOpts(n,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(n,e)}function equalBytes(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const wrapCipher=(n,e)=>(Object.assign(e,n),e);function setBigUint64$1(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(t>>s&o),c=Number(t&o),l=4,u=0;n.setUint32(e+l,a,r),n.setUint32(e+u,c,r)}const BLOCK_SIZE=16,POLY=283;function mul2(n){return n<<1^POLY&-(n>>7)}function mul(n,e){let t=0;for(;e>0;e>>=1)t^=n&-(e&1),n=mul2(n);return t}const sbox=(()=>{let n=new Uint8Array(256);for(let t=0,r=1;t<256;t++,r^=mul2(r))n[t]=r;const e=new Uint8Array(256);e[0]=99;for(let t=0;t<255;t++){let r=n[255-t];r|=r<<8,e[n[t]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return e})(),invSbox=sbox.map((n,e)=>sbox.indexOf(e)),rotr32_8=n=>n<<24|n>>>8,rotl32_8=n=>n<<8|n>>>24;function genTtable(n,e){if(n.length!==256)throw new Error("Wrong sbox length");const t=new Uint32Array(256).map((u,f)=>e(n[f])),r=t.map(rotl32_8),s=r.map(rotl32_8),o=s.map(rotl32_8),a=new Uint32Array(256*256),c=new Uint32Array(256*256),l=new Uint16Array(256*256);for(let u=0;u<256;u++)for(let f=0;f<256;f++){const h=u*256+f;a[h]=t[u]^r[f],c[h]=s[u]^o[f],l[h]=n[u]<<8|n[f]}return{sbox:n,sbox2:l,T0:t,T1:r,T2:s,T3:o,T01:a,T23:c}}const tableEncoding=genTtable(sbox,n=>mul(n,3)<<24|n<<16|n<<8|mul(n,2)),tableDecoding=genTtable(invSbox,n=>mul(n,11)<<24|mul(n,13)<<16|mul(n,9)<<8|mul(n,14)),xPowers=(()=>{const n=new Uint8Array(16);for(let e=0,t=1;e<16;e++,t=mul2(t))n[e]=t;return n})();function expandKeyLE(n){bytes(n);const e=n.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:t}=tableEncoding,r=u32(n),s=r.length,o=c=>applySbox(t,c,c,c,c),a=new Uint32Array(e+28);a.set(r);for(let c=s;c<a.length;c++){let l=a[c-1];c%s===0?l=o(rotr32_8(l))^xPowers[c/s-1]:s>6&&c%s===4&&(l=o(l)),a[c]=a[c-s]^l}return a}function expandKeyDecLE(n){const e=expandKeyLE(n),t=e.slice(),r=e.length,{sbox2:s}=tableEncoding,{T0:o,T1:a,T2:c,T3:l}=tableDecoding;for(let u=0;u<r;u+=4)for(let f=0;f<4;f++)t[u+f]=e[r-u-4+f];e.fill(0);for(let u=4;u<r-4;u++){const f=t[u],h=applySbox(s,f,f,f,f);t[u]=o[h&255]^a[h>>>8&255]^c[h>>>16&255]^l[h>>>24]}return t}function apply0123(n,e,t,r,s,o){return n[t<<8&65280|r>>>8&255]^e[s>>>8&65280|o>>>24&255]}function applySbox(n,e,t,r,s){return n[e&255|t&65280]|n[r>>>16&255|s>>>16&65280]<<16}function encrypt$3(n,e,t,r,s){const{sbox2:o,T01:a,T23:c}=tableEncoding;let l=0;e^=n[l++],t^=n[l++],r^=n[l++],s^=n[l++];const u=n.length/4-2;for(let b=0;b<u;b++){const m=n[l++]^apply0123(a,c,e,t,r,s),E=n[l++]^apply0123(a,c,t,r,s,e),_=n[l++]^apply0123(a,c,r,s,e,t),C=n[l++]^apply0123(a,c,s,e,t,r);e=m,t=E,r=_,s=C}const f=n[l++]^applySbox(o,e,t,r,s),h=n[l++]^applySbox(o,t,r,s,e),p=n[l++]^applySbox(o,r,s,e,t),g=n[l++]^applySbox(o,s,e,t,r);return{s0:f,s1:h,s2:p,s3:g}}function decrypt$3(n,e,t,r,s){const{sbox2:o,T01:a,T23:c}=tableDecoding;let l=0;e^=n[l++],t^=n[l++],r^=n[l++],s^=n[l++];const u=n.length/4-2;for(let b=0;b<u;b++){const m=n[l++]^apply0123(a,c,e,s,r,t),E=n[l++]^apply0123(a,c,t,e,s,r),_=n[l++]^apply0123(a,c,r,t,e,s),C=n[l++]^apply0123(a,c,s,r,t,e);e=m,t=E,r=_,s=C}const f=n[l++]^applySbox(o,e,s,r,t),h=n[l++]^applySbox(o,t,e,s,r),p=n[l++]^applySbox(o,r,t,e,s),g=n[l++]^applySbox(o,s,r,t,e);return{s0:f,s1:h,s2:p,s3:g}}function getDst(n,e){if(!e)return new Uint8Array(n);if(bytes(e),e.length<n)throw new Error(`aes: wrong destination length, expected at least ${n}, got: ${e.length}`);return e}function validateBlockDecrypt(n){if(bytes(n),n.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(n,e,t){let r=n.length;const s=r%BLOCK_SIZE;if(!e&&s!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const o=u32(n);if(e){let l=BLOCK_SIZE-s;l||(l=BLOCK_SIZE),r=r+l}const a=getDst(r,t),c=u32(a);return{b:o,o:c,out:a}}function validatePCKS(n,e){if(!e)return n;const t=n.length;if(!t)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=n[t-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const s=n.subarray(0,-r);for(let o=0;o<r;o++)if(n[t-o-1]!==r)throw new Error("aes/pcks5: wrong padding");return s}function padPCKS(n){const e=new Uint8Array(16),t=u32(e);e.set(n);const r=BLOCK_SIZE-n.length;for(let s=BLOCK_SIZE-r;s<BLOCK_SIZE;s++)e[s]=r;return t}const cbc=wrapCipher({blockSize:16,nonceLength:16},function n(e,t,r={}){bytes(e),bytes(t,16);const s=!r.disablePadding;return{encrypt:(o,a)=>{const c=expandKeyLE(e),{b:l,o:u,out:f}=validateBlockEncrypt(o,s,a),h=u32(t);let p=h[0],g=h[1],b=h[2],m=h[3],E=0;for(;E+4<=l.length;)p^=l[E+0],g^=l[E+1],b^=l[E+2],m^=l[E+3],{s0:p,s1:g,s2:b,s3:m}=encrypt$3(c,p,g,b,m),u[E++]=p,u[E++]=g,u[E++]=b,u[E++]=m;if(s){const _=padPCKS(o.subarray(E*4));p^=_[0],g^=_[1],b^=_[2],m^=_[3],{s0:p,s1:g,s2:b,s3:m}=encrypt$3(c,p,g,b,m),u[E++]=p,u[E++]=g,u[E++]=b,u[E++]=m}return c.fill(0),f},decrypt:(o,a)=>{validateBlockDecrypt(o);const c=expandKeyDecLE(e),l=u32(t),u=getDst(o.length,a),f=u32(o),h=u32(u);let p=l[0],g=l[1],b=l[2],m=l[3];for(let E=0;E+4<=f.length;){const _=p,C=g,I=b,P=m;p=f[E+0],g=f[E+1],b=f[E+2],m=f[E+3];const{s0:M,s1:L,s2:F,s3:K}=decrypt$3(c,p,g,b,m);h[E++]=M^_,h[E++]=L^C,h[E++]=F^I,h[E++]=K^P}return c.fill(0),validatePCKS(u,s)}}}),u8to16=(n,e)=>n[e++]&255|(n[e++]&255)<<8;class Poly1305{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=toBytes$1(e),bytes(e,32);const t=u8to16(e,0),r=u8to16(e,2),s=u8to16(e,4),o=u8to16(e,6),a=u8to16(e,8),c=u8to16(e,10),l=u8to16(e,12),u=u8to16(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|o<<9)&8191,this.r[4]=(o>>>4|a<<12)&255,this.r[5]=a>>>1&8190,this.r[6]=(a>>>14|c<<2)&8191,this.r[7]=(c>>>11|l<<5)&8065,this.r[8]=(l>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let f=0;f<8;f++)this.pad[f]=u8to16(e,16+2*f)}process(e,t,r=!1){const s=r?0:2048,{h:o,r:a}=this,c=a[0],l=a[1],u=a[2],f=a[3],h=a[4],p=a[5],g=a[6],b=a[7],m=a[8],E=a[9],_=u8to16(e,t+0),C=u8to16(e,t+2),I=u8to16(e,t+4),P=u8to16(e,t+6),M=u8to16(e,t+8),L=u8to16(e,t+10),F=u8to16(e,t+12),K=u8to16(e,t+14);let U=o[0]+(_&8191),O=o[1]+((_>>>13|C<<3)&8191),T=o[2]+((C>>>10|I<<6)&8191),x=o[3]+((I>>>7|P<<9)&8191),v=o[4]+((P>>>4|M<<12)&8191),$=o[5]+(M>>>1&8191),w=o[6]+((M>>>14|L<<2)&8191),k=o[7]+((L>>>11|F<<5)&8191),S=o[8]+((F>>>8|K<<8)&8191),N=o[9]+(K>>>5|s),A=0,B=A+U*c+O*(5*E)+T*(5*m)+x*(5*b)+v*(5*g);A=B>>>13,B&=8191,B+=$*(5*p)+w*(5*h)+k*(5*f)+S*(5*u)+N*(5*l),A+=B>>>13,B&=8191;let R=A+U*l+O*c+T*(5*E)+x*(5*m)+v*(5*b);A=R>>>13,R&=8191,R+=$*(5*g)+w*(5*p)+k*(5*h)+S*(5*f)+N*(5*u),A+=R>>>13,R&=8191;let D=A+U*u+O*l+T*c+x*(5*E)+v*(5*m);A=D>>>13,D&=8191,D+=$*(5*b)+w*(5*g)+k*(5*p)+S*(5*h)+N*(5*f),A+=D>>>13,D&=8191;let z=A+U*f+O*u+T*l+x*c+v*(5*E);A=z>>>13,z&=8191,z+=$*(5*m)+w*(5*b)+k*(5*g)+S*(5*p)+N*(5*h),A+=z>>>13,z&=8191;let H=A+U*h+O*f+T*u+x*l+v*c;A=H>>>13,H&=8191,H+=$*(5*E)+w*(5*m)+k*(5*b)+S*(5*g)+N*(5*p),A+=H>>>13,H&=8191;let V=A+U*p+O*h+T*f+x*u+v*l;A=V>>>13,V&=8191,V+=$*c+w*(5*E)+k*(5*m)+S*(5*b)+N*(5*g),A+=V>>>13,V&=8191;let j=A+U*g+O*p+T*h+x*f+v*u;A=j>>>13,j&=8191,j+=$*l+w*c+k*(5*E)+S*(5*m)+N*(5*b),A+=j>>>13,j&=8191;let q=A+U*b+O*g+T*p+x*h+v*f;A=q>>>13,q&=8191,q+=$*u+w*l+k*c+S*(5*E)+N*(5*m),A+=q>>>13,q&=8191;let G=A+U*m+O*b+T*g+x*p+v*h;A=G>>>13,G&=8191,G+=$*f+w*u+k*l+S*c+N*(5*E),A+=G>>>13,G&=8191;let W=A+U*E+O*m+T*b+x*g+v*p;A=W>>>13,W&=8191,W+=$*h+w*f+k*u+S*l+N*c,A+=W>>>13,W&=8191,A=(A<<2)+A|0,A=A+B|0,B=A&8191,A=A>>>13,R+=A,o[0]=B,o[1]=R,o[2]=D,o[3]=z,o[4]=H,o[5]=V,o[6]=j,o[7]=q,o[8]=G,o[9]=W}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=s,s=e[c]>>>13,e[c]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,r[0]=e[0]+5,s=r[0]>>>13,r[0]&=8191;for(let c=1;c<10;c++)r[c]=e[c]+s,s=r[c]>>>13,r[c]&=8191;r[9]-=8192;let o=(s^1)-1;for(let c=0;c<10;c++)r[c]&=o;o=~o;for(let c=0;c<10;c++)e[c]=e[c]&o|r[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let a=e[0]+t[0];e[0]=a&65535;for(let c=1;c<8;c++)a=(e[c]+t[c]|0)+(a>>>16)|0,e[c]=a&65535}update(e){exists(this);const{buffer:t,blockLen:r}=this;e=toBytes$1(e);const s=e.length;for(let o=0;o<s;){const a=Math.min(r-this.pos,s-o);if(a===r){for(;r<=s-o;o+=r)this.process(e,o);continue}t.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let o=0;for(let a=0;a<8;a++)e[o++]=r[a]>>>0,e[o++]=r[a]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function wrapConstructorWithKey(n){const e=(r,s)=>n(s).update(toBytes$1(r)).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const poly1305=wrapConstructorWithKey(n=>new Poly1305(n)),_utf8ToBytes=n=>Uint8Array.from(n.split("").map(e=>e.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl$1(n,e){return n<<e|n>>>32-e}function isAligned32(n){return n.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(n,e,t,r,s,o,a,c){const l=s.length,u=new Uint8Array(BLOCK_LEN),f=u32(u),h=isAligned32(s)&&isAligned32(o),p=h?u32(s):U32_EMPTY,g=h?u32(o):U32_EMPTY;for(let b=0;b<l;a++){if(n(e,t,r,f,a,c),a>=MAX_COUNTER)throw new Error("arx: counter overflow");const m=Math.min(BLOCK_LEN,l-b);if(h&&m===BLOCK_LEN){const E=b/4;if(b%4!==0)throw new Error("arx: invalid block position");for(let _=0,C;_<BLOCK_LEN32;_++)C=E+_,g[C]=p[C]^f[_];b+=BLOCK_LEN;continue}for(let E=0,_;E<m;E++)_=b+E,o[_]=s[_]^u[E];b+=m}}function createCipher(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:s,counterRight:o,rounds:a}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return number(s),number(a),bool(o),bool(t),(c,l,u,f,h=0)=>{bytes(c),bytes(l),bytes(u);const p=u.length;if(f||(f=new Uint8Array(p)),bytes(f),number(h),h<0||h>=MAX_COUNTER)throw new Error("arx: counter overflow");if(f.length<p)throw new Error(`arx: output (${f.length}) is shorter than data (${p})`);const g=[];let b=c.length,m,E;if(b===32)m=c.slice(),g.push(m),E=sigma32_32;else if(b===16&&t)m=new Uint8Array(32),m.set(c),m.set(c,16),E=sigma16_32,g.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${b}`);isAligned32(l)||(l=l.slice(),g.push(l));const _=u32(m);if(r){if(l.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(E,_,u32(l.subarray(0,16)),_),l=l.subarray(16)}const C=16-s;if(C!==l.length)throw new Error(`arx: nonce must be ${C} or 16 bytes`);if(C!==12){const P=new Uint8Array(12);P.set(l,o?0:12-l.length),l=P,g.push(l)}const I=u32(l);for(runCipher(n,E,_,I,u,f,h,a);g.length>0;)g.pop().fill(0);return f}}function chachaCore(n,e,t,r,s,o=20){let a=n[0],c=n[1],l=n[2],u=n[3],f=e[0],h=e[1],p=e[2],g=e[3],b=e[4],m=e[5],E=e[6],_=e[7],C=s,I=t[0],P=t[1],M=t[2],L=a,F=c,K=l,U=u,O=f,T=h,x=p,v=g,$=b,w=m,k=E,S=_,N=C,A=I,B=P,R=M;for(let z=0;z<o;z+=2)L=L+O|0,N=rotl$1(N^L,16),$=$+N|0,O=rotl$1(O^$,12),L=L+O|0,N=rotl$1(N^L,8),$=$+N|0,O=rotl$1(O^$,7),F=F+T|0,A=rotl$1(A^F,16),w=w+A|0,T=rotl$1(T^w,12),F=F+T|0,A=rotl$1(A^F,8),w=w+A|0,T=rotl$1(T^w,7),K=K+x|0,B=rotl$1(B^K,16),k=k+B|0,x=rotl$1(x^k,12),K=K+x|0,B=rotl$1(B^K,8),k=k+B|0,x=rotl$1(x^k,7),U=U+v|0,R=rotl$1(R^U,16),S=S+R|0,v=rotl$1(v^S,12),U=U+v|0,R=rotl$1(R^U,8),S=S+R|0,v=rotl$1(v^S,7),L=L+T|0,R=rotl$1(R^L,16),k=k+R|0,T=rotl$1(T^k,12),L=L+T|0,R=rotl$1(R^L,8),k=k+R|0,T=rotl$1(T^k,7),F=F+x|0,N=rotl$1(N^F,16),S=S+N|0,x=rotl$1(x^S,12),F=F+x|0,N=rotl$1(N^F,8),S=S+N|0,x=rotl$1(x^S,7),K=K+v|0,A=rotl$1(A^K,16),$=$+A|0,v=rotl$1(v^$,12),K=K+v|0,A=rotl$1(A^K,8),$=$+A|0,v=rotl$1(v^$,7),U=U+O|0,B=rotl$1(B^U,16),w=w+B|0,O=rotl$1(O^w,12),U=U+O|0,B=rotl$1(B^U,8),w=w+B|0,O=rotl$1(O^w,7);let D=0;r[D++]=a+L|0,r[D++]=c+F|0,r[D++]=l+K|0,r[D++]=u+U|0,r[D++]=f+O|0,r[D++]=h+T|0,r[D++]=p+x|0,r[D++]=g+v|0,r[D++]=b+$|0,r[D++]=m+w|0,r[D++]=E+k|0,r[D++]=_+S|0,r[D++]=C+N|0,r[D++]=I+A|0,r[D++]=P+B|0,r[D++]=M+R|0}function hchacha(n,e,t,r){let s=n[0],o=n[1],a=n[2],c=n[3],l=e[0],u=e[1],f=e[2],h=e[3],p=e[4],g=e[5],b=e[6],m=e[7],E=t[0],_=t[1],C=t[2],I=t[3];for(let M=0;M<20;M+=2)s=s+l|0,E=rotl$1(E^s,16),p=p+E|0,l=rotl$1(l^p,12),s=s+l|0,E=rotl$1(E^s,8),p=p+E|0,l=rotl$1(l^p,7),o=o+u|0,_=rotl$1(_^o,16),g=g+_|0,u=rotl$1(u^g,12),o=o+u|0,_=rotl$1(_^o,8),g=g+_|0,u=rotl$1(u^g,7),a=a+f|0,C=rotl$1(C^a,16),b=b+C|0,f=rotl$1(f^b,12),a=a+f|0,C=rotl$1(C^a,8),b=b+C|0,f=rotl$1(f^b,7),c=c+h|0,I=rotl$1(I^c,16),m=m+I|0,h=rotl$1(h^m,12),c=c+h|0,I=rotl$1(I^c,8),m=m+I|0,h=rotl$1(h^m,7),s=s+u|0,I=rotl$1(I^s,16),b=b+I|0,u=rotl$1(u^b,12),s=s+u|0,I=rotl$1(I^s,8),b=b+I|0,u=rotl$1(u^b,7),o=o+f|0,E=rotl$1(E^o,16),m=m+E|0,f=rotl$1(f^m,12),o=o+f|0,E=rotl$1(E^o,8),m=m+E|0,f=rotl$1(f^m,7),a=a+h|0,_=rotl$1(_^a,16),p=p+_|0,h=rotl$1(h^p,12),a=a+h|0,_=rotl$1(_^a,8),p=p+_|0,h=rotl$1(h^p,7),c=c+l|0,C=rotl$1(C^c,16),g=g+C|0,l=rotl$1(l^g,12),c=c+l|0,C=rotl$1(C^c,8),g=g+C|0,l=rotl$1(l^g,7);let P=0;r[P++]=s,r[P++]=o,r[P++]=a,r[P++]=c,r[P++]=E,r[P++]=_,r[P++]=C,r[P++]=I}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1}),xchacha20=createCipher(chachaCore,{counterRight:!1,counterLength:8,extendNonceFn:hchacha,allowShortKeys:!1}),ZEROS16=new Uint8Array(16),updatePadded=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(ZEROS16.subarray(t))},ZEROS32=new Uint8Array(32);function computeTag(n,e,t,r,s){const o=n(e,t,ZEROS32),a=poly1305.create(o);s&&updatePadded(a,s),updatePadded(a,r);const c=new Uint8Array(16),l=createView$1(c);setBigUint64$1(l,0,BigInt(s?s.length:0),!0),setBigUint64$1(l,8,BigInt(r.length),!0),a.update(c);const u=a.digest();return o.fill(0),u}const _poly1305_aead=n=>(e,t,r)=>(bytes(e,32),bytes(t),{encrypt:(o,a)=>{const c=o.length,l=c+16;a?bytes(a,l):a=new Uint8Array(l),n(e,t,o,a,1);const u=computeTag(n,e,t,a.subarray(0,-16),r);return a.set(u,c),a},decrypt:(o,a)=>{const c=o.length,l=c-16;if(c<16)throw new Error("encrypted data must be at least 16 bytes");a?bytes(a,l):a=new Uint8Array(l);const u=o.subarray(0,-16),f=o.subarray(-16),h=computeTag(n,e,t,u,r);if(!equalBytes(f,h))throw new Error("invalid tag");return n(e,t,u,a,1),a}}),xchacha20poly1305=wrapCipher({blockSize:64,nonceLength:24,tagLength:16},_poly1305_aead(xchacha20));let HMAC$1=class extends Hash$1{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,assert.hash(e);const r=toBytes$2(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return assert.exists(this),this.iHash.update(e),this}digestInto(e){assert.exists(this),assert.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(n,e,t)=>new HMAC$1(n,e).update(t).digest();hmac$1.create=(n,e)=>new HMAC$1(n,e);function extract(n,e,t){return assert.hash(n),hmac$1(n,toBytes$2(t),toBytes$2(e))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(n,e,t,r=32){if(assert.hash(n),assert.number(r),r>255*n.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(r/n.outputLen);t===void 0&&(t=EMPTY_BUFFER);const o=new Uint8Array(s*n.outputLen),a=hmac$1.create(n,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)HKDF_COUNTER[0]=u+1,c.update(u===0?EMPTY_BUFFER:l).update(t).update(HKDF_COUNTER).digestInto(l),o.set(l,n.outputLen*u),a._cloneInto(c);return a.destroy(),c.destroy(),l.fill(0),HKDF_COUNTER.fill(0),o.slice(0,r)}var __defProp$1=Object.defineProperty,__export=(n,e)=>{for(var t in e)__defProp$1(n,t,{get:e[t],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=n=>n instanceof Object;function validateEvent(n){if(!isRecord(n)||typeof n.kind!="number"||typeof n.content!="string"||typeof n.created_at!="number"||typeof n.pubkey!="string"||!n.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(n.tags))return!1;for(let e=0;e<n.tags.length;e++){let t=n.tags[e];if(!Array.isArray(t))return!1;for(let r=0;r<t.length;r++)if(typeof t[r]!="string")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue$1,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,bytesToHex:()=>bytesToHex$1,hexToBytes:()=>hexToBytes$1,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder$1,utf8Encoder:()=>utf8Encoder$1});var utf8Decoder$1=new TextDecoder("utf-8"),utf8Encoder$1=new TextEncoder;function normalizeURL(n){try{n.indexOf("://")===-1&&(n="wss://"+n);let e=new URL(n);return e.pathname=e.pathname.replace(/\/+/g,"/"),e.pathname.endsWith("/")&&(e.pathname=e.pathname.slice(0,-1)),(e.port==="80"&&e.protocol==="ws:"||e.port==="443"&&e.protocol==="wss:")&&(e.port=""),e.searchParams.sort(),e.hash="",e.toString()}catch{throw new Error(`Invalid URL: ${n}`)}}function insertEventIntoDescendingList(n,e){const[t,r]=binarySearch(n,s=>e.id===s.id?0:e.created_at===s.created_at?-1:s.created_at-e.created_at);return r||n.splice(t,0,e),n}function insertEventIntoAscendingList(n,e){const[t,r]=binarySearch(n,s=>e.id===s.id?0:e.created_at===s.created_at?-1:e.created_at-s.created_at);return r||n.splice(t,0,e),n}function binarySearch(n,e){let t=0,r=n.length-1;for(;t<=r;){const s=Math.floor((t+r)/2),o=e(n[s]);if(o===0)return[s,!0];o<0?r=s-1:t=s+1}return[t,!1]}var QueueNode=class{constructor(n){y(this,"value");y(this,"next",null);y(this,"prev",null);this.value=n}},Queue$1=class{constructor(){y(this,"first");y(this,"last");this.first=null,this.last=null}enqueue(e){const t=new QueueNode(e);return this.last?this.last===this.first?(this.last=t,this.last.prev=this.first,this.first.next=t):(t.prev=this.last,this.last.next=t,this.last=t):(this.first=t,this.last=t),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const t=this.first;return this.first=null,this.last=null,t.value}const e=this.first;return this.first=e.next,this.first&&(this.first.prev=null),e.value}},JS=class{generateSecretKey(){return schnorr$1.utils.randomPrivateKey()}getPublicKey(n){return bytesToHex$1(schnorr$1.getPublicKey(n))}finalizeEvent(n,e){const t=n;return t.pubkey=bytesToHex$1(schnorr$1.getPublicKey(e)),t.id=getEventHash$1(t),t.sig=bytesToHex$1(schnorr$1.sign(getEventHash$1(t),e)),t[verifiedSymbol]=!0,t}verifyEvent(n){if(typeof n[verifiedSymbol]=="boolean")return n[verifiedSymbol];const e=getEventHash$1(n);if(e!==n.id)return n[verifiedSymbol]=!1,!1;try{const t=schnorr$1.verify(n.sig,e,n.pubkey);return n[verifiedSymbol]=t,t}catch{return n[verifiedSymbol]=!1,!1}}};function serializeEvent(n){if(!validateEvent(n))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content])}function getEventHash$1(n){let e=sha256$2(utf8Encoder$1.encode(serializeEvent(n)));return bytesToHex$1(e)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isAddressableKind:()=>isAddressableKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(n){return 1e3<=n&&n<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(n)}function isReplaceableKind(n){return[0,3].includes(n)||1e4<=n&&n<2e4}function isEphemeralKind(n){return 2e4<=n&&n<3e4}function isAddressableKind(n){return 3e4<=n&&n<4e4}function classifyKind(n){return isRegularKind(n)?"regular":isReplaceableKind(n)?"replaceable":isEphemeralKind(n)?"ephemeral":isAddressableKind(n)?"parameterized":"unknown"}function isKind(n,e){const t=e instanceof Array?e:[e];return validateEvent(n)&&t.includes(n.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550;function matchFilter(n,e){if(n.ids&&n.ids.indexOf(e.id)===-1||n.kinds&&n.kinds.indexOf(e.kind)===-1||n.authors&&n.authors.indexOf(e.pubkey)===-1)return!1;for(let t in n)if(t[0]==="#"){let r=t.slice(1),s=n[`#${r}`];if(s&&!e.tags.find(([o,a])=>o===t.slice(1)&&s.indexOf(a)!==-1))return!1}return!(n.since&&e.created_at<n.since||n.until&&e.created_at>n.until)}function matchFilters(n,e){for(let t=0;t<n.length;t++)if(matchFilter(n[t],e))return!0;return!1}var fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(n,e){let t=e.length+3,r=n.indexOf(`"${e}":`)+t,s=n.slice(r).indexOf('"')+r+1;return n.slice(s,s+64)}function getInt(n,e){let t=e.length,r=n.indexOf(`"${e}":`)+t+3,s=n.slice(r),o=Math.min(s.indexOf(","),s.indexOf("}"));return parseInt(s.slice(0,o),10)}function getSubscriptionId(n){let e=n.slice(0,22).indexOf('"EVENT"');if(e===-1)return null;let t=n.slice(e+7+1).indexOf('"');if(t===-1)return null;let r=e+7+1+t,s=n.slice(r+1,80).indexOf('"');if(s===-1)return null;let o=r+1+s;return n.slice(r+1,o)}function matchEventId(n,e){return e===getHex64(n,"id")}function matchEventPubkey(n,e){return e===getHex64(n,"pubkey")}function matchEventKind(n,e){return e===getInt(n,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(n,e){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",n],["challenge",e]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports$1={};__export(nip19_exports$1,{BECH32_REGEX:()=>BECH32_REGEX$2,Bech32MaxSize:()=>Bech32MaxSize$2,NostrTypeGuard:()=>NostrTypeGuard$1,decode:()=>decode$1,decodeNostrURI:()=>decodeNostrURI$1,encodeBytes:()=>encodeBytes$2,naddrEncode:()=>naddrEncode$1,neventEncode:()=>neventEncode$1,noteEncode:()=>noteEncode$1,nprofileEncode:()=>nprofileEncode$1,npubEncode:()=>npubEncode$1,nsecEncode:()=>nsecEncode$1});var NostrTypeGuard$1={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize$2=5e3,BECH32_REGEX$2=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array$1(n){const e=new Uint8Array(4);return e[0]=n>>24&255,e[1]=n>>16&255,e[2]=n>>8&255,e[3]=n&255,e}function decodeNostrURI$1(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode$1(n)}catch{return{type:"invalid",data:null}}}function decode$1(n){var s,o,a,c,l,u,f;let{prefix:e,words:t}=bech32$1.decode(n,Bech32MaxSize$2),r=new Uint8Array(bech32$1.fromWords(t));switch(e){case"nprofile":{let h=parseTLV$1(r);if(!((s=h[0])!=null&&s[0]))throw new Error("missing TLV 0 for nprofile");if(h[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$1(h[0][0]),relays:h[1]?h[1].map(p=>utf8Decoder$1.decode(p)):[]}}}case"nevent":{let h=parseTLV$1(r);if(!((o=h[0])!=null&&o[0]))throw new Error("missing TLV 0 for nevent");if(h[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(h[2]&&h[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(h[3]&&h[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$1(h[0][0]),relays:h[1]?h[1].map(p=>utf8Decoder$1.decode(p)):[],author:(a=h[2])!=null&&a[0]?bytesToHex$1(h[2][0]):void 0,kind:(c=h[3])!=null&&c[0]?parseInt(bytesToHex$1(h[3][0]),16):void 0}}}case"naddr":{let h=parseTLV$1(r);if(!((l=h[0])!=null&&l[0]))throw new Error("missing TLV 0 for naddr");if(!((u=h[2])!=null&&u[0]))throw new Error("missing TLV 2 for naddr");if(h[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((f=h[3])!=null&&f[0]))throw new Error("missing TLV 3 for naddr");if(h[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder$1.decode(h[0][0]),pubkey:bytesToHex$1(h[2][0]),kind:parseInt(bytesToHex$1(h[3][0]),16),relays:h[1]?h[1].map(p=>utf8Decoder$1.decode(p)):[]}}}case"nsec":return{type:e,data:r};case"npub":case"note":return{type:e,data:bytesToHex$1(r)};default:throw new Error(`unknown prefix ${e}`)}}function parseTLV$1(n){let e={},t=n;for(;t.length>0;){let r=t[0],s=t[1],o=t.slice(2,2+s);if(t=t.slice(2+s),o.length<s)throw new Error(`not enough data to read on TLV ${r}`);e[r]=e[r]||[],e[r].push(o)}return e}function nsecEncode$1(n){return encodeBytes$2("nsec",n)}function npubEncode$1(n){return encodeBytes$2("npub",hexToBytes$1(n))}function noteEncode$1(n){return encodeBytes$2("note",hexToBytes$1(n))}function encodeBech32$2(n,e){let t=bech32$1.toWords(e);return bech32$1.encode(n,t,Bech32MaxSize$2)}function encodeBytes$2(n,e){return encodeBech32$2(n,e)}function nprofileEncode$1(n){let e=encodeTLV$1({0:[hexToBytes$1(n.pubkey)],1:(n.relays||[]).map(t=>utf8Encoder$1.encode(t))});return encodeBech32$2("nprofile",e)}function neventEncode$1(n){let e;n.kind!==void 0&&(e=integerToUint8Array$1(n.kind));let t=encodeTLV$1({0:[hexToBytes$1(n.id)],1:(n.relays||[]).map(r=>utf8Encoder$1.encode(r)),2:n.author?[hexToBytes$1(n.author)]:[],3:e?[new Uint8Array(e)]:[]});return encodeBech32$2("nevent",t)}function naddrEncode$1(n){let e=new ArrayBuffer(4);new DataView(e).setUint32(0,n.kind,!1);let t=encodeTLV$1({0:[utf8Encoder$1.encode(n.identifier)],1:(n.relays||[]).map(r=>utf8Encoder$1.encode(r)),2:[hexToBytes$1(n.pubkey)],3:[new Uint8Array(e)]});return encodeBech32$2("naddr",t)}function encodeTLV$1(n){let e=[];return Object.entries(n).reverse().forEach(([t,r])=>{r.forEach(s=>{let o=new Uint8Array(s.length+2);o.set([parseInt(t)],0),o.set([s.length],1),o.set(s,2),e.push(o)})}),concatBytes$1(...e)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt$2,encrypt:()=>encrypt$2});function encrypt$2(n,e,t){const r=n instanceof Uint8Array?bytesToHex$1(n):n,s=secp256k1$1.getSharedSecret(r,"02"+e),o=getNormalizedX(s);let a=Uint8Array.from(randomBytes$1(16)),c=utf8Encoder$1.encode(t),l=cbc(o,a).encrypt(c),u=base64.encode(new Uint8Array(l)),f=base64.encode(new Uint8Array(a.buffer));return`${u}?iv=${f}`}function decrypt$2(n,e,t){const r=n instanceof Uint8Array?bytesToHex$1(n):n;let[s,o]=t.split("?iv="),a=secp256k1$1.getSharedSecret(r,"02"+e),c=getNormalizedX(a),l=base64.decode(o),u=base64.decode(s),f=cbc(c,l).decrypt(u);return utf8Decoder$1.decode(f)}function getNormalizedX(n){return n.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX$1,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX$1=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=n=>NIP05_REGEX$1.test(n||""),_fetch;try{_fetch=fetch}catch(n){}function useFetchImplementation(n){_fetch=n}async function searchDomain(n,e=""){try{const t=`https://${n}/.well-known/nostr.json?name=${e}`,r=await _fetch(t,{redirect:"manual"});if(r.status!==200)throw Error("Wrong response code");return(await r.json()).names}catch{return{}}}async function queryProfile(n){var s;const e=n.match(NIP05_REGEX$1);if(!e)return null;const[,t="_",r]=e;try{const o=`https://${r}/.well-known/nostr.json?name=${t}`,a=await _fetch(o,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const c=await a.json(),l=c.names[t];return l?{pubkey:l,relays:(s=c.relays)==null?void 0:s[l]}:null}catch{return null}}async function isValid(n,e){const t=await queryProfile(e);return t?t.pubkey===n:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(n){const e={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let t,r;for(let s=n.tags.length-1;s>=0;s--){const o=n.tags[s];if(o[0]==="e"&&o[1]){const[a,c,l,u,f]=o,h={id:c,relays:l?[l]:[],author:f};if(u==="root"){e.root=h;continue}if(u==="reply"){e.reply=h;continue}if(u==="mention"){e.mentions.push(h);continue}t?r=h:t=h,e.mentions.push(h);continue}if(o[0]==="q"&&o[1]){const[a,c,l]=o;e.quotes.push({id:c,relays:l?[l]:[]})}if(o[0]==="p"&&o[1]){e.profiles.push({pubkey:o[1],relays:o[2]?[o[2]]:[]});continue}}return e.root||(e.root=r||t||e.reply),e.reply||(e.reply=t||e.root),[e.reply,e.root].forEach(s=>{if(!s)return;let o=e.mentions.indexOf(s);if(o!==-1&&e.mentions.splice(o,1),s.author){let a=e.profiles.find(c=>c.pubkey===s.author);a&&a.relays&&(s.relays||(s.relays=[]),a.relays.forEach(c=>{var l;((l=s.relays)==null?void 0:l.indexOf(c))===-1&&s.relays.push(c)}),a.relays=s.relays)}}),e.mentions.forEach(s=>{if(s.author){let o=e.profiles.find(a=>a.pubkey===s.author);o&&o.relays&&(s.relays||(s.relays=[]),o.relays.forEach(a=>{s.relays.indexOf(a)===-1&&s.relays.push(a)}),o.relays=s.relays)}}),e}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation$1,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(n){_fetch2=n}async function fetchRelayInformation$1(n){return await(await fetch(n.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(n){let e=0;for(let t=0;t<64;t+=8){const r=parseInt(n.substring(t,t+8),16);if(r===0)e+=32;else{e+=Math.clz32(r);break}}return e}function minePow(n,e){let t=0;const r=n,s=["nonce",t.toString(),e.toString()];for(r.tags.push(s);;){const o=Math.floor(new Date().getTime()/1e3);if(o!==r.created_at&&(t=0,r.created_at=o),s[1]=(++t).toString(),r.id=fastEventHash(r),getPow(r.id)>=e)break}return r}function fastEventHash(n){return bytesToHex$1(sha256$2(utf8Encoder$1.encode(JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]))))}var nip17_exports={};__export(nip17_exports,{unwrapEvent:()=>unwrapEvent2,unwrapManyEvents:()=>unwrapManyEvents2,wrapEvent:()=>wrapEvent2,wrapManyEvents:()=>wrapManyEvents2});var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent$1,wrapManyEvents:()=>wrapManyEvents});var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(n,e){const t=secp256k1$1.getSharedSecret(n,"02"+e).subarray(1,33);return extract(sha256$2,t,"nip44-v2")}function getMessageKeys(n,e){const t=expand(sha256$2,n,e,76);return{chacha_key:t.subarray(0,32),chacha_nonce:t.subarray(32,44),hmac_key:t.subarray(44,76)}}function calcPaddedLen(n){if(!Number.isSafeInteger(n)||n<1)throw new Error("expected positive integer");if(n<=32)return 32;const e=1<<Math.floor(Math.log2(n-1))+1,t=e<=256?32:e/8;return t*(Math.floor((n-1)/t)+1)}function writeU16BE(n){if(!Number.isSafeInteger(n)||n<minPlaintextSize||n>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const e=new Uint8Array(2);return new DataView(e.buffer).setUint16(0,n,!1),e}function pad(n){const e=utf8Encoder$1.encode(n),t=e.length,r=writeU16BE(t),s=new Uint8Array(calcPaddedLen(t)-t);return concatBytes$1(r,e,s)}function unpad(n){const e=new DataView(n.buffer).getUint16(0),t=n.subarray(2,2+e);if(e<minPlaintextSize||e>maxPlaintextSize||t.length!==e||n.length!==2+calcPaddedLen(e))throw new Error("invalid padding");return utf8Decoder$1.decode(t)}function hmacAad(n,e,t){if(t.length!==32)throw new Error("AAD associated data must be 32 bytes");const r=concatBytes$1(t,e);return hmac$1(sha256$2,n,r)}function decodePayload(n){if(typeof n!="string")throw new Error("payload must be a valid string");const e=n.length;if(e<132||e>87472)throw new Error("invalid payload length: "+e);if(n[0]==="#")throw new Error("unknown encryption version");let t;try{t=base64.decode(n)}catch(o){throw new Error("invalid base64: "+o.message)}const r=t.length;if(r<99||r>65603)throw new Error("invalid data length: "+r);const s=t[0];if(s!==2)throw new Error("unknown encryption version "+s);return{nonce:t.subarray(1,33),ciphertext:t.subarray(33,-32),mac:t.subarray(-32)}}function encrypt2(n,e,t=randomBytes$1(32)){const{chacha_key:r,chacha_nonce:s,hmac_key:o}=getMessageKeys(e,t),a=pad(n),c=chacha20(r,s,a),l=hmacAad(o,c,t);return base64.encode(concatBytes$1(new Uint8Array([2]),t,c,l))}function decrypt2(n,e){const{nonce:t,ciphertext:r,mac:s}=decodePayload(n),{chacha_key:o,chacha_nonce:a,hmac_key:c}=getMessageKeys(e,t),l=hmacAad(c,r,t);if(!equalBytes(l,s))throw new Error("invalid MAC");const u=chacha20(o,a,r);return unpad(u)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(n,e)=>getConversationKey(n,e),nip44Encrypt=(n,e,t)=>encrypt2(JSON.stringify(n),nip44ConversationKey(e,t)),nip44Decrypt=(n,e)=>JSON.parse(decrypt2(n.content,nip44ConversationKey(e,n.pubkey)));function createRumor(n,e){const t={created_at:now(),content:"",tags:[],...n,pubkey:getPublicKey(e)};return t.id=getEventHash$1(t),t}function createSeal(n,e,t){return finalizeEvent({kind:Seal,content:nip44Encrypt(n,e,t),created_at:randomNow(),tags:[]},e)}function createWrap(n,e){const t=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(n,t,e),created_at:randomNow(),tags:[["p",e]]},t)}function wrapEvent$1(n,e,t){const r=createRumor(n,e),s=createSeal(r,e,t);return createWrap(s,t)}function wrapManyEvents(n,e,t){if(!t||t.length===0)throw new Error("At least one recipient is required.");const r=getPublicKey(e),s=[wrapEvent$1(n,e,r)];return t.forEach(o=>{s.push(wrapEvent$1(n,e,o))}),s}function unwrapEvent(n,e){const t=nip44Decrypt(n,e);return nip44Decrypt(t,e)}function unwrapManyEvents(n,e){let t=[];return n.forEach(r=>{t.push(unwrapEvent(r,e))}),t.sort((r,s)=>r.created_at-s.created_at),t}function createEvent(n,e,t,r){const s={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage,tags:[],content:e};return(Array.isArray(n)?n:[n]).forEach(({publicKey:a,relayUrl:c})=>{s.tags.push(c?["p",a,c]:["p",a])}),r&&s.tags.push(["e",r.eventId,r.relayUrl||"","reply"]),t&&s.tags.push(["subject",t]),s}function wrapEvent2(n,e,t,r,s){const o=createEvent(e,t,r,s);return wrapEvent$1(o,n,e.publicKey)}function wrapManyEvents2(n,e,t,r,s){if(!e||e.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey(n)},...e].map(a=>wrapEvent2(n,a,t,r,s))}var unwrapEvent2=unwrapEvent,unwrapManyEvents2=unwrapManyEvents,nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(n,e,t,r){var a;let s;const o=[...n.tags??[],["e",e.id,t],["p",e.pubkey]];return e.kind===ShortTextNote?s=Repost:(s=GenericRepost,o.push(["k",String(e.kind)])),finalizeEvent({kind:s,tags:o,content:n.content===""||(a=e.tags)!=null&&a.find(c=>c[0]==="-")?"":JSON.stringify(e),created_at:n.created_at},r)}function getRepostedEventPointer(n){if(![Repost,GenericRepost].includes(n.kind))return;let e,t;for(let r=n.tags.length-1;r>=0&&(e===void 0||t===void 0);r--){const s=n.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&t===void 0&&(t=s))}if(e!==void 0)return{id:e[1],relays:[e[2],t==null?void 0:t[2]].filter(r=>typeof r=="string"),author:t==null?void 0:t[1]}}function getRepostedEvent(n,{skipVerification:e}={}){const t=getRepostedEventPointer(n);if(t===void 0||n.content==="")return;let r;try{r=JSON.parse(n.content)}catch{return}if(r.id===t.id&&!(!e&&!verifyEvent(r)))return r}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX$2.source})`);function test(n){return typeof n=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(n)}function parse2(n){const e=n.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!e)throw new Error(`Invalid Nostr URI: ${n}`);return{uri:e[0],value:e[1],decoded:decode$1(e[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(n,e,t){const r=e.tags.filter(s=>s.length>=2&&(s[0]==="e"||s[0]==="p"));return finalizeEvent({...n,kind:Reaction,tags:[...n.tags??[],...r,["e",e.id],["p",e.pubkey]],content:n.content??"+"},t)}function getReactedEventPointer(n){if(n.kind!==Reaction)return;let e,t;for(let r=n.tags.length-1;r>=0&&(e===void 0||t===void 0);r--){const s=n.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&t===void 0&&(t=s))}if(!(e===void 0||t===void 0))return{id:e[1],relays:[e[2],t[2]].filter(r=>r!==void 0),author:t[1]}}var nip27_exports={};__export(nip27_exports,{parse:()=>parse3});var noCharacter=/\W/m,noURLCharacter=/\W |\W$|$|,| /m;function*parse3(n){const e=n.length;let t=0,r=0;for(;r<e;){let s=n.indexOf(":",r);if(s===-1)break;if(n.substring(s-5,s)==="nostr"){const o=n.substring(s+60).match(noCharacter),a=o?s+60+o.index:e;try{let c,{data:l,type:u}=decode$1(n.substring(s+1,a));switch(u){case"npub":c={pubkey:l};break;case"nsec":case"note":r=a+1;continue;default:c=l}t!==s-5&&(yield{type:"text",text:n.substring(t,s-5)}),yield{type:"reference",pointer:c},r=a,t=r;continue}catch{r=s+1;continue}}else if(n.substring(s-5,s)==="https"||n.substring(s-4,s)==="http"){const o=n.substring(s+4).match(noURLCharacter),a=o?s+4+o.index:e,c=n[s-1]==="s"?5:4;try{let l=new URL(n.substring(s-c,a));if(l.hostname.indexOf(".")===-1)throw new Error("invalid url");if(t!==s-c&&(yield{type:"text",text:n.substring(t,s-c)}),/\.(png|jpe?g|gif|webp)$/i.test(l.pathname)){yield{type:"image",url:l.toString()},r=a,t=r;continue}if(/\.(mp4|avi|webm|mkv)$/i.test(l.pathname)){yield{type:"video",url:l.toString()},r=a,t=r;continue}if(/\.(mp3|aac|ogg|opus)$/i.test(l.pathname)){yield{type:"audio",url:l.toString()},r=a,t=r;continue}yield{type:"url",url:l.toString()},r=a,t=r;continue}catch{r=a+1;continue}}else if(n.substring(s-3,s)==="wss"||n.substring(s-2,s)==="ws"){const o=n.substring(s+4).match(noURLCharacter),a=o?s+4+o.index:e,c=n[s-1]==="s"?3:2;try{let l=new URL(n.substring(s-c,a));if(l.hostname.indexOf(".")===-1)throw new Error("invalid ws url");t!==s-c&&(yield{type:"text",text:n.substring(t,s-c)}),yield{type:"relay",url:l.toString()},r=a,t=r;continue}catch{r=a+1;continue}}else{r=s+1;continue}}t!==e&&(yield{type:"text",text:n.substring(t)})}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(n,e)=>{let t;if(typeof n.content=="object")t=JSON.stringify(n.content);else if(typeof n.content=="string")t=n.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...n.tags??[]],content:t,created_at:n.created_at},e)},channelMetadataEvent=(n,e)=>{let t;if(typeof n.content=="object")t=JSON.stringify(n.content);else if(typeof n.content=="string")t=n.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",n.channel_create_event_id],...n.tags??[]],content:t,created_at:n.created_at},e)},channelMessageEvent=(n,e)=>{const t=[["e",n.channel_create_event_id,n.relay_url,"root"]];return n.reply_to_channel_message_event_id&&t.push(["e",n.reply_to_channel_message_event_id,n.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...t,...n.tags??[]],content:n.content,created_at:n.created_at},e)},channelHideMessageEvent=(n,e)=>{let t;if(typeof n.content=="object")t=JSON.stringify(n.content);else if(typeof n.content=="string")t=n.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",n.channel_message_event_id],...n.tags??[]],content:t,created_at:n.created_at},e)},channelMuteUserEvent=(n,e)=>{let t;if(typeof n.content=="object")t=JSON.stringify(n.content);else if(typeof n.content=="string")t=n.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",n.pubkey_to_mute],...n.tags??[]],content:t,created_at:n.created_at},e)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll(n){const e=n.matchAll(regex());for(const t of e)try{const[r,s]=t;yield{shortcode:r,name:s,start:t.index,end:t.index+r.length}}catch{}}function replaceAll(n,e){return n.replaceAll(regex(),(t,r)=>e({shortcode:t,name:r}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(n){_fetch3=n}async function validateGithub(n,e,t){try{return await(await _fetch3(`https://gist.github.com/${e}/${t}/raw`)).text()===`Verifying that I control the following Nostr public key: ${n}`}catch{return!1}}var nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(n){const{host:e,pathname:t,searchParams:r}=new URL(n),s=t||e,o=r.get("relay"),a=r.get("secret");if(!s||!o||!a)throw new Error("invalid connection string");return{pubkey:s,relay:o,secret:a}}async function makeNwcRequestEvent(n,e,t){const s=encrypt$2(e,n,JSON.stringify({method:"pay_invoice",params:{invoice:t}})),o={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:s,tags:[["p",n]]};return finalizeEvent(o,e)}var nip54_exports={};__export(nip54_exports,{normalizeIdentifier:()=>normalizeIdentifier});function normalizeIdentifier(n){return n=n.trim().toLowerCase(),n=n.normalize("NFKC"),Array.from(n).map(e=>new RegExp("\\p{Letter}","u").test(e)||new RegExp("\\p{Number}","u").test(e)?e:"-").join("")}var nip57_exports={};__export(nip57_exports,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11,getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(n){_fetch4=n}async function getZapEndpoint(n){try{let e="",{lud06:t,lud16:r}=JSON.parse(n.content);if(t){let{words:a}=bech32$1.decode(t,1e3),c=bech32$1.fromWords(a);e=utf8Decoder$1.decode(c)}else if(r){let[a,c]=r.split("@");e=new URL(`/.well-known/lnurlp/${a}`,`https://${c}`).toString()}else return null;let o=await(await _fetch4(e)).json();if(o.allowsNostr&&o.nostrPubkey)return o.callback}catch{}return null}function makeZapRequest(n){let e={kind:9734,created_at:Math.round(Date.now()/1e3),content:n.comment||"",tags:[["p","pubkey"in n?n.pubkey:n.event.pubkey],["amount",n.amount.toString()],["relays",...n.relays]]};if("event"in n){if(e.tags.push(["e",n.event.id]),isReplaceableKind(n.event.kind)){const t=["a",`${n.event.kind}:${n.event.pubkey}:`];e.tags.push(t)}else if(isAddressableKind(n.event.kind)){let t=n.event.tags.find(([s,o])=>s==="d"&&o);if(!t)throw new Error("d tag not found or is empty");const r=["a",`${n.event.kind}:${n.event.pubkey}:${t[1]}`];e.tags.push(r)}e.tags.push(["k",n.event.kind.toString()])}return e}function validateZapRequest(n){let e;try{e=JSON.parse(n)}catch{return"Invalid zap request JSON."}if(!validateEvent(e))return"Zap request is not a valid Nostr event.";if(!verifyEvent(e))return"Invalid signature on zap request.";let t=e.tags.find(([o,a])=>o==="p"&&a);if(!t)return"Zap request doesn't have a 'p' tag.";if(!t[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let r=e.tags.find(([o,a])=>o==="e"&&a);return r&&!r[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":e.tags.find(([o,a])=>o==="relays"&&a)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:n,preimage:e,bolt11:t,paidAt:r}){let s=JSON.parse(n),o=s.tags.filter(([c])=>c==="e"||c==="p"||c==="a"),a={kind:9735,created_at:Math.round(r.getTime()/1e3),content:"",tags:[...o,["P",s.pubkey],["bolt11",t],["description",n]]};return e&&a.tags.push(["preimage",e]),a}function getSatoshisAmountFromBolt11(n){if(n.length<50)return 0;n=n.substring(0,50);const e=n.lastIndexOf("1");if(e===-1)return 0;const t=n.substring(0,e);if(!t.startsWith("lnbc"))return 0;const r=t.substring(4);if(r.length<1)return 0;const s=r[r.length-1],o=s.charCodeAt(0)-48,a=o>=0&&o<=9;let c=r.length-1;if(a&&c++,c<1)return 0;const l=parseInt(r.substring(0,c));switch(s){case"m":return l*1e5;case"u":return l*100;case"n":return l/10;case"p":return l/1e4;default:return l*1e8}}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(n,e,t,r=!1,s){const o={kind:HTTPAuth,tags:[["u",n],["method",e]],created_at:Math.round(new Date().getTime()/1e3),content:""};s&&o.tags.push(["payload",hashPayload(s)]);const a=await t(o);return(r?_authorizationScheme:"")+base64.encode(utf8Encoder$1.encode(JSON.stringify(a)))}async function validateToken(n,e,t){const r=await unpackEventFromToken(n).catch(o=>{throw o});return await validateEvent2(r,e,t).catch(o=>{throw o})}async function unpackEventFromToken(n){if(!n)throw new Error("Missing token");n=n.replace(_authorizationScheme,"");const e=utf8Decoder$1.decode(base64.decode(n));if(!e||e.length===0||!e.startsWith("{"))throw new Error("Invalid token");return JSON.parse(e)}function validateEventTimestamp(n){return n.created_at?Math.round(new Date().getTime()/1e3)-n.created_at<60:!1}function validateEventKind(n){return n.kind===HTTPAuth}function validateEventUrlTag(n,e){const t=n.tags.find(r=>r[0]==="u");return t?t.length>0&&t[1]===e:!1}function validateEventMethodTag(n,e){const t=n.tags.find(r=>r[0]==="method");return t?t.length>0&&t[1].toLowerCase()===e.toLowerCase():!1}function hashPayload(n){const e=sha256$2(utf8Encoder$1.encode(JSON.stringify(n)));return bytesToHex$1(e)}function validateEventPayloadTag(n,e){const t=n.tags.find(s=>s[0]==="payload");if(!t)return!1;const r=hashPayload(e);return t.length>0&&t[1]===r}async function validateEvent2(n,e,t,r){if(!verifyEvent(n))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(n))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(n))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(n,e))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(n,t))throw new Error("Invalid nostr event, method tag invalid");if(r&&typeof r=="object"&&Object.keys(r).length>0&&!validateEventPayloadTag(n,r))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}const crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(n,...e){if(!isBytes(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function ahash(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");anumber(n.outputLen),anumber(n.blockLen)}function aexists(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function aoutput(n,e){abytes(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function clean(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function createView(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function rotr(n,e){return n<<32-e|n>>>e}const hasHexBuiltin=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",hexes=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function bytesToHex(n){if(abytes(n),hasHexBuiltin)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=hexes[n[t]];return e}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(n){if(n>=asciis._0&&n<=asciis._9)return n-asciis._0;if(n>=asciis.A&&n<=asciis.F)return n-(asciis.A-10);if(n>=asciis.a&&n<=asciis.f)return n-(asciis.a-10)}function hexToBytes(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(hasHexBuiltin)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const a=asciiToBase16(n.charCodeAt(o)),c=asciiToBase16(n.charCodeAt(o+1));if(a===void 0||c===void 0){const l=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+o)}r[s]=a*16+c}return r}function utf8ToBytes(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function toBytes(n){return typeof n=="string"&&(n=utf8ToBytes(n)),abytes(n),n}function concatBytes(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];abytes(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const o=n[r];t.set(o,s),s+=o.length}return t}class Hash{}function createHasher(n){const e=r=>n().update(toBytes(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function randomBytes(n=32){if(crypto&&typeof crypto.getRandomValues=="function")return crypto.getRandomValues(new Uint8Array(n));if(crypto&&typeof crypto.randomBytes=="function")return Uint8Array.from(crypto.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(t>>s&o),c=Number(t&o),l=r?4:0,u=r?0:4;n.setUint32(e+l,a,r),n.setUint32(e+u,c,r)}function Chi(n,e,t){return n&e^~n&t}function Maj(n,e,t){return n&e^n&t^e&t}class HashMD extends Hash{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){aexists(this),e=toBytes(e),abytes(e);const{view:t,buffer:r,blockLen:s}=this,o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),aoutput(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;t[a++]=128,clean(this.buffer.subarray(a)),this.padOffset>s-a&&(this.process(r,0),a=0);for(let h=a;h<s;h++)t[h]=0;setBigUint64(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=l/4,f=this.get();if(u>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,f[h],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.destroyed=a,e.finished=o,e.length=s,e.pos=c,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_K=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(e=32){super(64,e,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,t,r,s,o,a,c,l]}set(e,t,r,s,o,a,c,l){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,t){for(let h=0;h<16;h++,t+=4)SHA256_W[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const p=SHA256_W[h-15],g=SHA256_W[h-2],b=rotr(p,7)^rotr(p,18)^p>>>3,m=rotr(g,17)^rotr(g,19)^g>>>10;SHA256_W[h]=m+SHA256_W[h-7]+b+SHA256_W[h-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:u,H:f}=this;for(let h=0;h<64;h++){const p=rotr(c,6)^rotr(c,11)^rotr(c,25),g=f+p+Chi(c,l,u)+SHA256_K[h]+SHA256_W[h]|0,m=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,o)|0;f=u,u=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+m|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,u,f)}roundClean(){clean(SHA256_W)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}}const sha256$1=createHasher(()=>new SHA256);class HMAC extends Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ahash(e);const r=toBytes(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),clean(o)}update(e){return aexists(this),this.iHash.update(e),this}digestInto(e){aexists(this),abytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(n,e,t)=>new HMAC(n,e).update(t).digest();hmac.create=(n,e)=>new HMAC(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1);function _abool2(n,e=""){if(typeof n!="boolean"){const t=e&&`"${e}"`;throw new Error(t+"expected boolean, got type="+typeof n)}return n}function _abytes2(n,e,t=""){const r=isBytes(n),s=n==null?void 0:n.length,o=e!==void 0;if(!r||o&&s!==e){const a=t&&`"${t}" `,c=o?` of length ${e}`:"",l=r?`length=${s}`:`type=${typeof n}`;throw new Error(a+"expected Uint8Array"+c+", got "+l)}return n}function numberToHexUnpadded(n){const e=n.toString(16);return e.length&1?"0"+e:e}function hexToNumber(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?_0n$4:BigInt("0x"+n)}function bytesToNumberBE(n){return hexToNumber(bytesToHex(n))}function bytesToNumberLE(n){return abytes(n),hexToNumber(bytesToHex(Uint8Array.from(n).reverse()))}function numberToBytesBE(n,e){return hexToBytes(n.toString(16).padStart(e*2,"0"))}function numberToBytesLE(n,e){return numberToBytesBE(n,e).reverse()}function ensureBytes(n,e,t){let r;if(typeof e=="string")try{r=hexToBytes(e)}catch(o){throw new Error(n+" must be hex string or Uint8Array, cause: "+o)}else if(isBytes(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(n+" of length "+t+" expected, got "+s);return r}const isPosBig=n=>typeof n=="bigint"&&_0n$4<=n;function inRange(n,e,t){return isPosBig(n)&&isPosBig(e)&&isPosBig(t)&&e<=n&&n<t}function aInRange(n,e,t,r){if(!inRange(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function bitLen(n){let e;for(e=0;n>_0n$4;n>>=_1n$4,e+=1);return e}const bitMask=n=>(_1n$4<<BigInt(n))-_1n$4;function createHmacDrbg(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=g=>new Uint8Array(g),s=g=>Uint8Array.of(g);let o=r(n),a=r(n),c=0;const l=()=>{o.fill(1),a.fill(0),c=0},u=(...g)=>t(a,o,...g),f=(g=r(0))=>{a=u(s(0),g),o=u(),g.length!==0&&(a=u(s(1),g),o=u())},h=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const b=[];for(;g<e;){o=u();const m=o.slice();b.push(m),g+=o.length}return concatBytes(...b)};return(g,b)=>{l(),f(g);let m;for(;!(m=b(h()));)f();return l(),m}}function _validateObject(n,e,t={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,o,a){const c=n[s];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${l}`)}Object.entries(e).forEach(([s,o])=>r(s,o,!1)),Object.entries(t).forEach(([s,o])=>r(s,o,!0))}function memoized(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const o=n(t,...r);return e.set(t,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$2=BigInt(2),_3n$1=BigInt(3),_4n$1=BigInt(4),_5n=BigInt(5),_7n=BigInt(7),_8n=BigInt(8),_9n=BigInt(9),_16n=BigInt(16);function mod(n,e){const t=n%e;return t>=_0n$3?t:e+t}function pow2(n,e,t){let r=n;for(;e-- >_0n$3;)r*=r,r%=t;return r}function invert(n,e){if(n===_0n$3)throw new Error("invert: expected non-zero number");if(e<=_0n$3)throw new Error("invert: expected positive modulus, got "+e);let t=mod(n,e),r=e,s=_0n$3,o=_1n$3;for(;t!==_0n$3;){const c=r/t,l=r%t,u=s-o*c;r=t,t=l,s=o,o=u}if(r!==_1n$3)throw new Error("invert: does not exist");return mod(s,e)}function assertIsSquare(n,e,t){if(!n.eql(n.sqr(e),t))throw new Error("Cannot find square root")}function sqrt3mod4(n,e){const t=(n.ORDER+_1n$3)/_4n$1,r=n.pow(e,t);return assertIsSquare(n,r,e),r}function sqrt5mod8(n,e){const t=(n.ORDER-_5n)/_8n,r=n.mul(e,_2n$2),s=n.pow(r,t),o=n.mul(e,s),a=n.mul(n.mul(o,_2n$2),s),c=n.mul(o,n.sub(a,n.ONE));return assertIsSquare(n,c,e),c}function sqrt9mod16(n){const e=Field(n),t=tonelliShanks(n),r=t(e,e.neg(e.ONE)),s=t(e,r),o=t(e,e.neg(r)),a=(n+_7n)/_16n;return(c,l)=>{let u=c.pow(l,a),f=c.mul(u,r);const h=c.mul(u,s),p=c.mul(u,o),g=c.eql(c.sqr(f),l),b=c.eql(c.sqr(h),l);u=c.cmov(u,f,g),f=c.cmov(p,h,b);const m=c.eql(c.sqr(f),l),E=c.cmov(u,f,m);return assertIsSquare(c,E,l),E}}function tonelliShanks(n){if(n<_3n$1)throw new Error("sqrt is not defined for small field");let e=n-_1n$3,t=0;for(;e%_2n$2===_0n$3;)e/=_2n$2,t++;let r=_2n$2;const s=Field(n);for(;FpLegendre(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return sqrt3mod4;let o=s.pow(r,e);const a=(e+_1n$3)/_2n$2;return function(l,u){if(l.is0(u))return u;if(FpLegendre(l,u)!==1)throw new Error("Cannot find square root");let f=t,h=l.mul(l.ONE,o),p=l.pow(u,e),g=l.pow(u,a);for(;!l.eql(p,l.ONE);){if(l.is0(p))return l.ZERO;let b=1,m=l.sqr(p);for(;!l.eql(m,l.ONE);)if(b++,m=l.sqr(m),b===f)throw new Error("Cannot find square root");const E=_1n$3<<BigInt(f-b-1),_=l.pow(h,E);f=b,h=l.sqr(_),p=l.mul(p,h),g=l.mul(g,_)}return g}}function FpSqrt(n){return n%_4n$1===_3n$1?sqrt3mod4:n%_8n===_5n?sqrt5mod8:n%_16n===_9n?sqrt9mod16(n):tonelliShanks(n)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=FIELD_FIELDS.reduce((r,s)=>(r[s]="function",r),e);return _validateObject(n,t),n}function FpPow(n,e,t){if(t<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(t===_0n$3)return n.ONE;if(t===_1n$3)return e;let r=n.ONE,s=e;for(;t>_0n$3;)t&_1n$3&&(r=n.mul(r,s)),s=n.sqr(s),t>>=_1n$3;return r}function FpInvertBatch(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),s=e.reduce((a,c,l)=>n.is0(c)?a:(r[l]=a,n.mul(a,c)),n.ONE),o=n.inv(s);return e.reduceRight((a,c,l)=>n.is0(c)?a:(r[l]=n.mul(a,r[l]),n.mul(a,c)),o),r}function FpLegendre(n,e){const t=(n.ORDER-_1n$3)/_2n$2,r=n.pow(e,t),s=n.eql(r,n.ONE),o=n.eql(r,n.ZERO),a=n.eql(r,n.neg(n.ONE));if(!s&&!o&&!a)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function nLength(n,e){e!==void 0&&anumber(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Field(n,e,t=!1,r={}){if(n<=_0n$3)throw new Error("invalid field: expected ORDER > 0, got "+n);let s,o,a=!1,c;if(typeof e=="object"&&e!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const p=e;p.BITS&&(s=p.BITS),p.sqrt&&(o=p.sqrt),typeof p.isLE=="boolean"&&(t=p.isLE),typeof p.modFromBytes=="boolean"&&(a=p.modFromBytes),c=p.allowedLengths}else typeof e=="number"&&(s=e),r.sqrt&&(o=r.sqrt);const{nBitLength:l,nByteLength:u}=nLength(n,s);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const h=Object.freeze({ORDER:n,isLE:t,BITS:l,BYTES:u,MASK:bitMask(l),ZERO:_0n$3,ONE:_1n$3,allowedLengths:c,create:p=>mod(p,n),isValid:p=>{if(typeof p!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof p);return _0n$3<=p&&p<n},is0:p=>p===_0n$3,isValidNot0:p=>!h.is0(p)&&h.isValid(p),isOdd:p=>(p&_1n$3)===_1n$3,neg:p=>mod(-p,n),eql:(p,g)=>p===g,sqr:p=>mod(p*p,n),add:(p,g)=>mod(p+g,n),sub:(p,g)=>mod(p-g,n),mul:(p,g)=>mod(p*g,n),pow:(p,g)=>FpPow(h,p,g),div:(p,g)=>mod(p*invert(g,n),n),sqrN:p=>p*p,addN:(p,g)=>p+g,subN:(p,g)=>p-g,mulN:(p,g)=>p*g,inv:p=>invert(p,n),sqrt:o||(p=>(f||(f=FpSqrt(n)),f(h,p))),toBytes:p=>t?numberToBytesLE(p,u):numberToBytesBE(p,u),fromBytes:(p,g=!0)=>{if(c){if(!c.includes(p.length)||p.length>u)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+p.length);const m=new Uint8Array(u);m.set(p,t?0:m.length-p.length),p=m}if(p.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+p.length);let b=t?bytesToNumberLE(p):bytesToNumberBE(p);if(a&&(b=mod(b,n)),!g&&!h.isValid(b))throw new Error("invalid field element: outside of range 0..ORDER");return b},invertBatch:p=>FpInvertBatch(h,p),cmov:(p,g,b)=>b?g:p});return Object.freeze(h)}function getFieldBytesLength(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function getMinHashLength(n){const e=getFieldBytesLength(n);return e+Math.ceil(e/2)}function mapHashToField(n,e,t=!1){const r=n.length,s=getFieldBytesLength(e),o=getMinHashLength(e);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const a=t?bytesToNumberLE(n):bytesToNumberBE(n),c=mod(a,e-_1n$3)+_1n$3;return t?numberToBytesLE(c,s):numberToBytesBE(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function negateCt(n,e){const t=e.negate();return n?t:e}function normalizeZ(n,e){const t=FpInvertBatch(n.Fp,e.map(r=>r.Z));return e.map((r,s)=>n.fromAffine(r.toAffine(t[s])))}function validateW(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function calcWOpts(n,e){validateW(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),s=2**n,o=bitMask(n),a=BigInt(n);return{windows:t,windowSize:r,mask:o,maxNumber:s,shiftBy:a}}function calcOffsets(n,e,t){const{windowSize:r,mask:s,maxNumber:o,shiftBy:a}=t;let c=Number(n&s),l=n>>a;c>r&&(c-=o,l+=_1n$2);const u=e*r,f=u+Math.abs(c)-1,h=c===0,p=c<0,g=e%2!==0;return{nextN:l,offset:f,isZero:h,isNeg:p,isNegF:g,offsetF:u}}function validateMSMPoints(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function validateMSMScalars(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(n){return pointWindowSizes.get(n)||1}function assert0(n){if(n!==_0n$2)throw new Error("invalid wNAF")}class wNAF{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let s=e;for(;t>_0n$2;)t&_1n$2&&(r=r.add(s)),s=s.double(),t>>=_1n$2;return r}precomputeWindow(e,t){const{windows:r,windowSize:s}=calcWOpts(t,this.bits),o=[];let a=e,c=a;for(let l=0;l<r;l++){c=a,o.push(c);for(let u=1;u<s;u++)c=c.add(a),o.push(c);a=c.double()}return o}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const a=calcWOpts(e,this.bits);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:f,isNeg:h,isNegF:p,offsetF:g}=calcOffsets(r,c,a);r=l,f?o=o.add(negateCt(p,t[g])):s=s.add(negateCt(h,t[u]))}return assert0(r),{p:s,f:o}}wNAFUnsafe(e,t,r,s=this.ZERO){const o=calcWOpts(e,this.bits);for(let a=0;a<o.windows&&r!==_0n$2;a++){const{nextN:c,offset:l,isZero:u,isNeg:f}=calcOffsets(r,a,o);if(r=c,!u){const h=t[l];s=s.add(f?h.negate():h)}}return assert0(r),s}getPrecomputes(e,t,r){let s=pointPrecomputes.get(t);return s||(s=this.precomputeWindow(t,e),e!==1&&(typeof r=="function"&&(s=r(s)),pointPrecomputes.set(t,s))),s}cached(e,t,r){const s=getW(e);return this.wNAF(s,this.getPrecomputes(s,e,r),t)}unsafe(e,t,r,s){const o=getW(e);return o===1?this._unsafeLadder(e,t,s):this.wNAFUnsafe(o,this.getPrecomputes(o,e,r),t,s)}createCache(e,t){validateW(t,this.bits),pointWindowSizes.set(e,t),pointPrecomputes.delete(e)}hasCache(e){return getW(e)!==1}}function mulEndoUnsafe(n,e,t,r){let s=e,o=n.ZERO,a=n.ZERO;for(;t>_0n$2||r>_0n$2;)t&_1n$2&&(o=o.add(s)),r&_1n$2&&(a=a.add(s)),s=s.double(),t>>=_1n$2,r>>=_1n$2;return{p1:o,p2:a}}function pippenger(n,e,t,r){validateMSMPoints(t,n),validateMSMScalars(r,e);const s=t.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const a=n.ZERO,c=bitLen(BigInt(s));let l=1;c>12?l=c-3:c>4?l=c-2:c>0&&(l=2);const u=bitMask(l),f=new Array(Number(u)+1).fill(a),h=Math.floor((e.BITS-1)/l)*l;let p=a;for(let g=h;g>=0;g-=l){f.fill(a);for(let m=0;m<o;m++){const E=r[m],_=Number(E>>BigInt(g)&u);f[_]=f[_].add(t[m])}let b=a;for(let m=f.length-1,E=a;m>0;m--)E=E.add(f[m]),b=b.add(E);if(p=p.add(b),g!==0)for(let m=0;m<l;m++)p=p.double()}return p}function createField(n,e,t){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return validateField(e),e}else return Field(n,{isLE:t})}function _createCurveFields(n,e,t={},r){if(r===void 0&&(r=n==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const l of["p","n","h"]){const u=e[l];if(!(typeof u=="bigint"&&u>_0n$2))throw new Error(`CURVE.${l} must be positive bigint`)}const s=createField(e.p,t.Fp,r),o=createField(e.n,t.Fn,r),c=["Gx","Gy","a","b"];for(const l of c)if(!s.isValid(e[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:s,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const divNearest=(n,e)=>(n+(n>=0?e:-e)/_2n$1)/e;function _splitEndoScalar(n,e,t){const[[r,s],[o,a]]=e,c=divNearest(a*n,t),l=divNearest(-s*n,t);let u=n-c*r-l*o,f=-c*s-l*a;const h=u<_0n$1,p=f<_0n$1;h&&(u=-u),p&&(f=-f);const g=bitMask(Math.ceil(bitLen(t)/2))+_1n$1;if(u<_0n$1||u>=g||f<_0n$1||f>=g)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:h,k1:u,k2neg:p,k2:f}}function validateSigFormat(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function validateSigOpts(n,e){const t={};for(let r of Object.keys(e))t[r]=n[r]===void 0?e[r]:n[r];return _abool2(t.lowS,"lowS"),_abool2(t.prehash,"prehash"),t.format!==void 0&&validateSigFormat(t.format),t}class DERErr extends Error{constructor(e=""){super(e)}}const DER={Err:DERErr,_tlv:{encode:(n,e)=>{const{Err:t}=DER;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=numberToHexUnpadded(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=r>127?numberToHexUnpadded(s.length/2|128):"";return numberToHexUnpadded(n)+o+s+e},decode(n,e){const{Err:t}=DER;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],o=!!(s&128);let a=0;if(!o)a=s;else{const l=s&127;if(!l)throw new t("tlv.decode(long): indefinite length not supported");if(l>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+l);if(u.length!==l)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const f of u)a=a<<8|f;if(r+=l,a<128)throw new t("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+a)}}},_int:{encode(n){const{Err:e}=DER;if(n<_0n$1)throw new e("integer: negative integers are not allowed");let t=numberToHexUnpadded(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=DER;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return bytesToNumberBE(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=DER,s=ensureBytes("signature",n),{v:o,l:a}=r.decode(48,s);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l}=r.decode(2,o),{v:u,l:f}=r.decode(2,l);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(n){const{_tlv:e,_int:t}=DER,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),o=r+s;return e.encode(48,o)}},_0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_3n=BigInt(3),_4n=BigInt(4);function _normFnElement(n,e){const{BYTES:t}=n;let r;if(typeof e=="bigint")r=e;else{let s=ensureBytes("private key",e);try{r=n.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`)}}if(!n.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function weierstrassN(n,e={}){const t=_createCurveFields("weierstrass",n,e),{Fp:r,Fn:s}=t;let o=t.CURVE;const{h:a,n:c}=o;_validateObject(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=e;if(l&&(!r.is0(o.a)||typeof l.beta!="bigint"||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=getWLengths(r,s);function f(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(x,v,$){const{x:w,y:k}=v.toAffine(),S=r.toBytes(w);if(_abool2($,"isCompressed"),$){f();const N=!r.isOdd(k);return concatBytes(pprefix(N),S)}else return concatBytes(Uint8Array.of(4),S,r.toBytes(k))}function p(x){_abytes2(x,void 0,"Point");const{publicKey:v,publicKeyUncompressed:$}=u,w=x.length,k=x[0],S=x.subarray(1);if(w===v&&(k===2||k===3)){const N=r.fromBytes(S);if(!r.isValid(N))throw new Error("bad point: is not on curve, wrong x");const A=m(N);let B;try{B=r.sqrt(A)}catch(z){const H=z instanceof Error?": "+z.message:"";throw new Error("bad point: is not on curve, sqrt error"+H)}f();const R=r.isOdd(B);return(k&1)===1!==R&&(B=r.neg(B)),{x:N,y:B}}else if(w===$&&k===4){const N=r.BYTES,A=r.fromBytes(S.subarray(0,N)),B=r.fromBytes(S.subarray(N,N*2));if(!E(A,B))throw new Error("bad point: is not on curve");return{x:A,y:B}}else throw new Error(`bad point: got length ${w}, expected compressed=${v} or uncompressed=${$}`)}const g=e.toBytes||h,b=e.fromBytes||p;function m(x){const v=r.sqr(x),$=r.mul(v,x);return r.add(r.add($,r.mul(x,o.a)),o.b)}function E(x,v){const $=r.sqr(v),w=m(x);return r.eql($,w)}if(!E(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const _=r.mul(r.pow(o.a,_3n),_4n),C=r.mul(r.sqr(o.b),BigInt(27));if(r.is0(r.add(_,C)))throw new Error("bad curve params: a or b");function I(x,v,$=!1){if(!r.isValid(v)||$&&r.is0(v))throw new Error(`bad point coordinate ${x}`);return v}function P(x){if(!(x instanceof U))throw new Error("ProjectivePoint expected")}function M(x){if(!l||!l.basises)throw new Error("no endo");return _splitEndoScalar(x,l.basises,s.ORDER)}const L=memoized((x,v)=>{const{X:$,Y:w,Z:k}=x;if(r.eql(k,r.ONE))return{x:$,y:w};const S=x.is0();v==null&&(v=S?r.ONE:r.inv(k));const N=r.mul($,v),A=r.mul(w,v),B=r.mul(k,v);if(S)return{x:r.ZERO,y:r.ZERO};if(!r.eql(B,r.ONE))throw new Error("invZ was invalid");return{x:N,y:A}}),F=memoized(x=>{if(x.is0()){if(e.allowInfinityPoint&&!r.is0(x.Y))return;throw new Error("bad point: ZERO")}const{x:v,y:$}=x.toAffine();if(!r.isValid(v)||!r.isValid($))throw new Error("bad point: x or y not field elements");if(!E(v,$))throw new Error("bad point: equation left != right");if(!x.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function K(x,v,$,w,k){return $=new U(r.mul($.X,x),$.Y,$.Z),v=negateCt(w,v),$=negateCt(k,$),v.add($)}class U{constructor(v,$,w){this.X=I("x",v),this.Y=I("y",$,!0),this.Z=I("z",w),Object.freeze(this)}static CURVE(){return o}static fromAffine(v){const{x:$,y:w}=v||{};if(!v||!r.isValid($)||!r.isValid(w))throw new Error("invalid affine point");if(v instanceof U)throw new Error("projective point not allowed");return r.is0($)&&r.is0(w)?U.ZERO:new U($,w,r.ONE)}static fromBytes(v){const $=U.fromAffine(b(_abytes2(v,void 0,"point")));return $.assertValidity(),$}static fromHex(v){return U.fromBytes(ensureBytes("pointHex",v))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,$=!0){return T.createCache(this,v),$||this.multiply(_3n),this}assertValidity(){F(this)}hasEvenY(){const{y:v}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(v)}equals(v){P(v);const{X:$,Y:w,Z:k}=this,{X:S,Y:N,Z:A}=v,B=r.eql(r.mul($,A),r.mul(S,k)),R=r.eql(r.mul(w,A),r.mul(N,k));return B&&R}negate(){return new U(this.X,r.neg(this.Y),this.Z)}double(){const{a:v,b:$}=o,w=r.mul($,_3n),{X:k,Y:S,Z:N}=this;let A=r.ZERO,B=r.ZERO,R=r.ZERO,D=r.mul(k,k),z=r.mul(S,S),H=r.mul(N,N),V=r.mul(k,S);return V=r.add(V,V),R=r.mul(k,N),R=r.add(R,R),A=r.mul(v,R),B=r.mul(w,H),B=r.add(A,B),A=r.sub(z,B),B=r.add(z,B),B=r.mul(A,B),A=r.mul(V,A),R=r.mul(w,R),H=r.mul(v,H),V=r.sub(D,H),V=r.mul(v,V),V=r.add(V,R),R=r.add(D,D),D=r.add(R,D),D=r.add(D,H),D=r.mul(D,V),B=r.add(B,D),H=r.mul(S,N),H=r.add(H,H),D=r.mul(H,V),A=r.sub(A,D),R=r.mul(H,z),R=r.add(R,R),R=r.add(R,R),new U(A,B,R)}add(v){P(v);const{X:$,Y:w,Z:k}=this,{X:S,Y:N,Z:A}=v;let B=r.ZERO,R=r.ZERO,D=r.ZERO;const z=o.a,H=r.mul(o.b,_3n);let V=r.mul($,S),j=r.mul(w,N),q=r.mul(k,A),G=r.add($,w),W=r.add(S,N);G=r.mul(G,W),W=r.add(V,j),G=r.sub(G,W),W=r.add($,k);let Z=r.add(S,A);return W=r.mul(W,Z),Z=r.add(V,q),W=r.sub(W,Z),Z=r.add(w,k),B=r.add(N,A),Z=r.mul(Z,B),B=r.add(j,q),Z=r.sub(Z,B),D=r.mul(z,W),B=r.mul(H,q),D=r.add(B,D),B=r.sub(j,D),D=r.add(j,D),R=r.mul(B,D),j=r.add(V,V),j=r.add(j,V),q=r.mul(z,q),W=r.mul(H,W),j=r.add(j,q),q=r.sub(V,q),q=r.mul(z,q),W=r.add(W,q),V=r.mul(j,W),R=r.add(R,V),V=r.mul(Z,W),B=r.mul(G,B),B=r.sub(B,V),V=r.mul(G,j),D=r.mul(Z,D),D=r.add(D,V),new U(B,R,D)}subtract(v){return this.add(v.negate())}is0(){return this.equals(U.ZERO)}multiply(v){const{endo:$}=e;if(!s.isValidNot0(v))throw new Error("invalid scalar: out of range");let w,k;const S=N=>T.cached(this,N,A=>normalizeZ(U,A));if($){const{k1neg:N,k1:A,k2neg:B,k2:R}=M(v),{p:D,f:z}=S(A),{p:H,f:V}=S(R);k=z.add(V),w=K($.beta,D,H,N,B)}else{const{p:N,f:A}=S(v);w=N,k=A}return normalizeZ(U,[w,k])[0]}multiplyUnsafe(v){const{endo:$}=e,w=this;if(!s.isValid(v))throw new Error("invalid scalar: out of range");if(v===_0n$1||w.is0())return U.ZERO;if(v===_1n$1)return w;if(T.hasCache(this))return this.multiply(v);if($){const{k1neg:k,k1:S,k2neg:N,k2:A}=M(v),{p1:B,p2:R}=mulEndoUnsafe(U,w,S,A);return K($.beta,B,R,k,N)}else return T.unsafe(w,v)}multiplyAndAddUnsafe(v,$,w){const k=this.multiplyUnsafe($).add(v.multiplyUnsafe(w));return k.is0()?void 0:k}toAffine(v){return L(this,v)}isTorsionFree(){const{isTorsionFree:v}=e;return a===_1n$1?!0:v?v(U,this):T.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:v}=e;return a===_1n$1?this:v?v(U,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(v=!0){return _abool2(v,"isCompressed"),this.assertValidity(),g(U,this,v)}toHex(v=!0){return bytesToHex(this.toBytes(v))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(v=!0){return this.toBytes(v)}_setWindowSize(v){this.precompute(v)}static normalizeZ(v){return normalizeZ(U,v)}static msm(v,$){return pippenger(U,s,v,$)}static fromPrivateKey(v){return U.BASE.multiply(_normFnElement(s,v))}}U.BASE=new U(o.Gx,o.Gy,r.ONE),U.ZERO=new U(r.ZERO,r.ONE,r.ZERO),U.Fp=r,U.Fn=s;const O=s.BITS,T=new wNAF(U,e.endo?Math.ceil(O/2):O);return U.BASE.precompute(8),U}function pprefix(n){return Uint8Array.of(n?2:3)}function getWLengths(n,e){return{secretKey:e.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function ecdh(n,e={}){const{Fn:t}=n,r=e.randomBytes||randomBytes,s=Object.assign(getWLengths(n.Fp,t),{seed:getMinHashLength(t.ORDER)});function o(g){try{return!!_normFnElement(t,g)}catch{return!1}}function a(g,b){const{publicKey:m,publicKeyUncompressed:E}=s;try{const _=g.length;return b===!0&&_!==m||b===!1&&_!==E?!1:!!n.fromBytes(g)}catch{return!1}}function c(g=r(s.seed)){return mapHashToField(_abytes2(g,s.seed,"seed"),t.ORDER)}function l(g,b=!0){return n.BASE.multiply(_normFnElement(t,g)).toBytes(b)}function u(g){const b=c(g);return{secretKey:b,publicKey:l(b)}}function f(g){if(typeof g=="bigint")return!1;if(g instanceof n)return!0;const{secretKey:b,publicKey:m,publicKeyUncompressed:E}=s;if(t.allowedLengths||b===m)return;const _=ensureBytes("key",g).length;return _===m||_===E}function h(g,b,m=!0){if(f(g)===!0)throw new Error("first arg must be private key");if(f(b)===!1)throw new Error("second arg must be public key");const E=_normFnElement(t,g);return n.fromHex(b).multiply(E).toBytes(m)}return Object.freeze({getPublicKey:l,getSharedSecret:h,keygen:u,Point:n,utils:{isValidSecretKey:o,isValidPublicKey:a,randomSecretKey:c,isValidPrivateKey:o,randomPrivateKey:c,normPrivateKeyToScalar:g=>_normFnElement(t,g),precompute(g=8,b=n.BASE){return b.precompute(g,!1)}},lengths:s})}function ecdsa(n,e,t={}){ahash(e),_validateObject(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=t.randomBytes||randomBytes,s=t.hmac||(($,...w)=>hmac(e,$,concatBytes(...w))),{Fp:o,Fn:a}=n,{ORDER:c,BITS:l}=a,{keygen:u,getPublicKey:f,getSharedSecret:h,utils:p,lengths:g}=ecdh(n,t),b={prehash:!1,lowS:typeof t.lowS=="boolean"?t.lowS:!1,format:void 0,extraEntropy:!1},m="compact";function E($){const w=c>>_1n$1;return $>w}function _($,w){if(!a.isValidNot0(w))throw new Error(`invalid signature ${$}: out of range 1..Point.Fn.ORDER`);return w}function C($,w){validateSigFormat(w);const k=g.signature,S=w==="compact"?k:w==="recovered"?k+1:void 0;return _abytes2($,S,`${w} signature`)}class I{constructor(w,k,S){this.r=_("r",w),this.s=_("s",k),S!=null&&(this.recovery=S),Object.freeze(this)}static fromBytes(w,k=m){C(w,k);let S;if(k==="der"){const{r:R,s:D}=DER.toSig(_abytes2(w));return new I(R,D)}k==="recovered"&&(S=w[0],k="compact",w=w.subarray(1));const N=a.BYTES,A=w.subarray(0,N),B=w.subarray(N,N*2);return new I(a.fromBytes(A),a.fromBytes(B),S)}static fromHex(w,k){return this.fromBytes(hexToBytes(w),k)}addRecoveryBit(w){return new I(this.r,this.s,w)}recoverPublicKey(w){const k=o.ORDER,{r:S,s:N,recovery:A}=this;if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");if(c*_2n$1<k&&A>1)throw new Error("recovery id is ambiguous for h>1 curve");const R=A===2||A===3?S+c:S;if(!o.isValid(R))throw new Error("recovery id 2 or 3 invalid");const D=o.toBytes(R),z=n.fromBytes(concatBytes(pprefix((A&1)===0),D)),H=a.inv(R),V=M(ensureBytes("msgHash",w)),j=a.create(-V*H),q=a.create(N*H),G=n.BASE.multiplyUnsafe(j).add(z.multiplyUnsafe(q));if(G.is0())throw new Error("point at infinify");return G.assertValidity(),G}hasHighS(){return E(this.s)}toBytes(w=m){if(validateSigFormat(w),w==="der")return hexToBytes(DER.hexFromSig(this));const k=a.toBytes(this.r),S=a.toBytes(this.s);if(w==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return concatBytes(Uint8Array.of(this.recovery),k,S)}return concatBytes(k,S)}toHex(w){return bytesToHex(this.toBytes(w))}assertValidity(){}static fromCompact(w){return I.fromBytes(ensureBytes("sig",w),"compact")}static fromDER(w){return I.fromBytes(ensureBytes("sig",w),"der")}normalizeS(){return this.hasHighS()?new I(this.r,a.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return bytesToHex(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return bytesToHex(this.toBytes("compact"))}}const P=t.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const k=bytesToNumberBE(w),S=w.length*8-l;return S>0?k>>BigInt(S):k},M=t.bits2int_modN||function(w){return a.create(P(w))},L=bitMask(l);function F($){return aInRange("num < 2^"+l,$,_0n$1,L),a.toBytes($)}function K($,w){return _abytes2($,void 0,"message"),w?_abytes2(e($),void 0,"prehashed message"):$}function U($,w,k){if(["recovered","canonical"].some(j=>j in k))throw new Error("sign() legacy options not supported");const{lowS:S,prehash:N,extraEntropy:A}=validateSigOpts(k,b);$=K($,N);const B=M($),R=_normFnElement(a,w),D=[F(R),F(B)];if(A!=null&&A!==!1){const j=A===!0?r(g.secretKey):A;D.push(ensureBytes("extraEntropy",j))}const z=concatBytes(...D),H=B;function V(j){const q=P(j);if(!a.isValidNot0(q))return;const G=a.inv(q),W=n.BASE.multiply(q).toAffine(),Z=a.create(W.x);if(Z===_0n$1)return;const ke=a.create(G*a.create(H+Z*R));if(ke===_0n$1)return;let X=(W.x===Z?0:2)|Number(W.y&_1n$1),Y=ke;return S&&E(ke)&&(Y=a.neg(ke),X^=1),new I(Z,Y,X)}return{seed:z,k2sig:V}}function O($,w,k={}){$=ensureBytes("message",$);const{seed:S,k2sig:N}=U($,w,k);return createHmacDrbg(e.outputLen,a.BYTES,s)(S,N)}function T($){let w;const k=typeof $=="string"||isBytes($),S=!k&&$!==null&&typeof $=="object"&&typeof $.r=="bigint"&&typeof $.s=="bigint";if(!k&&!S)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(S)w=new I($.r,$.s);else if(k){try{w=I.fromBytes(ensureBytes("sig",$),"der")}catch(N){if(!(N instanceof DER.Err))throw N}if(!w)try{w=I.fromBytes(ensureBytes("sig",$),"compact")}catch{return!1}}return w||!1}function x($,w,k,S={}){const{lowS:N,prehash:A,format:B}=validateSigOpts(S,b);if(k=ensureBytes("publicKey",k),w=K(ensureBytes("message",w),A),"strict"in S)throw new Error("options.strict was renamed to lowS");const R=B===void 0?T($):I.fromBytes(ensureBytes("sig",$),B);if(R===!1)return!1;try{const D=n.fromBytes(k);if(N&&R.hasHighS())return!1;const{r:z,s:H}=R,V=M(w),j=a.inv(H),q=a.create(V*j),G=a.create(z*j),W=n.BASE.multiplyUnsafe(q).add(D.multiplyUnsafe(G));return W.is0()?!1:a.create(W.x)===z}catch{return!1}}function v($,w,k={}){const{prehash:S}=validateSigOpts(k,b);return w=K(w,S),I.fromBytes($,"recovered").recoverPublicKey(w).toBytes()}return Object.freeze({keygen:u,getPublicKey:f,getSharedSecret:h,utils:p,lengths:g,Point:n,sign:O,verify:x,recoverPublicKey:v,Signature:I,hash:e})}function _weierstrass_legacy_opts_to_new(n){const e={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},t=n.Fp;let r=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(a=>Math.ceil(a/2)))):void 0;const s=Field(e.n,{BITS:n.nBitLength,allowedLengths:r,modFromBytes:n.wrapPrivateKey}),o={Fp:t,Fn:s,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:e,curveOpts:o}}function _ecdsa_legacy_opts_to_new(n){const{CURVE:e,curveOpts:t}=_weierstrass_legacy_opts_to_new(n),r={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:e,curveOpts:t,hash:n.hash,ecdsaOpts:r}}function _ecdsa_new_output_to_legacy(n,e){const t=e.Point;return Object.assign({},e,{ProjectivePoint:t,CURVE:Object.assign({},n,nLength(t.Fn.ORDER,t.Fn.BITS))})}function weierstrass(n){const{CURVE:e,curveOpts:t,hash:r,ecdsaOpts:s}=_ecdsa_legacy_opts_to_new(n),o=weierstrassN(e,t),a=ecdsa(o,r,s);return _ecdsa_new_output_to_legacy(n,a)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function createCurve(n,e){const t=r=>weierstrass({...n,hash:r});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1_CURVE={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},secp256k1_ENDO={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2);function sqrtMod(n){const e=secp256k1_CURVE.p,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),u=n*n*n%e,f=u*u*n%e,h=pow2(f,t,e)*f%e,p=pow2(h,t,e)*f%e,g=pow2(p,_2n,e)*u%e,b=pow2(g,s,e)*g%e,m=pow2(b,o,e)*b%e,E=pow2(m,c,e)*m%e,_=pow2(E,l,e)*E%e,C=pow2(_,c,e)*m%e,I=pow2(C,t,e)*f%e,P=pow2(I,a,e)*b%e,M=pow2(P,r,e)*u%e,L=pow2(M,_2n,e);if(!Fpk1.eql(Fpk1.sqr(L),n))throw new Error("Cannot find square root");return L}const Fpk1=Field(secp256k1_CURVE.p,{sqrt:sqrtMod}),secp256k1=createCurve({...secp256k1_CURVE,Fp:Fpk1,lowS:!0,endo:secp256k1_ENDO},sha256$1),TAGGED_HASH_PREFIXES={};function taggedHash(n,...e){let t=TAGGED_HASH_PREFIXES[n];if(t===void 0){const r=sha256$1(utf8ToBytes(n));t=concatBytes(r,r),TAGGED_HASH_PREFIXES[n]=t}return sha256$1(concatBytes(t,...e))}const pointToBytes=n=>n.toBytes(!0).slice(1),Pointk1=secp256k1.Point,hasEven=n=>n%_2n===_0n;function schnorrGetExtPubKey(n){const{Fn:e,BASE:t}=Pointk1,r=_normFnElement(e,n),s=t.multiply(r);return{scalar:hasEven(s.y)?r:e.neg(r),bytes:pointToBytes(s)}}function lift_x(n){const e=Fpk1;if(!e.isValidNot0(n))throw new Error("invalid x: Fail if x ≥ p");const t=e.create(n*n),r=e.create(t*n+BigInt(7));let s=e.sqrt(r);hasEven(s)||(s=e.neg(s));const o=Pointk1.fromAffine({x:n,y:s});return o.assertValidity(),o}const num=bytesToNumberBE;function challenge(...n){return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge",...n)))}function schnorrGetPublicKey(n){return schnorrGetExtPubKey(n).bytes}function schnorrSign(n,e,t=randomBytes(32)){const{Fn:r}=Pointk1,s=ensureBytes("message",n),{bytes:o,scalar:a}=schnorrGetExtPubKey(e),c=ensureBytes("auxRand",t,32),l=r.toBytes(a^num(taggedHash("BIP0340/aux",c))),u=taggedHash("BIP0340/nonce",l,o,s),{bytes:f,scalar:h}=schnorrGetExtPubKey(u),p=challenge(f,o,s),g=new Uint8Array(64);if(g.set(f,0),g.set(r.toBytes(r.create(h+p*a)),32),!schnorrVerify(g,s,o))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify(n,e,t){const{Fn:r,BASE:s}=Pointk1,o=ensureBytes("signature",n,64),a=ensureBytes("message",e),c=ensureBytes("publicKey",t,32);try{const l=lift_x(num(c)),u=num(o.subarray(0,32));if(!inRange(u,_1n,secp256k1_CURVE.p))return!1;const f=num(o.subarray(32,64));if(!inRange(f,_1n,secp256k1_CURVE.n))return!1;const h=challenge(r.toBytes(u),pointToBytes(l),a),p=s.multiplyUnsafe(f).add(l.multiplyUnsafe(r.neg(h))),{x:g,y:b}=p.toAffine();return!(p.is0()||!hasEven(b)||g!==u)}catch{return!1}}const schnorr=(()=>{const t=(s=randomBytes(48))=>mapHashToField(s,secp256k1_CURVE.n);secp256k1.utils.randomSecretKey;function r(s){const o=t(s);return{secretKey:o,publicKey:schnorrGetPublicKey(o)}}return{keygen:r,getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,Point:Pointk1,utils:{randomSecretKey:t,randomPrivateKey:t,taggedHash,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:32*2,seed:48}}})(),sha256=sha256$1;var dist={},LRUCache$1={},LRUCacheNode$1={};Object.defineProperty(LRUCacheNode$1,"__esModule",{value:!0});LRUCacheNode$1.LRUCacheNode=void 0;class LRUCacheNode{constructor(e,t,r){const{entryExpirationTimeInMS:s=null,next:o=null,prev:a=null,onEntryEvicted:c,onEntryMarkedAsMostRecentlyUsed:l,clone:u,cloneFn:f}=r??{};if(typeof s=="number"&&(s<=0||Number.isNaN(s)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=u??!1,this.cloneFn=f??this.defaultClone,this.key=e,this.internalValue=this.clone?this.cloneFn(t):t,this.created=Date.now(),this.entryExpirationTimeInMS=s,this.next=o,this.prev=a,this.onEntryEvicted=c,this.onEntryMarkedAsMostRecentlyUsed=l}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:e,value:t,isExpired:r}=this;this.onEntryEvicted({key:e,value:t,isExpired:r})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:e,value:t}=this;this.onEntryMarkedAsMostRecentlyUsed({key:e,value:t})}}defaultClone(e){return typeof e=="boolean"||typeof e=="string"||typeof e=="number"?e:JSON.parse(JSON.stringify(e))}}LRUCacheNode$1.LRUCacheNode=LRUCacheNode;Object.defineProperty(LRUCache$1,"__esModule",{value:!0});LRUCache$1.LRUCache=void 0;const LRUCacheNode_1=LRUCacheNode$1;class LRUCache{constructor(e){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:t=25,entryExpirationTimeInMS:r=null,onEntryEvicted:s,onEntryMarkedAsMostRecentlyUsed:o,cloneFn:a,clone:c}=e??{};if(Number.isNaN(t)||t<=0)throw new Error("maxSize must be greater than 0.");if(typeof r=="number"&&(r<=0||Number.isNaN(r)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=t,this.entryExpirationTimeInMS=r,this.onEntryEvicted=s,this.onEntryMarkedAsMostRecentlyUsed=o,this.clone=c,this.cloneFn=a}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(e){if(Number.isNaN(e)||e<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=e,this.enforceSizeLimit()}set(e,t,r){const s=this.lookupTable.get(e);s&&this.removeNodeFromListAndLookupTable(s);const o=new LRUCacheNode_1.LRUCacheNode(e,t,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...r});return this.setNodeAsHead(o),this.lookupTable.set(e,o),this.enforceSizeLimit(),this}get(e){const t=this.lookupTable.get(e);return t?t.isExpired?(this.removeNodeFromListAndLookupTable(t),null):(this.setNodeAsHead(t),t.value):null}peek(e){const t=this.lookupTable.get(e);return t?t.isExpired?(this.removeNodeFromListAndLookupTable(t),null):t.value:null}delete(e){const t=this.lookupTable.get(e);return t?this.removeNodeFromListAndLookupTable(t):!1}has(e){const t=this.lookupTable.get(e);return t?t.isExpired?(this.removeNodeFromListAndLookupTable(t),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(e){let t=this.head;for(;t;){if(t.isExpired){const s=t.next;this.removeNodeFromListAndLookupTable(t),t=s;continue}const r=this.mapNodeToEntry(t);if(e(r))return this.setNodeAsHead(t),r;t=t.next}return null}forEach(e){let t=this.head,r=0;for(;t;){if(t.isExpired){const s=t.next;this.removeNodeFromListAndLookupTable(t),t=s;continue}e(t.value,t.key,r),t=t.next,r++}}*values(){let e=this.head;for(;e;){if(e.isExpired){const t=e.next;this.removeNodeFromListAndLookupTable(e),e=t;continue}yield e.value,e=e.next}}*keys(){let e=this.head;for(;e;){if(e.isExpired){const t=e.next;this.removeNodeFromListAndLookupTable(e),e=t;continue}yield e.key,e=e.next}}*entries(){let e=this.head;for(;e;){if(e.isExpired){const t=e.next;this.removeNodeFromListAndLookupTable(e),e=t;continue}yield this.mapNodeToEntry(e),e=e.next}}*[Symbol.iterator](){let e=this.head;for(;e;){if(e.isExpired){const t=e.next;this.removeNodeFromListAndLookupTable(e),e=t;continue}yield this.mapNodeToEntry(e),e=e.next}}enforceSizeLimit(){let e=this.tail;for(;e!==null&&this.size>this.maxSizeInternal;){const t=e.prev;this.removeNodeFromListAndLookupTable(e),e=t}}mapNodeToEntry({key:e,value:t}){return{key:e,value:t}}setNodeAsHead(e){this.removeNodeFromList(e),this.head?(e.next=this.head,this.head.prev=e,this.head=e):(this.head=e,this.tail=e),e.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(e){e.prev!==null&&(e.prev.next=e.next),e.next!==null&&(e.next.prev=e.prev),this.head===e&&(this.head=e.next),this.tail===e&&(this.tail=e.prev),e.next=null,e.prev=null}removeNodeFromListAndLookupTable(e){return e.invokeOnEvicted(),this.removeNodeFromList(e),this.lookupTable.delete(e.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const e=[];for(const t of this.lookupTable.values())t.isExpired&&e.push(t);e.forEach(t=>this.removeNodeFromListAndLookupTable(t))}}LRUCache$1.LRUCache=LRUCache;(function(n){var e=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),t=commonjsGlobal&&commonjsGlobal.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(n,"__esModule",{value:!0}),t(LRUCache$1,n)})(dist);function pbkdf2Init(n,e,t,r){assert.hash(n);const s=checkOpts$1({dkLen:32,asyncTick:10},r),{c:o,dkLen:a,asyncTick:c}=s;if(assert.number(o),assert.number(a),assert.number(c),o<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const l=toBytes$2(e),u=toBytes$2(t),f=new Uint8Array(a),h=hmac$1.create(n,l),p=h._cloneInto().update(u);return{c:o,dkLen:a,asyncTick:c,DK:f,PRF:h,PRFSalt:p}}function pbkdf2Output(n,e,t,r,s){return n.destroy(),e.destroy(),r&&r.destroy(),s.fill(0),t}function pbkdf2(n,e,t,r){const{c:s,dkLen:o,DK:a,PRF:c,PRFSalt:l}=pbkdf2Init(n,e,t,r);let u;const f=new Uint8Array(4),h=createView$2(f),p=new Uint8Array(c.outputLen);for(let g=1,b=0;b<o;g++,b+=c.outputLen){const m=a.subarray(b,b+c.outputLen);h.setInt32(0,g,!1),(u=l._cloneInto(u)).update(f).digestInto(p),m.set(p.subarray(0,m.length));for(let E=1;E<s;E++){c._cloneInto(u).update(p).digestInto(p);for(let _=0;_<m.length;_++)m[_]^=p[_]}}return pbkdf2Output(c,l,a,u,p)}const rotl=(n,e)=>n<<e|n>>>32-e;function XorAndSalsa(n,e,t,r,s,o){let a=n[e++]^t[r++],c=n[e++]^t[r++],l=n[e++]^t[r++],u=n[e++]^t[r++],f=n[e++]^t[r++],h=n[e++]^t[r++],p=n[e++]^t[r++],g=n[e++]^t[r++],b=n[e++]^t[r++],m=n[e++]^t[r++],E=n[e++]^t[r++],_=n[e++]^t[r++],C=n[e++]^t[r++],I=n[e++]^t[r++],P=n[e++]^t[r++],M=n[e++]^t[r++],L=a,F=c,K=l,U=u,O=f,T=h,x=p,v=g,$=b,w=m,k=E,S=_,N=C,A=I,B=P,R=M;for(let D=0;D<8;D+=2)O^=rotl(L+N|0,7),$^=rotl(O+L|0,9),N^=rotl($+O|0,13),L^=rotl(N+$|0,18),w^=rotl(T+F|0,7),A^=rotl(w+T|0,9),F^=rotl(A+w|0,13),T^=rotl(F+A|0,18),B^=rotl(k+x|0,7),K^=rotl(B+k|0,9),x^=rotl(K+B|0,13),k^=rotl(x+K|0,18),U^=rotl(R+S|0,7),v^=rotl(U+R|0,9),S^=rotl(v+U|0,13),R^=rotl(S+v|0,18),F^=rotl(L+U|0,7),K^=rotl(F+L|0,9),U^=rotl(K+F|0,13),L^=rotl(U+K|0,18),x^=rotl(T+O|0,7),v^=rotl(x+T|0,9),O^=rotl(v+x|0,13),T^=rotl(O+v|0,18),S^=rotl(k+w|0,7),$^=rotl(S+k|0,9),w^=rotl($+S|0,13),k^=rotl(w+$|0,18),N^=rotl(R+B|0,7),A^=rotl(N+R|0,9),B^=rotl(A+N|0,13),R^=rotl(B+A|0,18);s[o++]=a+L|0,s[o++]=c+F|0,s[o++]=l+K|0,s[o++]=u+U|0,s[o++]=f+O|0,s[o++]=h+T|0,s[o++]=p+x|0,s[o++]=g+v|0,s[o++]=b+$|0,s[o++]=m+w|0,s[o++]=E+k|0,s[o++]=_+S|0,s[o++]=C+N|0,s[o++]=I+A|0,s[o++]=P+B|0,s[o++]=M+R|0}function BlockMix(n,e,t,r,s){let o=r+0,a=r+16*s;for(let c=0;c<16;c++)t[a+c]=n[e+(2*s-1)*16+c];for(let c=0;c<s;c++,o+=16,e+=16)XorAndSalsa(t,a,n,e,t,o),c>0&&(a+=16),XorAndSalsa(t,o,n,e+=16,t,a)}function scryptInit(n,e,t){const r=checkOpts$1({dkLen:32,asyncTick:10,maxmem:1073742848},t),{N:s,r:o,p:a,dkLen:c,asyncTick:l,maxmem:u,onProgress:f}=r;if(assert.number(s),assert.number(o),assert.number(a),assert.number(c),assert.number(l),assert.number(u),f!==void 0&&typeof f!="function")throw new Error("progressCb should be function");const h=128*o,p=h/4;if(s<=1||s&s-1||s>=2**(h/8)||s>2**32)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(a<0||a>(2**32-1)*32/h)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(c<0||c>(2**32-1)*32)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const g=h*(s+a);if(g>u)throw new Error(`Scrypt: parameters too large, ${g} (128 * r * (N + p)) > ${u} (maxmem)`);const b=pbkdf2(sha256$2,n,e,{c:1,dkLen:h*a}),m=u32$1(b),E=u32$1(new Uint8Array(h*s)),_=u32$1(new Uint8Array(h));let C=()=>{};if(f){const I=2*s*a,P=Math.max(Math.floor(I/1e4),1);let M=0;C=()=>{M++,f&&(!(M%P)||M===I)&&f(M/I)}}return{N:s,r:o,p:a,dkLen:c,blockSize32:p,V:E,B32:m,B:b,tmp:_,blockMixCb:C,asyncTick:l}}function scryptOutput(n,e,t,r,s){const o=pbkdf2(sha256$2,n,t,{c:1,dkLen:e});return t.fill(0),r.fill(0),s.fill(0),o}function scrypt(n,e,t){const{N:r,r:s,p:o,dkLen:a,blockSize32:c,V:l,B32:u,B:f,tmp:h,blockMixCb:p}=scryptInit(n,e,t);for(let g=0;g<o;g++){const b=c*g;for(let m=0;m<c;m++)l[m]=u[b+m];for(let m=0,E=0;m<r-1;m++)BlockMix(l,E,l,E+=c,s),p();BlockMix(l,(r-1)*c,u,b,s),p();for(let m=0;m<r;m++){const E=u[b+c-16]%r;for(let _=0;_<c;_++)h[_]=u[b+_]^l[E*c+_];BlockMix(h,0,u,b,s),p()}}return scryptOutput(n,a,f,l,h)}var Bech32MaxSize$1=5e3;function encodeBech32$1(n,e){let t=bech32$1.toWords(e);return bech32$1.encode(n,t,Bech32MaxSize$1)}function encodeBytes$1(n,e){return encodeBech32$1(n,e)}function encrypt$1(n,e,t=16,r=2){let s=randomBytes$1(16),o=2**t,a=scrypt(e.normalize("NFKC"),s,{N:o,r:8,p:1,dkLen:32}),c=randomBytes$1(24),l=Uint8Array.from([r]),f=xchacha20poly1305(a,c,l).encrypt(n),h=concatBytes$1(Uint8Array.from([2]),Uint8Array.from([t]),s,c,l,f);return encodeBytes$1("ncryptsec",h)}function decrypt$1(n,e){let{prefix:t,words:r}=bech32$1.decode(n,Bech32MaxSize$1);if(t!=="ncryptsec")throw new Error(`invalid prefix ${t}, expected 'ncryptsec'`);let s=new Uint8Array(bech32$1.fromWords(r)),o=s[0];if(o!==2)throw new Error(`invalid version ${o}, expected 0x02`);let c=2**s[1],l=s.slice(2,18),u=s.slice(18,42),f=s[42],h=Uint8Array.from([f]),p=s.slice(43),g=scrypt(e.normalize("NFKC"),l,{N:c,r:8,p:1,dkLen:32});return xchacha20poly1305(g,u,h).decrypt(p)}const nip49_star=Object.freeze(Object.defineProperty({__proto__:null,decrypt:decrypt$1,encrypt:encrypt$1},Symbol.toStringTag,{value:"Module"}));var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder,NostrTypeGuard={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize=5e3,BECH32_REGEX$1=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(n){const e=new Uint8Array(4);return e[0]=n>>24&255,e[1]=n>>16&255,e[2]=n>>8&255,e[3]=n&255,e}function decodeNostrURI(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode(n)}catch{return{type:"invalid",data:null}}}function decode(n){var s,o,a,c,l,u,f;let{prefix:e,words:t}=bech32$1.decode(n,Bech32MaxSize),r=new Uint8Array(bech32$1.fromWords(t));switch(e){case"nprofile":{let h=parseTLV(r);if(!((s=h[0])!=null&&s[0]))throw new Error("missing TLV 0 for nprofile");if(h[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$1(h[0][0]),relays:h[1]?h[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nevent":{let h=parseTLV(r);if(!((o=h[0])!=null&&o[0]))throw new Error("missing TLV 0 for nevent");if(h[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(h[2]&&h[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(h[3]&&h[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$1(h[0][0]),relays:h[1]?h[1].map(p=>utf8Decoder.decode(p)):[],author:(a=h[2])!=null&&a[0]?bytesToHex$1(h[2][0]):void 0,kind:(c=h[3])!=null&&c[0]?parseInt(bytesToHex$1(h[3][0]),16):void 0}}}case"naddr":{let h=parseTLV(r);if(!((l=h[0])!=null&&l[0]))throw new Error("missing TLV 0 for naddr");if(!((u=h[2])!=null&&u[0]))throw new Error("missing TLV 2 for naddr");if(h[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((f=h[3])!=null&&f[0]))throw new Error("missing TLV 3 for naddr");if(h[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(h[0][0]),pubkey:bytesToHex$1(h[2][0]),kind:parseInt(bytesToHex$1(h[3][0]),16),relays:h[1]?h[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nsec":return{type:e,data:r};case"npub":case"note":return{type:e,data:bytesToHex$1(r)};default:throw new Error(`unknown prefix ${e}`)}}function parseTLV(n){let e={},t=n;for(;t.length>0;){let r=t[0],s=t[1],o=t.slice(2,2+s);if(t=t.slice(2+s),o.length<s)throw new Error(`not enough data to read on TLV ${r}`);e[r]=e[r]||[],e[r].push(o)}return e}function nsecEncode(n){return encodeBytes("nsec",n)}function npubEncode(n){return encodeBytes("npub",hexToBytes$1(n))}function noteEncode(n){return encodeBytes("note",hexToBytes$1(n))}function encodeBech32(n,e){let t=bech32$1.toWords(e);return bech32$1.encode(n,t,Bech32MaxSize)}function encodeBytes(n,e){return encodeBech32(n,e)}function nprofileEncode(n){let e=encodeTLV({0:[hexToBytes$1(n.pubkey)],1:(n.relays||[]).map(t=>utf8Encoder.encode(t))});return encodeBech32("nprofile",e)}function neventEncode(n){let e;n.kind!==void 0&&(e=integerToUint8Array(n.kind));let t=encodeTLV({0:[hexToBytes$1(n.id)],1:(n.relays||[]).map(r=>utf8Encoder.encode(r)),2:n.author?[hexToBytes$1(n.author)]:[],3:e?[new Uint8Array(e)]:[]});return encodeBech32("nevent",t)}function naddrEncode(n){let e=new ArrayBuffer(4);new DataView(e).setUint32(0,n.kind,!1);let t=encodeTLV({0:[utf8Encoder.encode(n.identifier)],1:(n.relays||[]).map(r=>utf8Encoder.encode(r)),2:[hexToBytes$1(n.pubkey)],3:[new Uint8Array(e)]});return encodeBech32("naddr",t)}function encodeTLV(n){let e=[];return Object.entries(n).reverse().forEach(([t,r])=>{r.forEach(s=>{let o=new Uint8Array(s.length+2);o.set([parseInt(t)],0),o.set([s.length],1),o.set(s,2),e.push(o)})}),concatBytes$1(...e)}const nip19_star=Object.freeze(Object.defineProperty({__proto__:null,BECH32_REGEX:BECH32_REGEX$1,Bech32MaxSize,NostrTypeGuard,decode,decodeNostrURI,encodeBytes,naddrEncode,neventEncode,noteEncode,nprofileEncode,npubEncode,nsecEncode},Symbol.toStringTag,{value:"Module"}));var lib={};(function(n){/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(n,"__esModule",{value:!0}),n.bytes=n.stringToBytes=n.str=n.bytesToString=n.hex=n.utf8=n.bech32m=n.bech32=n.base58check=n.base58xmr=n.base58xrp=n.base58flickr=n.base58=n.base64url=n.base64=n.base32crockford=n.base32hex=n.base32=n.base16=n.utils=n.assertNumber=void 0;function e(T){if(!Number.isSafeInteger(T))throw new Error(`Wrong integer: ${T}`)}n.assertNumber=e;function t(...T){const x=(w,k)=>S=>w(k(S)),v=Array.from(T).reverse().reduce((w,k)=>w?x(w,k.encode):k.encode,void 0),$=T.reduce((w,k)=>w?x(w,k.decode):k.decode,void 0);return{encode:v,decode:$}}function r(T){return{encode:x=>{if(!Array.isArray(x)||x.length&&typeof x[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return x.map(v=>{if(e(v),v<0||v>=T.length)throw new Error(`Digit index outside alphabet: ${v} (alphabet: ${T.length})`);return T[v]})},decode:x=>{if(!Array.isArray(x)||x.length&&typeof x[0]!="string")throw new Error("alphabet.decode input should be array of strings");return x.map(v=>{if(typeof v!="string")throw new Error(`alphabet.decode: not string element=${v}`);const $=T.indexOf(v);if($===-1)throw new Error(`Unknown letter: "${v}". Allowed: ${T}`);return $})}}}function s(T=""){if(typeof T!="string")throw new Error("join separator should be string");return{encode:x=>{if(!Array.isArray(x)||x.length&&typeof x[0]!="string")throw new Error("join.encode input should be array of strings");for(let v of x)if(typeof v!="string")throw new Error(`join.encode: non-string input=${v}`);return x.join(T)},decode:x=>{if(typeof x!="string")throw new Error("join.decode input should be string");return x.split(T)}}}function o(T,x="="){if(e(T),typeof x!="string")throw new Error("padding chr should be string");return{encode(v){if(!Array.isArray(v)||v.length&&typeof v[0]!="string")throw new Error("padding.encode input should be array of strings");for(let $ of v)if(typeof $!="string")throw new Error(`padding.encode: non-string input=${$}`);for(;v.length*T%8;)v.push(x);return v},decode(v){if(!Array.isArray(v)||v.length&&typeof v[0]!="string")throw new Error("padding.encode input should be array of strings");for(let w of v)if(typeof w!="string")throw new Error(`padding.decode: non-string input=${w}`);let $=v.length;if($*T%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;$>0&&v[$-1]===x;$--)if(!(($-1)*T%8))throw new Error("Invalid padding: string has too much padding");return v.slice(0,$)}}}function a(T){if(typeof T!="function")throw new Error("normalize fn should be function");return{encode:x=>x,decode:x=>T(x)}}function c(T,x,v){if(x<2)throw new Error(`convertRadix: wrong from=${x}, base cannot be less than 2`);if(v<2)throw new Error(`convertRadix: wrong to=${v}, base cannot be less than 2`);if(!Array.isArray(T))throw new Error("convertRadix: data should be array");if(!T.length)return[];let $=0;const w=[],k=Array.from(T);for(k.forEach(S=>{if(e(S),S<0||S>=x)throw new Error(`Wrong integer: ${S}`)});;){let S=0,N=!0;for(let A=$;A<k.length;A++){const B=k[A],R=x*S+B;if(!Number.isSafeInteger(R)||x*S/x!==S||R-B!==x*S)throw new Error("convertRadix: carry overflow");if(S=R%v,k[A]=Math.floor(R/v),!Number.isSafeInteger(k[A])||k[A]*v+S!==R)throw new Error("convertRadix: carry overflow");if(N)k[A]?N=!1:$=A;else continue}if(w.push(S),N)break}for(let S=0;S<T.length-1&&T[S]===0;S++)w.push(0);return w.reverse()}const l=(T,x)=>x?l(x,T%x):T,u=(T,x)=>T+(x-l(T,x));function f(T,x,v,$){if(!Array.isArray(T))throw new Error("convertRadix2: data should be array");if(x<=0||x>32)throw new Error(`convertRadix2: wrong from=${x}`);if(v<=0||v>32)throw new Error(`convertRadix2: wrong to=${v}`);if(u(x,v)>32)throw new Error(`convertRadix2: carry overflow from=${x} to=${v} carryBits=${u(x,v)}`);let w=0,k=0;const S=2**v-1,N=[];for(const A of T){if(e(A),A>=2**x)throw new Error(`convertRadix2: invalid data word=${A} from=${x}`);if(w=w<<x|A,k+x>32)throw new Error(`convertRadix2: carry overflow pos=${k} from=${x}`);for(k+=x;k>=v;k-=v)N.push((w>>k-v&S)>>>0);w&=2**k-1}if(w=w<<v-k&S,!$&&k>=x)throw new Error("Excess padding");if(!$&&w)throw new Error(`Non-zero padding: ${w}`);return $&&k>0&&N.push(w>>>0),N}function h(T){return e(T),{encode:x=>{if(!(x instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return c(Array.from(x),2**8,T)},decode:x=>{if(!Array.isArray(x)||x.length&&typeof x[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(c(x,T,2**8))}}}function p(T,x=!1){if(e(T),T<=0||T>32)throw new Error("radix2: bits should be in (0..32]");if(u(8,T)>32||u(T,8)>32)throw new Error("radix2: carry overflow");return{encode:v=>{if(!(v instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return f(Array.from(v),8,T,!x)},decode:v=>{if(!Array.isArray(v)||v.length&&typeof v[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(f(v,T,8,x))}}}function g(T){if(typeof T!="function")throw new Error("unsafeWrapper fn should be function");return function(...x){try{return T.apply(null,x)}catch{}}}function b(T,x){if(e(T),typeof x!="function")throw new Error("checksum fn should be function");return{encode(v){if(!(v instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const $=x(v).slice(0,T),w=new Uint8Array(v.length+T);return w.set(v),w.set($,v.length),w},decode(v){if(!(v instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const $=v.slice(0,-T),w=x($).slice(0,T),k=v.slice(-T);for(let S=0;S<T;S++)if(w[S]!==k[S])throw new Error("Invalid checksum");return $}}}n.utils={alphabet:r,chain:t,checksum:b,radix:h,radix2:p,join:s,padding:o},n.base16=t(p(4),r("0123456789ABCDEF"),s("")),n.base32=t(p(5),r("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),o(5),s("")),n.base32hex=t(p(5),r("0123456789ABCDEFGHIJKLMNOPQRSTUV"),o(5),s("")),n.base32crockford=t(p(5),r("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),s(""),a(T=>T.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),n.base64=t(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),o(6),s("")),n.base64url=t(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),o(6),s(""));const m=T=>t(h(58),r(T),s(""));n.base58=m("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),n.base58flickr=m("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),n.base58xrp=m("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const E=[0,2,3,5,6,7,9,10,11];n.base58xmr={encode(T){let x="";for(let v=0;v<T.length;v+=8){const $=T.subarray(v,v+8);x+=n.base58.encode($).padStart(E[$.length],"1")}return x},decode(T){let x=[];for(let v=0;v<T.length;v+=11){const $=T.slice(v,v+11),w=E.indexOf($.length),k=n.base58.decode($);for(let S=0;S<k.length-w;S++)if(k[S]!==0)throw new Error("base58xmr: wrong padding");x=x.concat(Array.from(k.slice(k.length-w)))}return Uint8Array.from(x)}};const _=T=>t(b(4,x=>T(T(x))),n.base58);n.base58check=_;const C=t(r("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),s("")),I=[996825010,642813549,513874426,1027748829,705979059];function P(T){const x=T>>25;let v=(T&33554431)<<5;for(let $=0;$<I.length;$++)(x>>$&1)===1&&(v^=I[$]);return v}function M(T,x,v=1){const $=T.length;let w=1;for(let k=0;k<$;k++){const S=T.charCodeAt(k);if(S<33||S>126)throw new Error(`Invalid prefix (${T})`);w=P(w)^S>>5}w=P(w);for(let k=0;k<$;k++)w=P(w)^T.charCodeAt(k)&31;for(let k of x)w=P(w)^k;for(let k=0;k<6;k++)w=P(w);return w^=v,C.encode(f([w%2**30],30,5,!1))}function L(T){const x=T==="bech32"?1:734539939,v=p(5),$=v.decode,w=v.encode,k=g($);function S(R,D,z=90){if(typeof R!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof R}`);if(!Array.isArray(D)||D.length&&typeof D[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof D}`);const H=R.length+7+D.length;if(z!==!1&&H>z)throw new TypeError(`Length ${H} exceeds limit ${z}`);return R=R.toLowerCase(),`${R}1${C.encode(D)}${M(R,D,x)}`}function N(R,D=90){if(typeof R!="string")throw new Error(`bech32.decode input should be string, not ${typeof R}`);if(R.length<8||D!==!1&&R.length>D)throw new TypeError(`Wrong string length: ${R.length} (${R}). Expected (8..${D})`);const z=R.toLowerCase();if(R!==z&&R!==R.toUpperCase())throw new Error("String must be lowercase or uppercase");R=z;const H=R.lastIndexOf("1");if(H===0||H===-1)throw new Error('Letter "1" must be present between prefix and data only');const V=R.slice(0,H),j=R.slice(H+1);if(j.length<6)throw new Error("Data must be at least 6 characters long");const q=C.decode(j).slice(0,-6),G=M(V,q,x);if(!j.endsWith(G))throw new Error(`Invalid checksum in ${R}: expected "${G}"`);return{prefix:V,words:q}}const A=g(N);function B(R){const{prefix:D,words:z}=N(R,!1);return{prefix:D,words:z,bytes:$(z)}}return{encode:S,decode:N,decodeToBytes:B,decodeUnsafe:A,fromWords:$,fromWordsUnsafe:k,toWords:w}}n.bech32=L("bech32"),n.bech32m=L("bech32m"),n.utf8={encode:T=>new TextDecoder().decode(T),decode:T=>new TextEncoder().encode(T)},n.hex=t(p(4),r("0123456789abcdef"),s(""),a(T=>{if(typeof T!="string"||T.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof T} with length ${T.length}`);return T.toLowerCase()}));const F={utf8:n.utf8,hex:n.hex,base16:n.base16,base32:n.base32,base64:n.base64,base64url:n.base64url,base58:n.base58,base58xmr:n.base58xmr},K=`Invalid encoding type. Available types: ${Object.keys(F).join(", ")}`,U=(T,x)=>{if(typeof T!="string"||!F.hasOwnProperty(T))throw new TypeError(K);if(!(x instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return F[T].encode(x)};n.bytesToString=U,n.str=n.bytesToString;const O=(T,x)=>{if(!F.hasOwnProperty(T))throw new TypeError(K);if(typeof x!="string")throw new TypeError("stringToBytes() expects string");return F[T].decode(x)};n.stringToBytes=O,n.bytes=n.stringToBytes})(lib);const{bech32,hex,utf8}=lib;BigInt(1e3),BigInt(1e6),BigInt(1e9),BigInt(1e12);BigInt("2100000000000000000");BigInt(1e11);const TAGCODES={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27};for(let n=0,e=Object.keys(TAGCODES);n<e.length;n++)e[n],TAGCODES[e[n]].toString();var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of __getOwnPropNames(e))!__hasOwnProp.call(n,s)&&s!==t&&__defProp(n,s,{get:()=>e[s],enumerable:!(r=__getOwnPropDesc(e,s))||r.enumerable});return n},__reExport=(n,e,t)=>(__copyProps(n,e,"default"),t);function getRelaysForSync(n,e,t="write"){if(!n.outboxTracker)return;const r=n.outboxTracker.data.get(e);if(r)return t==="write"?r.writeRelays:r.readRelays}async function getWriteRelaysFor(n,e,t="write"){if(n.outboxTracker)return n.outboxTracker.data.has(e)||await n.outboxTracker.trackUsers([e]),getRelaysForSync(n,e,t)}function getTopRelaysForAuthors(n,e){const t=new Map;return e.forEach(s=>{const o=getRelaysForSync(n,s);o&&o.forEach(a=>{const c=t.get(a)||0;t.set(a,c+1)})}),Array.from(t.entries()).sort((s,o)=>o[1]-s[1]).map(s=>s[0])}function getAllRelaysForAllPubkeys(n,e,t="read"){const r=new Map,s=new Set;return e.forEach(o=>{const a=getRelaysForSync(n,o,t);a&&a.size>0?(a.forEach(c=>{(r.get(c)||new Set).add(o)}),r.set(o,a)):s.add(o)}),{pubkeysToRelays:r,authorsMissingRelays:s}}function chooseRelayCombinationForPubkeys(n,e,t,{count:r,preferredRelays:s}={}){r??(r=2),s??(s=new Set);const o=n.pool,a=o.connectedRelays();a.forEach(p=>{s==null||s.add(p.url)});const c=new Map,{pubkeysToRelays:l,authorsMissingRelays:u}=getAllRelaysForAllPubkeys(n,e,t),f=getTopRelaysForAuthors(n,e),h=(p,g)=>{const b=c.get(g)||[];b.push(p),c.set(g,b)};for(const[p,g]of l.entries()){let b=r;const m=new Set;for(const E of a)g.has(E.url)&&(h(p,E.url),m.add(E.url),b--);for(const E of g)m.has(E)||c.has(E)&&(h(p,E),m.add(E),b--);if(!(b<=0))for(const E of f){if(b<=0)break;m.has(E)||g.has(E)&&(h(p,E),m.add(E),b--)}}for(const p of u)o.permanentAndConnectedRelays().forEach(g=>{const b=c.get(g.url)||[];b.push(p),c.set(g.url,b)});return c}function getRelaysForFilterWithAuthors(n,e,t=2){return chooseRelayCombinationForPubkeys(n,e,"write",{count:t})}function tryNormalizeRelayUrl(n){try{return normalizeRelayUrl(n)}catch{return}}function normalizeRelayUrl(n){let e=normalizeUrl(n,{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return e.endsWith("/")||(e+="/"),e}function normalize(n){const e=new Set;for(const t of n)try{e.add(normalizeRelayUrl(t))}catch{}return Array.from(e)}var DATA_URL_DEFAULT_MIME_TYPE="text/plain",DATA_URL_DEFAULT_CHARSET="us-ascii",testParameter=(n,e)=>e.some(t=>t instanceof RegExp?t.test(n):t===n),supportedProtocols=new Set(["https:","http:","file:"]),hasCustomProtocol=n=>{try{const{protocol:e}=new URL(n);return e.endsWith(":")&&!e.includes(".")&&!supportedProtocols.has(e)}catch{return!1}},normalizeDataURL=(n,{stripHash:e})=>{var h,p,g,b;const t=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(n);if(!t)throw new Error(`Invalid URL: ${n}`);const r=((h=t.groups)==null?void 0:h.type)??"",s=((p=t.groups)==null?void 0:p.data)??"";let o=((g=t.groups)==null?void 0:g.hash)??"";const a=r.split(";");o=e?"":o;let c=!1;a[a.length-1]==="base64"&&(a.pop(),c=!0);const l=((b=a.shift())==null?void 0:b.toLowerCase())??"",f=[...a.map(m=>{let[E,_=""]=m.split("=").map(C=>C.trim());return E==="charset"&&(_=_.toLowerCase(),_===DATA_URL_DEFAULT_CHARSET)?"":`${E}${_?`=${_}`:""}`}).filter(Boolean)];return c&&f.push("base64"),(f.length>0||l&&l!==DATA_URL_DEFAULT_MIME_TYPE)&&f.unshift(l),`data:${f.join(";")},${c?s.trim():s}${o?`#${o}`:""}`};function normalizeUrl(n,e={}){if(e={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...e},typeof e.defaultProtocol=="string"&&!e.defaultProtocol.endsWith(":")&&(e.defaultProtocol=`${e.defaultProtocol}:`),n=n.trim(),/^data:/i.test(n))return normalizeDataURL(n,e);if(hasCustomProtocol(n))return n;const t=n.startsWith("//");!t&&/^\.*\//.test(n)||(n=n.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,e.defaultProtocol));const s=new URL(n);if(s.hostname=s.hostname.toLowerCase(),e.forceHttp&&e.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(e.forceHttp&&s.protocol==="https:"&&(s.protocol="http:"),e.forceHttps&&s.protocol==="http:"&&(s.protocol="https:"),e.stripAuthentication&&(s.username="",s.password=""),e.stripHash?s.hash="":e.stripTextFragment&&(s.hash=s.hash.replace(/#?:~:text.*?$/i,"")),s.pathname){const a=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let c=0,l="";for(;;){const f=a.exec(s.pathname);if(!f)break;const h=f[0],p=f.index,g=s.pathname.slice(c,p);l+=g.replace(/\/{2,}/g,"/"),l+=h,c=p+h.length}const u=s.pathname.slice(c,s.pathname.length);l+=u.replace(/\/{2,}/g,"/"),s.pathname=l}if(s.pathname)try{s.pathname=decodeURI(s.pathname)}catch{}if(e.removeDirectoryIndex===!0&&(e.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(e.removeDirectoryIndex)&&e.removeDirectoryIndex.length>0){let a=s.pathname.split("/");const c=a[a.length-1];testParameter(c,e.removeDirectoryIndex)&&(a=a.slice(0,-1),s.pathname=`${a.slice(1).join("/")}/`)}if(s.hostname&&(s.hostname=s.hostname.replace(/\.$/,""),e.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.hostname)&&(s.hostname=s.hostname.replace(/^www\./,""))),Array.isArray(e.removeQueryParameters))for(const a of[...s.searchParams.keys()])testParameter(a,e.removeQueryParameters)&&s.searchParams.delete(a);if(!Array.isArray(e.keepQueryParameters)&&e.removeQueryParameters===!0&&(s.search=""),Array.isArray(e.keepQueryParameters)&&e.keepQueryParameters.length>0)for(const a of[...s.searchParams.keys()])testParameter(a,e.keepQueryParameters)||s.searchParams.delete(a);if(e.sortQueryParameters){s.searchParams.sort();try{s.search=decodeURIComponent(s.search)}catch{}}e.removeTrailingSlash&&(s.pathname=s.pathname.replace(/\/$/,"")),e.removeExplicitPort&&s.port&&(s.port="");const o=n;return n=s.toString(),!e.removeSingleSlash&&s.pathname==="/"&&!o.endsWith("/")&&s.hash===""&&(n=n.replace(/\/$/,"")),(e.removeTrailingSlash||s.pathname==="/")&&s.hash===""&&e.removeSingleSlash&&(n=n.replace(/\/$/,"")),t&&!e.normalizeProtocol&&(n=n.replace(/^http:\/\//,"//")),e.stripProtocol&&(n=n.replace(/^(?:https?:)?\/\//,"")),n}var NDKRelayKeepalive=class{constructor(n=3e4,e){y(this,"lastActivity",Date.now());y(this,"timer");y(this,"timeout");y(this,"isRunning",!1);this.onSilenceDetected=e,this.timeout=n}recordActivity(){this.lastActivity=Date.now(),this.isRunning&&this.resetTimer()}start(){this.isRunning||(this.isRunning=!0,this.lastActivity=Date.now(),this.resetTimer())}stop(){this.isRunning=!1,this.timer&&(clearTimeout(this.timer),this.timer=void 0)}resetTimer(){this.timer&&clearTimeout(this.timer),this.timer=setTimeout(()=>{const n=Date.now()-this.lastActivity;if(n>=this.timeout)this.onSilenceDetected();else{const e=this.timeout-n;this.timer=setTimeout(()=>{this.onSilenceDetected()},e)}},this.timeout)}};async function probeRelayConnection(n){const e=`probe-${Math.random().toString(36).substring(7)}`;return new Promise(t=>{let r=!1;const s=setTimeout(()=>{r||(r=!0,n.send(["CLOSE",e]),t(!1))},5e3),o=()=>{r||(r=!0,clearTimeout(s),n.send(["CLOSE",e]),t(!0))};n.once("message",o),n.send(["REQ",e,{kinds:[99999],limit:0}])})}var MAX_RECONNECT_ATTEMPTS=5,FLAPPING_THRESHOLD_MS=1e3,NDKRelayConnectivity=class{constructor(n,e){y(this,"ndkRelay");y(this,"ws");y(this,"_status");y(this,"timeoutMs");y(this,"connectedAt");y(this,"_connectionStats",{attempts:0,success:0,durations:[]});y(this,"debug");y(this,"netDebug");y(this,"connectTimeout");y(this,"reconnectTimeout");y(this,"ndk");y(this,"openSubs",new Map);y(this,"openCountRequests",new Map);y(this,"openEventPublishes",new Map);y(this,"pendingAuthPublishes",new Map);y(this,"serial",0);y(this,"baseEoseTimeout",4400);y(this,"keepalive");y(this,"wsStateMonitor");y(this,"sleepDetector");y(this,"lastSleepCheck",Date.now());y(this,"lastMessageSent",Date.now());y(this,"wasIdle",!1);y(this,"updateConnectionStats",{connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}});this.ndkRelay=n,this._status=1;const t=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend(`connectivity${t}`),this.ndk=e,this.setupMonitoring()}setupMonitoring(){this.keepalive=new NDKRelayKeepalive(12e4,async()=>{this.debug("Relay silence detected, probing connection"),await probeRelayConnection({send:e=>this.send(JSON.stringify(e)),once:(e,t)=>{var s;const r=o=>{var a;try{const c=JSON.parse(o.data);(c[0]==="EOSE"||c[0]==="EVENT"||c[0]==="NOTICE")&&(t(),(a=this.ws)==null||a.removeEventListener("message",r))}catch{}};(s=this.ws)==null||s.addEventListener("message",r)}})||(this.debug("Probe failed, connection is stale"),this.handleStaleConnection())}),this.wsStateMonitor=setInterval(()=>{this._status===5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN)&&(this.debug("WebSocket died silently, reconnecting"),this.handleStaleConnection())},5e3),this.sleepDetector=setInterval(()=>{const n=Date.now(),e=n-this.lastSleepCheck;e>15e3&&(this.debug(`Detected possible sleep/wake (${e}ms gap)`),this.handlePossibleWake()),this.lastSleepCheck=n},1e4)}handleStaleConnection(){this._status=1,this.wasIdle=!0,this.onDisconnect()}handlePossibleWake(){this.debug("System wake detected, checking all connections"),this.wasIdle=!0,this._status>=5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN?this.handleStaleConnection():probeRelayConnection({send:n=>this.send(JSON.stringify(n)),once:(n,e)=>{var r;const t=s=>{var o;try{const a=JSON.parse(s.data);(a[0]==="EOSE"||a[0]==="EVENT"||a[0]==="NOTICE")&&(e(),(o=this.ws)==null||o.removeEventListener("message",t))}catch{}};(r=this.ws)==null||r.addEventListener("message",t)}}).then(n=>{n||this.handleStaleConnection()}))}resetReconnectionState(){this.wasIdle=!0,this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0)}async connect(n,e=!0){if(this.ws&&this.ws.readyState!==WebSocket.OPEN&&this.ws.readyState!==WebSocket.CONNECTING){this.debug("Cleaning up stale WebSocket connection");try{this.ws.close()}catch{}this.ws=void 0,this._status=1}if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),n??(n=this.timeoutMs),!this.timeoutMs&&n&&(this.timeoutMs=n),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(e),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(t){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,t),this._status=1,e?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2*24*60*60*1e3),t}}disconnect(){var n,e;this._status=0,(n=this.keepalive)==null||n.stop(),this.wsStateMonitor&&(clearInterval(this.wsStateMonitor),this.wsStateMonitor=void 0),this.sleepDetector&&(clearInterval(this.sleepDetector),this.sleepDetector=void 0);try{(e=this.ws)==null||e.close()}catch(t){this.debug("Failed to disconnect",t),this._status=1}}onConnectionError(n){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),n&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){var n,e;(n=this.netDebug)==null||n.call(this,"connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,(e=this.keepalive)==null||e.start(),this.wasIdle=!1,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){var n,e;(n=this.netDebug)==null||n.call(this,"disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),(e=this.keepalive)==null||e.stop(),this.clearPendingPublishes(new Error(`Relay ${this.ndkRelay.url} disconnected`)),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(n){var e,t;(e=this.netDebug)==null||e.call(this,n.data,this.ndkRelay,"recv"),(t=this.keepalive)==null||t.recordActivity();try{const r=JSON.parse(n.data),[s,o,...a]=r,c=this.ndkRelay.getProtocolHandler(s);if(c){c(this.ndkRelay,r);return}switch(s){case"EVENT":{const l=this.openSubs.get(o),u=r[2];if(!l){this.debug(`Received event for unknown subscription ${o}`);return}l.onevent(u);return}case"COUNT":{const l=r[2],u=this.openCountRequests.get(o);u&&(u.resolve(l.count),this.openCountRequests.delete(o));return}case"EOSE":{const l=this.openSubs.get(o);if(!l)return;l.oneose(o);return}case"OK":{const l=r[2],u=r[3],f=this.openEventPublishes.get(o),h=f==null?void 0:f.pop();if(!f||!h){this.debug("Received OK for unknown event publish",o);return}l?(h.resolve(u),this.pendingAuthPublishes.delete(o)):u&&(u.toLowerCase().includes("auth-required")||u.toLowerCase().includes("not authorized")||u.toLowerCase().includes("blocked: not authorized"))?this.pendingAuthPublishes.get(o)?(this.debug("Publish failed due to auth-required, will retry after auth",o),f.push(h),this.openEventPublishes.set(o,f)):h.reject(new Error(u)):(h.reject(new Error(u)),this.pendingAuthPublishes.delete(o)),f.length===0?this.openEventPublishes.delete(o):!l&&!(u!=null&&u.toLowerCase().includes("auth-required")||u!=null&&u.toLowerCase().includes("not authorized")||u!=null&&u.toLowerCase().includes("blocked: not authorized"))&&this.openEventPublishes.set(o,f);return}case"CLOSED":{const l=this.openSubs.get(o);if(!l)return;l.onclosed(r[2]);return}case"NOTICE":this.onNotice(r[1]);return;case"AUTH":{this.onAuthRequested(r[1]);return}}}catch(r){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${r.message}`,r==null?void 0:r.stack);return}}async onAuthRequested(n){var t,r,s;const e=this.ndkRelay.authPolicy??((t=this.ndk)==null?void 0:t.relayAuthDefaultPolicy);if(this.debug("Relay requested authentication",{havePolicy:!!e}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,e){if(this._status>=5){this._status=7;let o;try{o=await e(this.ndkRelay,n)}catch(a){this.debug("Authentication policy threw an error",a),o=!1}if(this.debug("Authentication policy returned",!!o),o instanceof NDKEvent||o===!0){o instanceof NDKEvent&&await this.auth(o);const a=async()=>{if(this._status>=5&&this._status<8){const c=new NDKEvent(this.ndk);c.kind=22242,c.tags=[["relay",this.ndkRelay.url],["challenge",n]],await c.sign(),this.auth(c).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful"),this.retryPendingAuthPublishes()}).catch(l=>{this._status=6,this.ndkRelay.emit("auth:failed",l),this.debug("Authentication failed",l),this.rejectPendingAuthPublishes(l)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};o===!0&&((r=this.ndk)!=null&&r.signer?a().catch(c=>{console.error("Error authenticating",c)}):(this.debug("No signer available for authentication localhost"),(s=this.ndk)==null||s.once("signer:ready",a))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",n)}onError(n){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,n)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const n=this._connectionStats.durations;if(n.length%3!==0)return!1;const t=n.reduce((a,c)=>a+c,0)/n.length,r=n.map(a=>(a-t)**2).reduce((a,c)=>a+c,0)/n.length;return Math.sqrt(r)<FLAPPING_THRESHOLD_MS}async onNotice(n){this.ndkRelay.emit("notice",n)}handleReconnection(n=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}let e;if(this.wasIdle){const t=[0,1e3,2e3,5e3,1e4,3e4];e=t[Math.min(n,t.length-1)],this.debug(`Using aggressive reconnect after idle, attempt ${n}, delay ${e}ms`)}else this.connectedAt?e=Math.max(0,6e4-(Date.now()-this.connectedAt)):(e=Math.min(1e3*2**n,3e4),this.debug(`Using standard backoff, attempt ${n}, delay ${e}ms`));this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(t=>{n<MAX_RECONNECT_ATTEMPTS?this.handleReconnection(n+1):(this.debug("Max reconnect attempts reached"),this.wasIdle=!1)})},e),this.ndkRelay.emit("delayed-connect",e),this.debug("Reconnecting in",e),this._connectionStats.nextReconnectAt=Date.now()+e}async send(n){var t,r,s,o,a;Date.now()-this.lastMessageSent>12e4&&(this.wasIdle=!0),this._status>=5&&((t=this.ws)==null?void 0:t.readyState)===WebSocket.OPEN?((r=this.ws)==null||r.send(n),(s=this.netDebug)==null||s.call(this,n,this.ndkRelay,"send"),this.lastMessageSent=Date.now()):(this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${n}`,this._status),this._status>=5&&((o=this.ws)==null?void 0:o.readyState)!==WebSocket.OPEN&&(this.debug(`Stale connection detected, WebSocket state: ${(a=this.ws)==null?void 0:a.readyState}`),this.handleStaleConnection()))}async auth(n){const e=new Promise((t,r)=>{const s=this.openEventPublishes.get(n.id)??[];s.push({resolve:t,reject:r}),this.openEventPublishes.set(n.id,s)});return this.send(`["AUTH",${JSON.stringify(n.rawEvent())}]`),e}clearPendingPublishes(n){this.rejectPendingAuthPublishes(n);for(const[e,t]of this.openEventPublishes.entries()){for(;t.length>0;){const r=t.shift();r&&r.reject(n)}this.openEventPublishes.delete(e)}}retryPendingAuthPublishes(){if(this.pendingAuthPublishes.size!==0){this.debug(`Retrying ${this.pendingAuthPublishes.size} pending publishes after auth`);for(const[n,e]of this.pendingAuthPublishes.entries())this.debug(`Retrying publish for event ${n}`),this.send(`["EVENT",${JSON.stringify(e)}]`);this.pendingAuthPublishes.clear()}}rejectPendingAuthPublishes(n){if(this.pendingAuthPublishes.size!==0){this.debug(`Rejecting ${this.pendingAuthPublishes.size} pending publishes due to auth failure`);for(const[e]of this.pendingAuthPublishes.entries()){const t=this.openEventPublishes.get(e);if(t&&t.length>0){const r=t.pop();r&&r.reject(new Error(`Authentication failed: ${n.message}`)),t.length===0&&this.openEventPublishes.delete(e)}}this.pendingAuthPublishes.clear()}}async publish(n){const e=new Promise((t,r)=>{const s=this.openEventPublishes.get(n.id)??[];s.length>0&&console.warn(`Duplicate event publishing detected, you are publishing event ${n.id} twice`),s.push({resolve:t,reject:r}),this.openEventPublishes.set(n.id,s)});return this.pendingAuthPublishes.set(n.id,n),this.send(`["EVENT",${JSON.stringify(n)}]`),e}async count(n,e){this.serial++;const t=(e==null?void 0:e.id)||`count:${this.serial}`,r=new Promise((s,o)=>{this.openCountRequests.set(t,{resolve:s,reject:o})});return this.send(`["COUNT","${t}",${JSON.stringify(n).substring(1)}`),r}close(n,e){this.send(`["CLOSE","${n}"]`);const t=this.openSubs.get(n);this.openSubs.delete(n),t&&t.onclose(e)}req(n){`${this.send(`["REQ","${n.subId}",${JSON.stringify(n.executeFilters).substring(1)}`)}`,this.openSubs.set(n.subId,n)}get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){var n;return this._status>=5&&((n=this.ws)==null?void 0:n.readyState)===WebSocket.OPEN}};async function fetchRelayInformation(n){const e=n.replace(/^wss:\/\//,"https://").replace(/^ws:\/\//,"http://"),t=await fetch(e,{headers:{Accept:"application/nostr+json"}});if(!t.ok)throw new Error(`Failed to fetch relay information: ${t.status} ${t.statusText}`);return await t.json()}var NDKRelayPublisher=class{constructor(n){y(this,"ndkRelay");y(this,"debug");this.ndkRelay=n,this.debug=n.debug.extend("publisher")}async publish(n,e=2500){let t;const r=()=>new Promise((f,h)=>{try{this.publishEvent(n).then(p=>{this.ndkRelay.emit("published",n),n.emit("relay:published",this.ndkRelay),f(!0)}).catch(h)}catch(p){h(p)}}),s=new Promise((f,h)=>{t=setTimeout(()=>{t=void 0,h(new Error(`Timeout: ${e}ms`))},e)}),o=()=>{r().then(f=>a(f)).catch(f=>c(f))};let a,c;const l=f=>{throw this.ndkRelay.debug("Publish failed",f,n.id),this.ndkRelay.emit("publish:failed",n,f),n.emit("relay:publish:failed",this.ndkRelay,f),f},u=()=>{t&&clearTimeout(t),this.ndkRelay.removeListener("connect",o)};return this.ndkRelay.status>=5?Promise.race([r(),s]).catch(l).finally(u):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((f,h)=>{a=f,c=h,this.ndkRelay.on("connect",o)}),s]).catch(l).finally(u))}async publishEvent(n){return this.ndkRelay.connectivity.publish(n.rawEvent())}};function filterFingerprint(n,e){const t=[];for(const s of n){const o=Object.entries(s||{}).map(([a,c])=>["since","until"].includes(a)?`${a}:${c}`:a).sort().join("-");t.push(o)}let r=e?"+":"";return r+=t.join("|"),r}function mergeFilters(n){const e=[],t={};return n.filter(r=>!!r.limit).forEach(r=>e.push(r)),n=n.filter(r=>!r.limit),n.length===0?e:(n.forEach(r=>{Object.entries(r).forEach(([s,o])=>{Array.isArray(o)?t[s]===void 0?t[s]=[...o]:t[s]=Array.from(new Set([...t[s],...o])):t[s]=o})}),[...e,t])}var MAX_ITEMS=3;function formatArray(n,e){const r=(e?n.slice(0,MAX_ITEMS).map(e):n.slice(0,MAX_ITEMS)).join(",");return n.length>MAX_ITEMS?`${r}+${n.length-MAX_ITEMS}`:r}function formatFilters(n){return n.map(e=>{var r,s,o;const t=[];(r=e.ids)!=null&&r.length&&t.push(`ids:[${formatArray(e.ids,a=>String(a).slice(0,8))}]`),(s=e.kinds)!=null&&s.length&&t.push(`kinds:[${formatArray(e.kinds)}]`),(o=e.authors)!=null&&o.length&&t.push(`authors:[${formatArray(e.authors,a=>String(a).slice(0,8))}]`),e.since&&t.push(`since:${e.since}`),e.until&&t.push(`until:${e.until}`),e.limit&&t.push(`limit:${e.limit}`),e.search&&t.push(`search:"${String(e.search).slice(0,20)}"`);for(const[a,c]of Object.entries(e))a.startsWith("#")&&Array.isArray(c)&&c.length>0&&t.push(`${a}:[${formatArray(c,l=>String(l).slice(0,8))}]`);return`{${t.join(" ")}}`}).join(", ")}var NDKRelaySubscription=class{constructor(n,e,t){y(this,"fingerprint");y(this,"items",new Map);y(this,"topSubManager");y(this,"debug");y(this,"status",0);y(this,"onClose");y(this,"relay");y(this,"eosed",!1);y(this,"executionTimer");y(this,"fireTime");y(this,"delayType");y(this,"executeFilters");y(this,"id",Math.random().toString(36).substring(7));y(this,"_subId");y(this,"subIdParts",new Set);y(this,"executeOnRelayReady",()=>{if(this.status===2){if(this.items.size===0){this.debug("No items to execute; this relay was probably too slow to respond and the caller gave up",{status:this.status,fingerprint:this.fingerprint,id:this.id,subId:this.subId}),this.cleanup();return}this.debug("Executing on relay ready",{status:this.status,fingerprint:this.fingerprint,itemsSize:this.items.size,filters:formatFilters(this.compileFilters())}),this.status=1,this.execute()}});y(this,"reExecuteAfterAuth",(()=>{const n=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:n}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s 👉 %s",n,this.subId)}).bind(this));this.relay=n,this.topSubManager=t,this.debug=n.debug.extend(`sub[${this.id}]`),this.fingerprint=e||Math.random().toString(36).substring(7)}get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}addSubIdPart(n){this.subIdParts.add(n)}addItem(n,e){if(this.debug("Adding item",{filters:formatFilters(e),internalId:n.internalId,status:this.status,fingerprint:this.fingerprint,id:this.subId,itemsSize:this.items.size}),!this.items.has(n.internalId))switch(n.on("close",this.removeItem.bind(this,n)),this.items.set(n.internalId,{subscription:n,filters:e}),this.status!==3&&n.subId&&(!this._subId||this._subId.length<25)&&(this.status===0||this.status===1)&&this.addSubIdPart(n.subId),this.status){case 0:this.evaluateExecutionPlan(n);break;case 3:break;case 1:this.evaluateExecutionPlan(n);break;case 4:throw this.debug("Subscription is closed, cannot add new items",{filters:formatFilters(e),subId:n.subId,internalId:n.internalId}),new Error("Cannot add new items to a closed subscription")}}removeItem(n){if(this.items.delete(n.internalId),this.items.size===0){if(!this.eosed)return;this.close(),this.cleanup()}}close(){if(this.status===4)return;const n=this.status;if(this.status=4,n===3)try{this.relay.close(this.subId)}catch(e){this.debug("Error closing subscription",e,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:n,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(n){if(!n.isGroupable()){this.status=1,this.execute();return}if(n.filters.find(r=>!!r.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const e=n.groupableDelay,t=n.groupableDelayType;if(!e)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(e,t);else{const r=this.delayType,s=this.fireTime-Date.now();if(r==="at-least"&&t==="at-least")s<e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,t));else if(r==="at-least"&&t==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,t));else if(r==="at-most"&&t==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,t));else if(r==="at-most"&&t==="at-least")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,t));else throw new Error(`Unknown delay type combination ${r} ${t}`)}}schedule(n,e){this.status=1;const t=Date.now();this.fireTime=t+n,this.delayType=e;const r=setTimeout(this.execute.bind(this),n);e==="at-least"&&(this.executionTimer=r)}finalizeSubId(){if(this.subIdParts.size>0){let e=Array.from(this.subIdParts).map(t=>t.substring(0,10)).join("-");e.length>20&&(e=e.substring(0,20)),this._subId=e}else this._subId=this.fingerprint.slice(0,15);this._subId+=`-${Math.random().toString(36).substring(2,7)}`}execute(){if(this.status===1){if(!this.relay.connected){this.status=2,this.debug("Waiting for relay to be ready",{status:this.status,id:this.subId,fingerprint:this.fingerprint,itemsSize:this.items.size}),this.relay.once("ready",this.executeOnRelayReady);return}this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth),this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(n){this.topSubManager.dispatchEvent(n,this.relay)}oneose(n){if(this.eosed=!0,n!==this.subId){this.debug("Received EOSE for an abandoned subscription",n,this.subId),this.relay.close(n);return}this.items.size===0&&this.close();for(const{subscription:e}of this.items.values())e.eoseReceived(this.relay),e.closeOnEose&&(this.debug("Removing item because of EOSE",{filters:formatFilters(e.filters),internalId:e.internalId,status:this.status,fingerprint:this.fingerprint,itemsSize:this.items.size}),this.removeItem(e))}onclose(n){this.status=4}onclosed(n){if(n)for(const{subscription:e}of this.items.values())e.closedReceived(this.relay,n)}compileFilters(){const n=[],e=Array.from(this.items.values()).map(r=>r.filters);if(!e[0])return this.debug("👀 No filters to merge",{itemsSize:this.items.size}),[];const t=e[0].length;for(let r=0;r<t;r++){const s=e.map(a=>a[r]),o=mergeFilters(s);n.push(...o)}return n}},NDKRelaySubscriptionManager=class{constructor(n,e){y(this,"relay");y(this,"subscriptions");y(this,"generalSubManager");this.relay=n,this.subscriptions=new Map,this.generalSubManager=e}addSubscription(n,e){let t;if(!n.isGroupable())t=this.createSubscription(n,e);else{const r=filterFingerprint(e,n.closeOnEose);r&&(t=(this.subscriptions.get(r)||[]).find(o=>o.status<3)),t??(t=this.createSubscription(n,e,r))}t.addItem(n,e)}createSubscription(n,e,t){const r=new NDKRelaySubscription(this.relay,t||null,this.generalSubManager);r.onClose=this.onRelaySubscriptionClose.bind(this);const s=this.subscriptions.get(r.fingerprint)??[];return this.subscriptions.set(r.fingerprint,[...s,r]),r}onRelaySubscriptionClose(n){let e=this.subscriptions.get(n.fingerprint)??[];e?e.length===1?this.subscriptions.delete(n.fingerprint):(e=e.filter(t=>t.id!==n.id),this.subscriptions.set(n.fingerprint,e)):console.warn("Unexpectedly did not find a subscription with fingerprint",n.fingerprint)}},$e,NDKRelay=($e=class extends lib$1.EventEmitter{constructor(t,r,s){super();y(this,"url");y(this,"scores");y(this,"connectivity");y(this,"subs");y(this,"publisher");y(this,"authPolicy");y(this,"protocolHandlers",new Map);y(this,"_relayInfo");y(this,"lowestValidationRatio");y(this,"targetValidationRatio");y(this,"validationRatioFn");y(this,"validatedEventCount",0);y(this,"nonValidatedEventCount",0);y(this,"trusted",!1);y(this,"complaining",!1);y(this,"debug");y(this,"req");y(this,"close");this.url=normalizeRelayUrl(t),this.scores=new Map,this.debug=createDebug5(`ndk:relay:${t}`),this.connectivity=new NDKRelayConnectivity(this,s),this.connectivity.netDebug=s==null?void 0:s.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager(this,s.subManager),this.publisher=new NDKRelayPublisher(this),this.authPolicy=r,this.targetValidationRatio=s==null?void 0:s.initialValidationRatio,this.lowestValidationRatio=s==null?void 0:s.lowestValidationRatio,this.validationRatioFn=((s==null?void 0:s.validationRatioFn)??$e.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),s||console.trace("relay created without ndk")}updateValidationRatio(){if(this.validationRatioFn&&this.validatedEventCount>0){const t=this.validationRatioFn(this,this.validatedEventCount,this.nonValidatedEventCount);this.targetValidationRatio=t}setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(t,r=!0){return this.connectivity.connect(t,r)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(t,r){this.subs.addSubscription(t,r)}async publish(t,r=2500){return this.publisher.publish(t,r)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0||this.targetValidationRatio>=1?!0:Math.random()<this.targetValidationRatio}get connected(){return this.connectivity.connected}registerProtocolHandler(t,r){this.protocolHandlers.set(t,r)}unregisterProtocolHandler(t){this.protocolHandlers.delete(t)}getProtocolHandler(t){return this.protocolHandlers.get(t)}async fetchInfo(t=!1){var o,a;const s=this.connectivity.ndk;if(!t&&((o=s==null?void 0:s.cacheAdapter)!=null&&o.getRelayStatus)){const c=await s.cacheAdapter.getRelayStatus(this.url);if(c!=null&&c.nip11&&Date.now()-c.nip11.fetchedAt<864e5)return this._relayInfo=c.nip11.data,c.nip11.data}return!t&&this._relayInfo?this._relayInfo:(this._relayInfo=await fetchRelayInformation(this.url),(a=s==null?void 0:s.cacheAdapter)!=null&&a.updateRelayStatus&&await s.cacheAdapter.updateRelayStatus(this.url,{nip11:{data:this._relayInfo,fetchedAt:Date.now()}}),this._relayInfo)}get info(){return this._relayInfo}},y($e,"defaultValidationRatioUpdateFn",(t,r,s)=>{if(t.lowestValidationRatio===void 0||t.targetValidationRatio===void 0)return 1;let o=t.validationRatio;if(t.validationRatio>t.targetValidationRatio){const a=r/100;o=Math.max(t.lowestValidationRatio,t.validationRatio-a)}return o<t.validationRatio?o:t.validationRatio}),$e),NDKPublishError=class extends Error{constructor(e,t,r,s){super(e);y(this,"errors");y(this,"publishedToRelays");y(this,"intendedRelaySet");this.errors=t,this.publishedToRelays=r,this.intendedRelaySet=s}get relayErrors(){const e=[];for(const[t,r]of this.errors)e.push(`${t.url}: ${r}`);return e.join(`
`)}},NDKRelaySet=class Ke{constructor(e,t,r){y(this,"relays");y(this,"debug");y(this,"ndk");y(this,"pool");this.relays=e,this.ndk=t,this.pool=r??t.pool,this.debug=t.debug.extend("relayset")}addRelay(e){this.relays.add(e)}get relayUrls(){return Array.from(this.relays).map(e=>e.url)}static fromRelayUrls(e,t,r=!0,s){if(s=s??t.pool,!s)throw new Error("No pool provided");const o=new Set;for(const a of e){const c=s.relays.get(normalizeRelayUrl(a));if(c)c.status<5&&r&&c.connect(),o.add(c);else{const l=new NDKRelay(normalizeRelayUrl(a),t==null?void 0:t.relayAuthDefaultPolicy,t);s.useTemporaryRelay(l,void 0,`requested from fromRelayUrls ${e}`),o.add(l)}}return new Ke(new Set(o),t,s)}async publish(e,t,r=1){var l;const s=new Set,o=new Map,a=e.isEphemeral();e.publishStatus="pending";const c=u=>{s.add(u)};e.on("relay:published",c);try{const u=Array.from(this.relays).map(f=>new Promise(h=>{const p=t?setTimeout(()=>{s.has(f)||(o.set(f,new Error(`Publish timeout after ${t}ms`)),h(!1))},t):null;f.publish(e,t).then(g=>{p&&clearTimeout(p),g?(s.add(f),h(!0)):h(!1)}).catch(g=>{p&&clearTimeout(p),a||o.set(f,g),h(!1)})}));if(await Promise.all(u),s.size<r){if(!a){const f=new NDKPublishError("Not enough relays received the event ("+s.size+" published, "+r+" required)",o,s,this);throw e.publishStatus="error",e.publishError=f,(l=this.ndk)==null||l.emit("event:publish-failed",e,f,this.relayUrls),f}}else e.publishStatus="success",e.emit("published",{relaySet:this,publishedToRelays:s});return s}finally{e.off("relay:published",c)}}get size(){return this.relays.size}},d=createDebug5("ndk:outbox:calculate");async function calculateRelaySetFromEvent(n,e,t){var c,l;const r=new Set,s=await getWriteRelaysFor(n,e.pubkey);s&&s.forEach(u=>{var h;const f=(h=n.pool)==null?void 0:h.getRelay(u);f&&r.add(f)});let o=e.tags.filter(u=>["a","e"].includes(u[0])).map(u=>u[2]).filter(u=>u==null?void 0:u.startsWith("wss://")).filter(u=>{try{return new URL(u),!0}catch{return!1}}).map(u=>normalizeRelayUrl(u));o=Array.from(new Set(o)).slice(0,5),o.forEach(u=>{var h;const f=(h=n.pool)==null?void 0:h.getRelay(u,!0,!0);f&&(d("Adding relay hint %s",u),r.add(f))});const a=e.getMatchingTags("p").map(u=>u[1]);if(a.length<5?Array.from(chooseRelayCombinationForPubkeys(n,a,"read",{preferredRelays:new Set(s)}).keys()).forEach(f=>{var p;const h=(p=n.pool)==null?void 0:p.getRelay(f,!1,!0);h&&(d("Adding p-tagged relay %s",f),r.add(h))}):d("Too many p-tags to consider %d",a.length),(c=n.pool)==null||c.permanentAndConnectedRelays().forEach(u=>r.add(u)),t&&r.size<t){const u=(l=n.explicitRelayUrls)==null?void 0:l.filter(f=>!Array.from(r).some(h=>h.url===f)).slice(0,t-r.size);u==null||u.forEach(f=>{var p;const h=(p=n.pool)==null?void 0:p.getRelay(f,!1,!0);h&&(d("Adding explicit relay %s",f),r.add(h))})}return new NDKRelaySet(r,n)}function calculateRelaySetsFromFilter(n,e,t,r){const s=new Map,o=new Set;if(e.forEach(a=>{a.authors&&a.authors.forEach(c=>o.add(c))}),o.size>0){const a=getRelaysForFilterWithAuthors(n,Array.from(o),r);for(const c of a.keys())s.set(c,[]);for(const c of e)if(c.authors)for(const[l,u]of a.entries()){const f=c.authors.filter(h=>u.includes(h));s.set(l,[...s.get(l),{...c,authors:f}])}else for(const l of a.keys())s.set(l,[...s.get(l),c])}else n.explicitRelayUrls&&n.explicitRelayUrls.forEach(a=>{s.set(a,e)});return s.size===0&&t.permanentAndConnectedRelays().slice(0,5).forEach(a=>{s.set(a.url,e)}),s}function calculateRelaySetsFromFilters(n,e,t,r){return calculateRelaySetsFromFilter(n,e,t,r)}function isValidHex64(n){if(typeof n!="string"||n.length!==64)return!1;for(let e=0;e<64;e++){const t=n.charCodeAt(e);if(!(t>=48&&t<=57||t>=97&&t<=102||t>=65&&t<=70))return!1}return!0}function isValidPubkey(n){return isValidHex64(n)}function isValidNip05(n){if(typeof n!="string")return!1;for(let e=0;e<n.length;e++)if(n.charCodeAt(e)===46)return!0;return!1}function mergeTags(n,e){const t=new Map,r=a=>a.join(","),s=(a,c)=>a.every((l,u)=>l===c[u]),o=a=>{for(const[c,l]of t)if(s(l,a)||s(a,l)){a.length>=l.length&&t.set(c,a);return}t.set(r(a),a)};return n.concat(e).forEach(o),Array.from(t.values())}var hashtagRegex=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g");function generateHashtags(n){const e=n.match(hashtagRegex),t=new Set,r=new Set;if(e)for(const s of e)t.has(s.slice(1))||(r.add(s.slice(1)),t.add(s.slice(1)));return Array.from(r)}async function generateContentTags(n,e=[],t,r){var c,l;if(t!=null&&t.skipContentTagging)return{content:n,tags:e};const s=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,o=[],a=u=>{e.find(f=>["q",u[0]].includes(f[0])&&f[1]===u[1])||e.push(u)};if(n=n.replace(s,u=>{var f;try{const h=u.split(/(@|nostr:)/)[2],{type:p,data:g}=nip19_exports$1.decode(h);let b;if(t!=null&&t.filters){const m=!t.filters.includeTypes||t.filters.includeTypes.includes(p),E=(f=t.filters.excludeTypes)==null?void 0:f.includes(p);if(!m||E)return u}switch(p){case"npub":(t==null?void 0:t.pTags)!==!1&&(b=["p",g]);break;case"nprofile":(t==null?void 0:t.pTags)!==!1&&(b=["p",g.pubkey]);break;case"note":o.push(new Promise(async m=>{const E=await maybeGetEventRelayUrl(h);a(["q",g,E]),m()}));break;case"nevent":o.push(new Promise(async m=>{const{id:E,author:_}=g;let{relays:C}=g;(!C||C.length===0)&&(C=[await maybeGetEventRelayUrl(h)]),a(["q",E,C[0]]),_&&(t==null?void 0:t.pTags)!==!1&&(t==null?void 0:t.pTagOnQTags)!==!1&&a(["p",_]),m()}));break;case"naddr":o.push(new Promise(async m=>{const E=[g.kind,g.pubkey,g.identifier].join(":");let _=g.relays??[];_.length===0&&(_=[await maybeGetEventRelayUrl(h)]),a(["q",E,_[0]]),(t==null?void 0:t.pTags)!==!1&&(t==null?void 0:t.pTagOnQTags)!==!1&&(t==null?void 0:t.pTagOnATags)!==!1&&a(["p",g.pubkey]),m()}));break;default:return u}return b&&a(b),`nostr:${h}`}catch{return u}}),await Promise.all(o),!((l=(c=t==null?void 0:t.filters)==null?void 0:c.excludeTypes)!=null&&l.includes("hashtag"))){const u=generateHashtags(n).map(f=>["t",f]);e=mergeTags(e,u)}if((t==null?void 0:t.pTags)!==!1&&(t!=null&&t.copyPTagsFromTarget)&&r){const u=r.getMatchingTags("p");for(const f of u)!f[1]||!isValidPubkey(f[1])||e.find(h=>h[0]==="p"&&h[1]===f[1])||e.push(f)}return{content:n,tags:e}}async function maybeGetEventRelayUrl(n){return""}async function encrypt(n,e,t="nip44"){let r;if(!this.ndk)throw new Error("No NDK instance found!");let s=e;if(s||(this.ndk.assertSigner(),s=this.ndk.signer),!s)throw new Error("no NDK signer");const o=n||(()=>{const a=this.getMatchingTags("p");if(a.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");return this.ndk.getUser({pubkey:a[0][1]})})();if(t==="nip44"&&await isEncryptionEnabled(s,"nip44")&&(r=await s.encrypt(o,this.content,"nip44")),(!r||t==="nip04")&&await isEncryptionEnabled(s,"nip04")&&(r=await s.encrypt(o,this.content,"nip04")),!r)throw new Error("Failed to encrypt event.");this.content=r}async function decrypt(n,e,t){var c,l,u,f;if((l=(c=this.ndk)==null?void 0:c.cacheAdapter)!=null&&l.getDecryptedEvent){const h=await this.ndk.cacheAdapter.getDecryptedEvent(this.id);if(h){this.content=h.content;return}}let r;if(!this.ndk)throw new Error("No NDK instance found!");let s=e;if(s||(this.ndk.assertSigner(),s=this.ndk.signer),!s)throw new Error("no NDK signer");const o=n||this.author;if(!o)throw new Error("No sender provided and no author available");const a=t||(this.content.match(/\\?iv=/)?"nip04":"nip44");if((a==="nip04"||this.kind===4)&&await isEncryptionEnabled(s,"nip04")&&this.content.search("\\?iv=")&&(r=await s.decrypt(o,this.content,"nip04")),!r&&a==="nip44"&&await isEncryptionEnabled(s,"nip44")&&(r=await s.decrypt(o,this.content,"nip44")),!r)throw new Error("Failed to decrypt event.");this.content=r,(f=(u=this.ndk)==null?void 0:u.cacheAdapter)!=null&&f.addDecryptedEvent&&this.ndk.cacheAdapter.addDecryptedEvent(this.id,this)}async function isEncryptionEnabled(n,e){return n.encryptionEnabled?e?!!await n.encryptionEnabled(e):!0:!1}function eventHasETagMarkers(n){for(const e of n.tags)if(e[0]==="e"&&(e[3]??"").length>0)return!0;return!1}function getRootTag(n,e){e??(e=n.tagType());const t=n.tags.find(isTagRootTag);if(!t){if(eventHasETagMarkers(n))return;const r=n.getMatchingTags(e);if(r.length<3)return r[0]}return t}var nip22RootTags=new Set(["A","E","I"]),nip22ReplyTags=new Set(["a","e","i"]);function getReplyTag(n,e){if(n.kind===1111){let s;for(const o of n.tags)if(nip22RootTags.has(o[0]))s=o;else if(nip22ReplyTags.has(o[0])){s=o;break}return s}e??(e=n.tagType());let t=!1,r;for(const s of n.tags)if(s[0]===e){if((s[3]??"").length>0&&(t=!0),t&&s[3]==="reply")return s;t&&s[3]==="root"&&(r=s),t||(r=s)}return r}function isTagRootTag(n){return n[0]==="E"||n[3]==="root"}async function fetchTaggedEvent(n,e){if(!this.ndk)throw new Error("NDK instance not found");const t=this.getMatchingTags(n,e);if(t.length===0)return;const[r,s,o]=t[0],a=o!==""?this.ndk.pool.getRelay(o):void 0;return await this.ndk.fetchEvent(s,{},a)}async function fetchRootEvent(n){if(!this.ndk)throw new Error("NDK instance not found");const e=getRootTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,n)}async function fetchReplyEvent(n){if(!this.ndk)throw new Error("NDK instance not found");const e=getReplyTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,n)}function isReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_RELAY_COUNT=2;function encode(n=DEFAULT_RELAY_COUNT){let e=[];return this.onRelays.length>0?e=this.onRelays.map(t=>t.url):this.relay&&(e=[this.relay.url]),e.length>n&&(e=e.slice(0,n)),this.isParamReplaceable()?nip19_exports$1.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:e}):e.length>0?nip19_exports$1.neventEncode({id:this.tagId(),relays:e,author:this.pubkey}):nip19_exports$1.noteEncode(this.tagId())}async function repost(n=!0,e){if(!e&&n){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),e=this.ndk.signer}const t=new NDKEvent(this.ndk,{kind:getKind(this)});return this.isProtected||(t.content=JSON.stringify(this.rawEvent())),t.tag(this),this.kind!==1&&t.tags.push(["k",`${this.kind}`]),e&&await t.sign(e),n&&await t.publish(),t}function getKind(n){return n.kind===1?6:16}function getEventDetails(n){return"inspect"in n&&typeof n.inspect=="string"?n.inspect:JSON.stringify(n)}function validateForSerialization(n){if(typeof n.kind!="number")throw new Error(`Can't serialize event with invalid properties: kind (must be number, got ${typeof n.kind}). Event: ${getEventDetails(n)}`);if(typeof n.content!="string")throw new Error(`Can't serialize event with invalid properties: content (must be string, got ${typeof n.content}). Event: ${getEventDetails(n)}`);if(typeof n.created_at!="number")throw new Error(`Can't serialize event with invalid properties: created_at (must be number, got ${typeof n.created_at}). Event: ${getEventDetails(n)}`);if(typeof n.pubkey!="string")throw new Error(`Can't serialize event with invalid properties: pubkey (must be string, got ${typeof n.pubkey}). Event: ${getEventDetails(n)}`);if(!Array.isArray(n.tags))throw new Error(`Can't serialize event with invalid properties: tags (must be array, got ${typeof n.tags}). Event: ${getEventDetails(n)}`);for(let e=0;e<n.tags.length;e++){const t=n.tags[e];if(!Array.isArray(t))throw new Error(`Can't serialize event with invalid properties: tags[${e}] (must be array, got ${typeof t}). Event: ${getEventDetails(n)}`);for(let r=0;r<t.length;r++)if(typeof t[r]!="string")throw new Error(`Can't serialize event with invalid properties: tags[${e}][${r}] (must be string, got ${typeof t[r]}). Event: ${getEventDetails(n)}`)}}function serialize(n=!1,e=!1){validateForSerialization(this);const t=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return n&&t.push(this.sig),e&&t.push(this.id),JSON.stringify(t)}function deserialize(n){const e=JSON.parse(n),t={pubkey:e[1],created_at:e[2],kind:e[3],tags:e[4],content:e[5]};if(e.length>=7){const r=e[6],s=e[7];r&&r.length===128?(t.sig=r,s&&s.length===64&&(t.id=s)):r&&r.length===64&&(t.id=r,s&&s.length===128&&(t.sig=s))}return t}var worker,processingQueue={};function signatureVerificationInit(n){worker=n,worker.onmessage=e=>{if(!Array.isArray(e.data)||e.data.length!==2){console.error("[NDK] ❌ Signature verification worker received incompatible message format.",`

📋 Expected format: [eventId, boolean]`,`
📦 Received:`,e.data,`

🔍 This likely means:`,`
  1. You have a STALE worker.js file that needs updating`,`
  2. Version mismatch between @nostr-dev-kit/ndk and deployed worker`,`
  3. Wrong worker is being used for signature verification`,`

✅ Solution: Update your worker files:`,`
  cp node_modules/@nostr-dev-kit/ndk/dist/workers/sig-verification.js public/`,`
  cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/worker.js public/`,`

💡 Or use Vite/bundler imports instead of static files:`,`
  import SigWorker from "@nostr-dev-kit/ndk/workers/sig-verification?worker"`);return}const[t,r]=e.data,s=processingQueue[t];if(!s){console.error("No record found for event",t);return}delete processingQueue[t];for(const o of s.resolves)o(r)}}async function verifySignatureAsync(n,e,t){const r=n.ndk,s=Date.now();let o;return r.signatureVerificationFunction?o=await r.signatureVerificationFunction(n):o=await new Promise(a=>{const c=n.serialize();let l=!1;processingQueue[n.id]||(processingQueue[n.id]={event:n,resolves:[],relay:t},l=!0),processingQueue[n.id].resolves.push(a),l&&(worker==null||worker.postMessage({serialized:c,id:n.id,sig:n.sig,pubkey:n.pubkey}))}),r.signatureVerificationTimeMs+=Date.now()-s,o}var PUBKEY_REGEX=/^[a-f0-9]{64}$/;function validate(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX)||!Array.isArray(this.tags))return!1;for(let n=0;n<this.tags.length;n++){const e=this.tags[n];if(!Array.isArray(e))return!1;for(let t=0;t<e.length;t++)if(typeof e[t]=="object")return!1}return!0}var verifiedSignatures=new dist.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature(n){var t;if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const e=verifiedSignatures.get(this.id);if(e!==null)return this.signatureVerified=!!e,this.signatureVerified;try{if((t=this.ndk)!=null&&t.asyncSigVerification){const r=this.relay;verifySignatureAsync(this,n,r).then(s=>{var o,a;n&&(this.signatureVerified=s,s&&verifiedSignatures.set(this.id,this.sig)),s?r&&r.addValidatedEvent():(r?(o=this.ndk)==null||o.reportInvalidSignature(this,r):(a=this.ndk)==null||a.reportInvalidSignature(this),verifiedSignatures.set(this.id,!1))}).catch(s=>{console.error("signature verification error",this.id,s)})}else{const r=sha256(new TextEncoder().encode(this.serialize())),s=schnorr.verify(this.sig,r,this.pubkey);return s?verifiedSignatures.set(this.id,this.sig):verifiedSignatures.set(this.id,!1),this.signatureVerified=s,s}}catch{return this.signatureVerified=!1,!1}}function getEventHash(){return getEventHashFromSerializedEvent(this.serialize())}function getEventHashFromSerializedEvent(n){const e=sha256(new TextEncoder().encode(n));return bytesToHex(e)}var skipClientTagOnKinds=new Set([0,4,1059,13,3,9734,5]),NDKEvent=class _e extends lib$1.EventEmitter{constructor(t,r){var s;super();y(this,"ndk");y(this,"created_at");y(this,"content","");y(this,"tags",[]);y(this,"kind");y(this,"id","");y(this,"sig");y(this,"pubkey","");y(this,"signatureVerified");y(this,"_author");y(this,"relay");y(this,"publishStatus","success");y(this,"publishError");y(this,"serialize",serialize.bind(this));y(this,"getEventHash",getEventHash.bind(this));y(this,"validate",validate.bind(this));y(this,"verifySignature",verifySignature.bind(this));y(this,"isReplaceable",isReplaceable.bind(this));y(this,"isEphemeral",isEphemeral.bind(this));y(this,"isDvm",()=>this.kind&&this.kind>=5e3&&this.kind<=7e3);y(this,"isParamReplaceable",isParamReplaceable.bind(this));y(this,"encode",encode.bind(this));y(this,"encrypt",encrypt.bind(this));y(this,"decrypt",decrypt.bind(this));y(this,"fetchTaggedEvent",fetchTaggedEvent.bind(this));y(this,"fetchRootEvent",fetchRootEvent.bind(this));y(this,"fetchReplyEvent",fetchReplyEvent.bind(this));y(this,"repost",repost.bind(this));this.ndk=t,this.created_at=r==null?void 0:r.created_at,this.content=(r==null?void 0:r.content)||"",this.tags=(r==null?void 0:r.tags)||[],this.id=(r==null?void 0:r.id)||"",this.sig=r==null?void 0:r.sig,this.pubkey=(r==null?void 0:r.pubkey)||"",this.kind=r==null?void 0:r.kind,r instanceof _e&&(this.relay&&(this.relay=r.relay,(s=this.ndk)==null||s.subManager.seenEvent(r.id,this.relay)),this.publishStatus=r.publishStatus,this.publishError=r.publishError)}get onRelays(){let t=[];return this.ndk?t=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&t.push(this.relay),t}static deserialize(t,r){return new _e(t,deserialize(r))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(t){var r;this.pubkey=t.pubkey,this._author=t,(r=this._author).ndk??(r.ndk=this.ndk)}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const t=this.ndk.getUser({pubkey:this.pubkey});return this._author=t,t}tagExternal(t,r,s){const o=["i"],a=["k"];switch(r){case"url":{const c=new URL(t);c.hash="",o.push(c.toString()),a.push(`${c.protocol}//${c.host}`);break}case"hashtag":o.push(`#${t.toLowerCase()}`),a.push("#");break;case"geohash":o.push(`geo:${t.toLowerCase()}`),a.push("geo");break;case"isbn":o.push(`isbn:${t.replace(/-/g,"")}`),a.push("isbn");break;case"podcast:guid":o.push(`podcast:guid:${t}`),a.push("podcast:guid");break;case"podcast:item:guid":o.push(`podcast:item:guid:${t}`),a.push("podcast:item:guid");break;case"podcast:publisher:guid":o.push(`podcast:publisher:guid:${t}`),a.push("podcast:publisher:guid");break;case"isan":o.push(`isan:${t.split("-").slice(0,4).join("-")}`),a.push("isan");break;case"doi":o.push(`doi:${t.toLowerCase()}`),a.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${r}`)}s&&o.push(s),this.tags.push(o),this.tags.push(a)}tag(t,r,s,o,a){let c=[];if(t.fetchProfile!==void 0){if(o??(o="p"),o==="p"&&(a==null?void 0:a.pTags)===!1)return;const u=[o,t.pubkey];r&&u.push("",r),c.push(u)}else if(t instanceof _e){const u=t;if(s??(s=(u==null?void 0:u.pubkey)===this.pubkey),c=u.referenceTags(r,s,o,a),(a==null?void 0:a.pTags)!==!1)for(const f of u.getMatchingTags("p"))!f[1]||!isValidPubkey(f[1])||f[1]!==this.pubkey&&(this.tags.find(h=>h[0]==="p"&&h[1]===f[1])||this.tags.push(["p",f[1]]))}else if(Array.isArray(t))c=[t];else throw new Error("Invalid argument",t);this.tags=mergeTags(this.tags,c)}async toNostrEvent(t,r){var a,c;if(!t&&this.pubkey===""){const l=await((c=(a=this.ndk)==null?void 0:a.signer)==null?void 0:c.user());this.pubkey=(l==null?void 0:l.pubkey)||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:s,tags:o}=await this.generateTags(r);this.content=s||"",this.tags=o;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}getMatchingTags(t,r){const s=this.tags.filter(o=>o[0]===t);return r===void 0?s:s.filter(o=>o[3]===r)}hasTag(t,r){return this.tags.some(s=>s[0]===t&&(!r||s[3]===r))}tagValue(t,r){const s=this.getMatchingTags(t,r);if(s.length!==0)return s[0][1]}get alt(){return this.tagValue("alt")}set alt(t){this.removeTag("alt"),t&&this.tags.push(["alt",t])}get dTag(){return this.tagValue("d")}set dTag(t){this.removeTag("d"),t&&this.tags.push(["d",t])}removeTag(t,r){const s=Array.isArray(t)?t:[t];this.tags=this.tags.filter(o=>{const a=s.includes(o[0]),c=r?o[3]===r:!0;return!(a&&c)})}replaceTag(t){this.removeTag(t[0]),this.tags.push(t)}async sign(t,r){var o,a,c,l,u;(c=(a=(o=this.ndk)==null?void 0:o.aiGuardrails)==null?void 0:a.event)==null||c.signing(this),t?this.author=await t.user():((l=this.ndk)==null||l.assertSigner(),t=(u=this.ndk)==null?void 0:u.signer);const s=await this.toNostrEvent(void 0,r);return this.sig=await t.sign(s),this.sig}async publishReplaceable(t,r,s){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(t,r,s)}async publish(t,r,s,o){var l,u,f,h,p;if(s||(s=1),this.sig||await this.sign(void 0,o),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");if((u=(l=this.ndk.aiGuardrails)==null?void 0:l.event)==null||u.publishing(this),(!t||t.size===0)&&(t=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent(this.ndk,this,s)),this.kind===5&&((f=this.ndk.cacheAdapter)!=null&&f.deleteEventIds)){const g=this.getMatchingTags("e").map(b=>b[1]);this.ndk.cacheAdapter.deleteEventIds(g)}const a=this.rawEvent();if((h=this.ndk.cacheAdapter)!=null&&h.addUnpublishedEvent&&shouldTrackUnpublishedEvent(this))try{this.ndk.cacheAdapter.addUnpublishedEvent(this,t.relayUrls)}catch(g){console.error("Error adding unpublished event to cache",g)}this.kind===5&&((p=this.ndk.cacheAdapter)!=null&&p.deleteEventIds)&&this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map(g=>g[1])),this.ndk.subManager.dispatchEvent(a,void 0,!0);const c=await t.publish(this,r,s);return c.forEach(g=>{var b;return(b=this.ndk)==null?void 0:b.subManager.seenEvent(this.id,g)}),c}async generateTags(t){var a,c,l;let r=[];const s=await generateContentTags(this.content,this.tags,t,this),o=s.content;if(r=s.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const f=this.tagValue("title");let p=[...Array(f?6:16)].map(()=>Math.random().toString(36)[2]).join("");f&&f.length>0&&(p=`${f.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")}-${p}`),r.push(["d",p])}if(this.shouldAddClientTag){const u=["client",((a=this.ndk)==null?void 0:a.clientName)??""];(c=this.ndk)!=null&&c.clientNip89&&u.push((l=this.ndk)==null?void 0:l.clientNip89),r.push(u)}else this.shouldStripClientTag&&(r=r.filter(u=>u[0]!=="client"));return{content:o||"",tags:r}}get shouldAddClientTag(){var t,r;return!(!((t=this.ndk)!=null&&t.clientName)&&!((r=this.ndk)!=null&&r.clientNip89)||skipClientTagOnKinds.has(this.kind)||this.isEphemeral()||this.isReplaceable()&&!this.isParamReplaceable()||this.isDvm()||this.hasTag("client"))}get shouldStripClientTag(){return skipClientTagOnKinds.has(this.kind)}muted(){var t;return(t=this.ndk)!=null&&t.muteFilter&&this.ndk.muteFilter(this)?"muted":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const t=this.getMatchingTags("d")[0];return t?t[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(this.isParamReplaceable()){const t=this.dTag??"";return`${this.kind}:${this.pubkey}:${t}`}if(this.isReplaceable())return`${this.kind}:${this.pubkey}:`;throw new Error("Event is not a replaceable event")}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(t){let r;return this.isParamReplaceable()?r=["a",this.tagAddress()]:r=["e",this.tagId()],this.relay?r.push(this.relay.url):r.push(""),r.push(t??""),this.isParamReplaceable()||r.push(this.pubkey),r}referenceTags(t,r,s,o){let a=[];return this.isParamReplaceable()?a=[[s??"a",this.tagAddress()],[s??"e",this.id]]:a=[[s??"e",this.id]],a=a.map(c=>{var l,u,f;return c[0]==="e"||t?c.push(((l=this.relay)==null?void 0:l.url)??""):(u=this.relay)!=null&&u.url&&c.push((f=this.relay)==null?void 0:f.url),c}),a.forEach(c=>{c[0]==="e"?(c.push(t??""),c.push(this.pubkey)):t&&c.push(t)}),a=[...a,...this.getMatchingTags("h")],!r&&(o==null?void 0:o.pTags)!==!1&&a.push(...this.author.referenceTags()),a}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}nip22Filter(){return this.isParamReplaceable()?{"#A":[this.tagId()]}:{"#E":[this.tagId()]}}async delete(t,r=!0){var o;if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new _e(this.ndk,{kind:5,content:t||""});return s.tag(this,void 0,!0),s.tags.push(["k",(o=this.kind)==null?void 0:o.toString()]),r&&(this.emit("deleted"),await s.publish()),s}set isProtected(t){this.removeTag("-"),t&&this.tags.push(["-"])}get isProtected(){return this.hasTag("-")}async react(t,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new _e(this.ndk,{kind:7,content:t});return s.tag(this),this.kind!==1&&s.tags.push(["k",`${this.kind}`]),r&&await s.publish(),s}get isValid(){return this.validate()}get inspect(){return JSON.stringify(this.rawEvent(),null,4)}dump(){console.debug(JSON.stringify(this.rawEvent(),null,4)),console.debug("Event on relays:",this.onRelays.map(t=>t.url).join(", "))}reply(t,r){var o,a,c,l,u,f,h,p;const s=new _e(this.ndk);if((c=(a=(o=this.ndk)==null?void 0:o.aiGuardrails)==null?void 0:a.event)==null||c.creatingReply(s),this.kind===1&&!t)s.kind=1,this.hasTag("e")?s.tags=[...s.tags,...this.getMatchingTags("e"),...this.getMatchingTags("p"),...this.getMatchingTags("a"),...this.referenceTags("reply",!1,void 0,r)]:s.tag(this,"root",!1,void 0,r);else{s.kind=1111;const g=["A","E","I","P"],b=this.tags.filter(m=>g.includes(m[0]));if(b.length>0){const m=this.tagValue("K");s.tags.push(...b),m&&s.tags.push(["K",m]);let E;if(this.isParamReplaceable()){E=["a",this.tagAddress()];const _=((l=this.relay)==null?void 0:l.url)??"";_&&E.push(_)}else{E=["e",this.tagId()];const _=((u=this.relay)==null?void 0:u.url)??"";E.push(_),E.push(this.pubkey)}s.tags.push(E)}else{let m,E;const _=((f=this.relay)==null?void 0:f.url)??"";this.isParamReplaceable()?(m=["a",this.tagAddress(),_],E=["A",this.tagAddress(),_]):(m=["e",this.tagId(),_,this.pubkey],E=["E",this.tagId(),_,this.pubkey]),s.tags.push(m),s.tags.push(E),s.tags.push(["K",(h=this.kind)==null?void 0:h.toString()]),(r==null?void 0:r.pTags)!==!1&&(r==null?void 0:r.pTagOnATags)!==!1&&s.tags.push(["P",this.pubkey])}s.tags.push(["k",(p=this.kind)==null?void 0:p.toString()]),(r==null?void 0:r.pTags)!==!1&&(s.tags.push(...this.getMatchingTags("p")),s.tags.push(["p",this.pubkey]))}return s}},untrackedUnpublishedEvents=new Set([24133,13194,23194,23195]);function shouldTrackUnpublishedEvent(n){return!untrackedUnpublishedEvents.has(n.kind)}var NDKPool=class extends lib$1.EventEmitter{constructor(e,t,{debug:r,name:s}={}){super();y(this,"_relays",new Map);y(this,"status","idle");y(this,"autoConnectRelays",new Set);y(this,"debug");y(this,"temporaryRelayTimers",new Map);y(this,"flappingRelays",new Set);y(this,"backoffTimes",new Map);y(this,"ndk");y(this,"disconnectionTimes",new Map);y(this,"systemEventDetector");y(this,"_name","unnamed");this.debug=r??t.debug.extend("pool"),s&&(this._name=s),this.ndk=t,this.relayUrls=e,this.ndk.pools&&this.ndk.pools.push(this)}get relays(){return this._relays}set relayUrls(e){this._relays.clear();for(const t of e){const r=new NDKRelay(t,void 0,this.ndk);r.connectivity.netDebug=this.ndk.netDebug,this.addRelay(r)}}get name(){return this._name}set name(e){this._name=e,this.debug=this.debug.extend(e)}useTemporaryRelay(e,t=3e4,r){const s=this.relays.has(e.url);s||(this.addRelay(e),this.debug("Adding temporary relay %s for filters %o",e.url,r));const o=this.temporaryRelayTimers.get(e.url);if(o&&clearTimeout(o),!s||o){const a=setTimeout(()=>{var c;(c=this.ndk.explicitRelayUrls)!=null&&c.includes(e.url)||this.removeRelay(e.url)},t);this.temporaryRelayTimers.set(e.url,a)}}addRelay(e,t=!0){var b;const r=this.relays.has(e.url),s=e.url.includes("/npub1");let o=!0;const a=e.url;if(r)return;if(this.ndk.relayConnectionFilter&&!this.ndk.relayConnectionFilter(a)){this.debug(`Refusing to add relay ${a}: blocked by relayConnectionFilter`);return}if(s){this.debug(`Refusing to add relay ${a}: is a filter relay`);return}if((b=this.ndk.cacheAdapter)!=null&&b.getRelayStatus){const m=this.ndk.cacheAdapter.getRelayStatus(a),E=m instanceof Promise?void 0:m;if(E!=null&&E.dontConnectBefore){if(E.dontConnectBefore>Date.now()){const _=E.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${a}: delayed connect for ${_}ms`),setTimeout(()=>{this.addRelay(e,t)},_);return}o=!1}}const c=m=>this.emit("notice",e,m),l=()=>this.handleRelayConnect(a),u=()=>this.handleRelayReady(e),f=()=>{this.recordDisconnection(e),this.emit("relay:disconnect",e)},h=()=>this.handleFlapping(e),p=m=>this.emit("relay:auth",e,m),g=()=>this.emit("relay:authed",e);e.off("notice",c),e.off("connect",l),e.off("ready",u),e.off("disconnect",f),e.off("flapping",h),e.off("auth",p),e.off("authed",g),e.on("notice",c),e.on("connect",l),e.on("ready",u),e.on("disconnect",f),e.on("flapping",h),e.on("auth",p),e.on("authed",g),e.on("delayed-connect",m=>{var E;(E=this.ndk.cacheAdapter)!=null&&E.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(e.url,{dontConnectBefore:Date.now()+m})}),this._relays.set(a,e),t&&this.autoConnectRelays.add(a),t&&this.status==="active"&&(this.emit("relay:connecting",e),e.connect(void 0,o).catch(m=>{this.debug(`Failed to connect to relay ${a}`,m)}))}removeRelay(e){const t=this.relays.get(e);if(t)return t.disconnect(),this.relays.delete(e),this.autoConnectRelays.delete(e),this.emit("relay:disconnect",t),!0;const r=this.temporaryRelayTimers.get(e);return r&&(clearTimeout(r),this.temporaryRelayTimers.delete(e)),!1}isRelayConnected(e){const t=normalizeRelayUrl(e),r=this.relays.get(t);return r?r.status===5:!1}getRelay(e,t=!0,r=!1,s){let o=this.relays.get(normalizeRelayUrl(e));return o||(o=new NDKRelay(e,void 0,this.ndk),o.connectivity.netDebug=this.ndk.netDebug,r?this.useTemporaryRelay(o,3e4,s):this.addRelay(o,t)),o}handleRelayConnect(e){const t=this.relays.get(e);if(!t){console.error("NDK BUG: relay not found in pool",{relayUrl:e});return}this.emit("relay:connect",t),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(e){this.emit("relay:ready",e)}async connect(e){this.status="active",this.debug(`Connecting to ${this.relays.size} relays${e?`, timeout ${e}ms`:""}...`);const t=Array.from(this.autoConnectRelays.keys()).map(a=>this.relays.get(a)).filter(a=>!!a);for(const a of t)a.status!==5&&a.status!==4&&(this.emit("relay:connecting",a),a.connect().catch(c=>{this.debug(`Failed to connect to relay ${a.url}: ${c??"No reason specified"}`)}));const r=()=>t.every(a=>a.status===5),s=new Promise(a=>{if(r()){a();return}const c=[];for(const l of t){const u=()=>{if(r()){for(let f=0;f<t.length;f++)t[f].off("connect",c[f]);a()}};c.push(u),l.on("connect",u)}}),o=typeof e=="number"?new Promise(a=>setTimeout(a,e)):new Promise(()=>{});await Promise.race([s,o])}checkOnFlappingRelays(){const e=this.flappingRelays.size,t=this.relays.size;if(e/t>=.8)for(const r of this.flappingRelays)this.backoffTimes.set(r,0)}recordDisconnection(e){const t=Date.now();this.disconnectionTimes.set(e.url,t);for(const[r,s]of this.disconnectionTimes.entries())t-s>1e4&&this.disconnectionTimes.delete(r);this.checkForSystemWideDisconnection()}checkForSystemWideDisconnection(){const e=Date.now(),t=[];for(const r of this.disconnectionTimes.values())e-r<5e3&&t.push(r);t.length>this.relays.size/2&&this.relays.size>1&&(this.debug(`System-wide disconnection detected: ${t.length}/${this.relays.size} relays disconnected`),this.handleSystemWideReconnection())}handleSystemWideReconnection(){if(this.systemEventDetector){this.debug("System-wide reconnection already in progress, skipping");return}this.debug("Initiating system-wide reconnection with reset backoff"),this.systemEventDetector=setTimeout(()=>{this.systemEventDetector=void 0},1e4);for(const e of this.relays.values())e.connectivity&&(e.connectivity.resetReconnectionState(),e.status!==5&&e.status!==4&&e.connect().catch(t=>{this.debug(`Failed to reconnect relay ${e.url} after system event: ${t}`)}));this.disconnectionTimes.clear()}handleFlapping(e){this.debug(`Relay ${e.url} is flapping`);let t=this.backoffTimes.get(e.url)||5e3;t=t*2,this.backoffTimes.set(e.url,t),this.debug(`Backoff time for ${e.url} is ${t}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${e.url}`),this.emit("relay:connecting",e),e.connect(),this.checkOnFlappingRelays()},t),e.disconnect(),this.emit("flapping",e)}size(){return this.relays.size}stats(){const e={total:0,connected:0,disconnected:0,connecting:0};for(const t of this.relays.values())e.total++,t.status===5?e.connected++:t.status===1?e.disconnected++:t.status===4&&e.connecting++;return e}connectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5&&!this.temporaryRelayTimers.has(e.url))}urls(){return Array.from(this.relays.keys())}},xe,NDKDVMJobFeedback=(xe=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=7e3)}static async from(e){const t=new xe(e.ndk,e.rawEvent());return t.encrypted&&await t.dvmDecrypt(),t}get status(){return this.tagValue("status")}set status(e){this.removeTag("status"),e!==void 0&&this.tags.push(["status",e])}get encrypted(){return!!this.getMatchingTags("encrypted")[0]}async dvmDecrypt(){await this.decrypt();const e=JSON.parse(this.content);this.tags.push(...e)}},y(xe,"kinds",[7e3]),xe),te,NDKCashuMintList=(te=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_p2pk");this.kind??(this.kind=10019)}static from(t){return new te(t.ndk,t)}set relays(t){this.tags=this.tags.filter(r=>r[0]!=="relay");for(const r of t)this.tags.push(["relay",r])}get relays(){const t=[];for(const r of this.tags)r[0]==="relay"&&t.push(r[1]);return t}set mints(t){this.tags=this.tags.filter(r=>r[0]!=="mint");for(const r of t)this.tags.push(["mint",r])}get mints(){const t=[];for(const r of this.tags)r[0]==="mint"&&t.push(r[1]);return Array.from(new Set(t))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(t){this._p2pk=t,this.removeTag("pubkey"),t&&this.tags.push(["pubkey",t])}get relaySet(){return NDKRelaySet.fromRelayUrls(this.relays,this.ndk)}},y(te,"kind",10019),y(te,"kinds",[10019]),te),ne,NDKArticle=(ne=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=30023)}static from(e){return new ne(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get image(){return this.tagValue("image")}set image(e){this.removeTag("image"),e&&this.tags.push(["image",e])}get summary(){return this.tagValue("summary")}set summary(e){this.removeTag("summary"),e&&this.tags.push(["summary",e])}get published_at(){const e=this.tagValue("published_at");if(e){let t=Number.parseInt(e);return t>1e12&&(t=Math.floor(t/1e3)),t}}set published_at(e){this.removeTag("published_at"),e!==void 0&&this.tags.push(["published_at",e.toString()])}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}get url(){return this.tagValue("url")}set url(e){e?this.tags.push(["url",e]):this.removeTag("url")}},y(ne,"kind",30023),y(ne,"kinds",[30023]),ne),Te,NDKBlossomList=(Te=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=10063)}static from(e){return new Te(e.ndk,e.rawEvent())}get servers(){return this.tags.filter(e=>e[0]==="server").map(e=>e[1])}set servers(e){this.tags=this.tags.filter(t=>t[0]!=="server");for(const t of e)this.tags.push(["server",t])}get default(){const e=this.servers;return e.length>0?e[0]:void 0}set default(e){if(!e)return;const r=this.servers.filter(s=>s!==e);this.servers=[e,...r]}addServer(e){if(!e)return;const t=this.servers;t.includes(e)||(this.servers=[...t,e])}removeServer(e){if(!e)return;const t=this.servers;this.servers=t.filter(r=>r!==e)}},y(Te,"kinds",[10063]),Te),re,NDKFedimintMint=(re=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=38173)}static async from(e){return new re(e.ndk,e)}get identifier(){return this.tagValue("d")}set identifier(e){this.removeTag("d"),e&&this.tags.push(["d",e])}get inviteCodes(){return this.getMatchingTags("u").map(e=>e[1])}set inviteCodes(e){this.removeTag("u");for(const t of e)this.tags.push(["u",t])}get modules(){return this.getMatchingTags("modules").map(e=>e[1])}set modules(e){this.removeTag("modules");for(const t of e)this.tags.push(["modules",t])}get network(){return this.tagValue("n")}set network(e){this.removeTag("n"),e&&this.tags.push(["n",e])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(e){e?this.content=JSON.stringify(e):this.content=""}},y(re,"kind",38173),y(re,"kinds",[38173]),re),se,NDKCashuMintAnnouncement=(se=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=38172)}static async from(e){return new se(e.ndk,e)}get identifier(){return this.tagValue("d")}set identifier(e){this.removeTag("d"),e&&this.tags.push(["d",e])}get url(){return this.tagValue("u")}set url(e){this.removeTag("u"),e&&this.tags.push(["u",e])}get nuts(){return this.getMatchingTags("nuts").map(e=>e[1])}set nuts(e){this.removeTag("nuts");for(const t of e)this.tags.push(["nuts",t])}get network(){return this.tagValue("n")}set network(e){this.removeTag("n"),e&&this.tags.push(["n",e])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(e){e?this.content=JSON.stringify(e):this.content=""}},y(se,"kind",38172),y(se,"kinds",[38172]),se),ie,NDKMintRecommendation=(ie=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=38e3)}static async from(e){return new ie(e.ndk,e)}get recommendedKind(){const e=this.tagValue("k");return e?Number(e):void 0}set recommendedKind(e){this.removeTag("k"),e&&this.tags.push(["k",e.toString()])}get identifier(){return this.tagValue("d")}set identifier(e){this.removeTag("d"),e&&this.tags.push(["d",e])}get urls(){return this.getMatchingTags("u").map(e=>e[1])}set urls(e){this.removeTag("u");for(const t of e)this.tags.push(["u",t])}get mintEventPointers(){return this.getMatchingTags("a").map(e=>({kind:Number(e[1].split(":")[0]),identifier:e[1].split(":")[2],relay:e[2]}))}addMintEventPointer(e,t,r,s){const o=["a",`${e}:${t}:${r}`];s&&o.push(s),this.tags.push(o)}get review(){return this.content}set review(e){this.content=e}},y(ie,"kind",38e3),y(ie,"kinds",[38e3]),ie),Se,NDKClassified=(Se=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=30402)}static from(e){return new Se(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get summary(){return this.tagValue("summary")}set summary(e){this.removeTag("summary"),e&&this.tags.push(["summary",e])}get published_at(){const e=this.tagValue("published_at");if(e)return Number.parseInt(e)}set published_at(e){this.removeTag("published_at"),e!==void 0&&this.tags.push(["published_at",e.toString()])}get location(){return this.tagValue("location")}set location(e){this.removeTag("location"),e&&this.tags.push(["location",e])}get price(){const e=this.tags.find(t=>t[0]==="price");if(e)return{amount:Number.parseFloat(e[1]),currency:e[2],frequency:e[3]}}set price(e){if(typeof e=="string"&&(e={amount:Number.parseFloat(e)}),e!=null&&e.amount){const t=["price",e.amount.toString()];e.currency&&t.push(e.currency),e.frequency&&t.push(e.frequency),this.tags.push(t)}else this.removeTag("price")}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}},y(Se,"kinds",[30402]),Se),oe,NDKDraft=(oe=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_event");y(this,"counterparty");this.kind??(this.kind=31234)}static from(t){return new oe(t.ndk,t)}set identifier(t){this.removeTag("d"),this.tags.push(["d",t])}get identifier(){return this.dTag}set event(t){t instanceof NDKEvent?this._event=t:this._event=new NDKEvent(void 0,t),this.prepareEvent()}set checkpoint(t){t?(this.tags.push(t.tagReference()),this.kind=1234):(this.removeTag("a"),this.kind=31234)}get isCheckpoint(){return this.kind===1234}get isProposal(){const t=this.tagValue("p");return!!t&&t!==this.pubkey}async getEvent(t){var r;if(this._event)return this._event;if(t??(t=(r=this.ndk)==null?void 0:r.signer),!t)throw new Error("No signer available");if(this.content&&this.content.length>0)try{const s=t.pubkey,a=[this.tagValue("p"),this.pubkey].filter(Boolean).find(u=>u!==s);let c;c=new NDKUser({pubkey:a??s}),await this.decrypt(c,t);const l=JSON.parse(this.content);return this._event=await wrapEvent(new NDKEvent(this.ndk,l)),this._event}catch(s){console.error(s);return}else return null}prepareEvent(){if(!this._event)throw new Error("No event has been provided");this.removeTag("k"),this._event.kind&&this.tags.push(["k",this._event.kind.toString()]),this.content=JSON.stringify(this._event.rawEvent())}async save({signer:t,publish:r,relaySet:s}){var a;if(t??(t=(a=this.ndk)==null?void 0:a.signer),!t)throw new Error("No signer available");const o=this.counterparty||await t.user();if(await this.encrypt(o,t),this.counterparty){const c=this.counterparty.pubkey;this.removeTag("p"),this.tags.push(["p",c])}if(r!==!1)return this.publishReplaceable(s)}},y(oe,"kind",31234),y(oe,"kinds",[31234,1234]),oe);function mapImetaTag(n){const e={};if(n.length===2){const r=n[1].split(" ");for(let s=0;s<r.length;s+=2){const o=r[s],a=r[s+1];o==="fallback"?(e.fallback||(e.fallback=[]),e.fallback.push(a)):e[o]=a}return e}const t=n.slice(1);for(const r of t){const s=r.split(" "),o=s[0],a=s.slice(1).join(" ");o==="fallback"?(e.fallback||(e.fallback=[]),e.fallback.push(a)):e[o]=a}return e}function imetaTagToTag(n){const e=["imeta"];for(const[t,r]of Object.entries(n))if(Array.isArray(r))for(const s of r)e.push(`${t} ${s}`);else r&&e.push(`${t} ${r}`);return e}var ae,NDKFollowPack=(ae=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=39089)}static from(e){return new ae(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get image(){const e=this.tags.find(t=>t[0]==="imeta");if(e){const t=mapImetaTag(e);if(t.url)return t.url}return this.tagValue("image")}set image(e){this.tags=this.tags.filter(t=>t[0]!=="imeta"&&t[0]!=="image"),typeof e=="string"?e!==void 0&&this.tags.push(["image",e]):e&&typeof e=="object"&&(this.tags.push(imetaTagToTag(e)),e.url&&this.tags.push(["image",e.url]))}get pubkeys(){return Array.from(new Set(this.tags.filter(e=>e[0]==="p"&&e[1]&&isValidPubkey(e[1])).map(e=>e[1])))}set pubkeys(e){this.tags=this.tags.filter(t=>t[0]!=="p");for(const t of e)this.tags.push(["p",t])}get description(){return this.tagValue("description")}set description(e){this.removeTag("description"),e&&this.tags.push(["description",e])}},y(ae,"kind",39089),y(ae,"kinds",[39089,39092]),ae),ce,NDKHighlight=(ce=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_article");this.kind??(this.kind=9802)}static from(t){return new ce(t.ndk,t)}get url(){return this.tagValue("r")}set context(t){t===void 0?this.tags=this.tags.filter(([r,s])=>r!=="context"):(this.tags=this.tags.filter(([r,s])=>r!=="context"),this.tags.push(["context",t]))}get context(){var t;return((t=this.tags.find(([r,s])=>r==="context"))==null?void 0:t[1])??void 0}get article(){return this._article}set article(t){this._article=t,typeof t=="string"?this.tags.push(["r",t]):this.tag(t)}getArticleTag(){return this.getMatchingTags("a")[0]||this.getMatchingTags("e")[0]||this.getMatchingTags("r")[0]}async getArticle(){var s;if(this._article!==void 0)return this._article;let t;const r=this.getArticleTag();if(r){switch(r[0]){case"a":{const[o,a,c]=r[1].split(":");t=nip19_exports$1.naddrEncode({kind:Number.parseInt(o),pubkey:a,identifier:c});break}case"e":t=nip19_exports$1.noteEncode(r[1]);break;case"r":this._article=r[1];break}if(t){let o=await((s=this.ndk)==null?void 0:s.fetchEvent(t));o&&(o.kind===30023&&(o=NDKArticle.from(o)),this._article=o)}return this._article}}},y(ce,"kind",9802),y(ce,"kinds",[9802]),ce),le,NDKImage=(le=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_imetas");this.kind??(this.kind=20)}static from(t){return new le(t.ndk,t.rawEvent())}get isValid(){return this.imetas.length>0}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag).filter(t=>!!t.url),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag))}},y(le,"kind",20),y(le,"kinds",[20]),le),Ae,NDKList=(Ae=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_encryptedTags");y(this,"encryptedTagsLength");this.kind??(this.kind=30001)}static from(t){return new Ae(t.ndk,t)}get title(){const t=this.tagValue("title")||this.tagValue("name");return t||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(t){this.removeTag(["title","name"]),t&&this.tags.push(["title",t])}get name(){return this.title}set name(t){this.title=t}get description(){return this.tagValue("description")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(t=!0){if(t&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const r=await this.ndk.signer.user();try{if(this.content.length>0)try{const s=await this.ndk.signer.decrypt(r,this.content),o=JSON.parse(s);return o!=null&&o[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=o):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{}}catch{}return[]}validateTag(t){return!0}getItems(t){return this.tags.filter(r=>r[0]===t)}get items(){return this.tags.filter(t=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(t[0]))}async addItem(t,r=void 0,s=!1,o="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let a;if(t instanceof NDKEvent)a=[t.tagReference(r)];else if(t instanceof NDKUser)a=t.referenceTags();else if(t instanceof NDKRelay)a=t.referenceTags();else if(Array.isArray(t))a=[t];else throw new Error("Invalid object type");if(r&&a[0].push(r),s){const c=await this.ndk.signer.user(),l=await this.encryptedTags();o==="top"?l.unshift(...a):l.push(...a),this._encryptedTags=l,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(l),await this.encrypt(c)}else o==="top"?this.tags.unshift(...a):this.tags.push(...a);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(t,r=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const s=this.tags.findIndex(l=>l[1]===t);s>=0&&this.tags.splice(s,1);const o=await this.ndk.signer.user(),a=await this.encryptedTags(),c=a.findIndex(l=>l[1]===t);if(c>=0&&(a.splice(c,1),this._encryptedTags=a,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(a),await this.encrypt(o)),r)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(t,r){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(r){const s=await this.ndk.signer.user(),o=await this.encryptedTags();o.splice(t,1),this._encryptedTags=o,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(o),await this.encrypt(s)}else this.tags.splice(t,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(t){return this.items.some(r=>r[1]===t)}filterForItems(){const t=new Set,r=new Map,s=[];for(const o of this.items)if(o[0]==="e"&&o[1])t.add(o[1]);else if(o[0]==="a"&&o[1]){const[a,c,l]=o[1].split(":");if(!a||!c)continue;const u=`${a}:${c}`,f=r.get(u)||[];f.push(l||""),r.set(u,f)}if(t.size>0&&s.push({ids:Array.from(t)}),r.size>0)for(const[o,a]of r.entries()){const[c,l]=o.split(":");s.push({kinds:[Number.parseInt(c)],authors:[l],"#d":a})}return s}},y(Ae,"kinds",[30001,10004,10050,10030,10015,10001,10002,10007,10006,10003]),Ae),Re,NDKAppHandlerEvent=(Re=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"profile");this.kind??(this.kind=31990)}static from(t){const r=new Re(t.ndk,t.rawEvent());return r.isValid?r:null}get isValid(){const t=new Map,r=o=>[o[0],o[2]].join(":").toLowerCase(),s=["web","android","ios"];for(const o of this.tags)if(s.includes(o[0])){const a=r(o);if(t.has(a)&&t.get(a)!==o[1].toLowerCase())return!1;t.set(a,o[1].toLowerCase())}return!0}async fetchProfile(){if(this.profile===void 0&&this.content.length>0)try{const t=JSON.parse(this.content);if(t!=null&&t.name)return t;this.profile=null}catch{this.profile=null}return new Promise((t,r)=>{const s=this.author;s.fetchProfile().then(()=>{t(s.profile)}).catch(r)})}},y(Re,"kinds",[31990]),Re),Q,NDKNutzap=(Q=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"debug");y(this,"_proofs",[]);y(this,"sender",this.author);this.kind??(this.kind=9321),this.debug=(t==null?void 0:t.debug.extend("nutzap"))??createDebug5("ndk:nutzap"),this.alt||(this.alt="This is a nutzap");try{const s=this.getMatchingTags("proof");s.length?this._proofs=s.map(o=>JSON.parse(o[1])):this._proofs=JSON.parse(this.content)}catch{return}}static from(t){const r=new Q(t.ndk,t);if(!(!r._proofs||!r._proofs.length))return r}set comment(t){this.content=t??""}get comment(){const t=this.tagValue("comment");return t||this.content}set proofs(t){this._proofs=t,this.tags=this.tags.filter(r=>r[0]!=="proof");for(const r of t)this.tags.push(["proof",JSON.stringify(r)])}get proofs(){return this._proofs}get rawP2pk(){var r;const t=this.proofs[0];try{const s=JSON.parse(t.secret);let o;if(typeof s=="string"?(o=JSON.parse(s),this.debug("stringified payload",t.secret)):typeof s=="object"&&(o=s),Array.isArray(o)&&o[0]==="P2PK"&&o.length>1&&typeof o[1]=="object"&&o[1]!==null||typeof o=="object"&&o!==null&&typeof((r=o[1])==null?void 0:r.data)=="string")return o[1].data}catch(s){this.debug("error parsing p2pk pubkey",s,this.proofs[0])}}get p2pk(){const t=this.rawP2pk;if(t)return t.startsWith("02")?t.slice(2):t}get mint(){return this.tagValue("u")}set mint(t){this.replaceTag(["u",t])}get unit(){let t=this.tagValue("unit")??"sat";return t!=null&&t.startsWith("msat")&&(t="sat"),t}set unit(t){if(this.removeTag("unit"),t!=null&&t.startsWith("msat"))throw new Error("msat is not allowed, use sat denomination instead");t&&this.tag(["unit",t])}get amount(){return this.proofs.reduce((r,s)=>r+s.amount,0)}set target(t){this.tags=this.tags.filter(r=>r[0]!=="p"),t instanceof NDKEvent&&this.tags.push(t.tagReference())}set recipientPubkey(t){this.removeTag("p"),this.tag(["p",t])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const t=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:t}):new NDKUser({pubkey:t})}async toNostrEvent(){this.unit==="msat"&&(this.unit="sat"),this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()]);const t=await super.toNostrEvent();return t.content=this.comment,t}get isValid(){let t=0,r=0,s=0;for(const o of this.tags)o[0]==="e"&&t++,o[0]==="p"&&r++,o[0]==="u"&&s++;return r===1&&s===1&&t<=1&&this.proofs.length>0}},y(Q,"kind",9321),y(Q,"kinds",[Q.kind]),Q),ue,NDKProject=(ue=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_signer");this.kind=31933}static from(t){return new ue(t.ndk,t.rawEvent())}set repo(t){this.removeTag("repo"),t&&this.tags.push(["repo",t])}set hashtags(t){this.removeTag("hashtags"),t.filter(r=>r.length>0).length&&this.tags.push(["hashtags",...t])}get hashtags(){const t=this.tags.find(r=>r[0]==="hashtags");return t?t.slice(1):[]}get repo(){return this.tagValue("repo")}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get picture(){return this.tagValue("picture")}set picture(t){this.removeTag("picture"),t&&this.tags.push(["picture",t])}set description(t){this.content=t}get description(){return this.content}get slug(){return this.dTag??"empty-dtag"}async getSigner(){var r,s;if(this._signer)return this._signer;const t=this.tagValue("key");if(!t)this._signer=NDKPrivateKeySigner.generate(),await this.encryptAndSaveNsec();else{const o=await((s=(r=this.ndk)==null?void 0:r.signer)==null?void 0:s.decrypt(this.ndk.activeUser,t));if(!o)throw new Error("Failed to decrypt project key or missing signer context.");this._signer=new NDKPrivateKeySigner(o)}return this._signer}async getNsec(){return(await this.getSigner()).privateKey}async setNsec(t){this._signer=new NDKPrivateKeySigner(t),await this.encryptAndSaveNsec()}async encryptAndSaveNsec(){var s,o;if(!this._signer)throw new Error("Signer is not set.");const t=this._signer.privateKey,r=await((o=(s=this.ndk)==null?void 0:s.signer)==null?void 0:o.encrypt(this.ndk.activeUser,t));r&&(this.removeTag("key"),this.tags.push(["key",r]))}},y(ue,"kind",31933),y(ue,"kinds",[31933]),ue),he,NDKProjectTemplate=(he=class extends NDKEvent{constructor(e,t){super(e,t),this.kind=30717}static from(e){return new he(e.ndk,e.rawEvent())}get templateId(){return this.dTag??""}set templateId(e){this.dTag=e}get name(){return this.tagValue("title")??""}set name(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get description(){return this.tagValue("description")??""}set description(e){this.removeTag("description"),e&&this.tags.push(["description",e])}get repoUrl(){return this.tagValue("uri")??""}set repoUrl(e){this.removeTag("uri"),e&&this.tags.push(["uri",e])}get image(){return this.tagValue("image")}set image(e){this.removeTag("image"),e&&this.tags.push(["image",e])}get command(){return this.tagValue("command")}set command(e){this.removeTag("command"),e&&this.tags.push(["command",e])}get agentConfig(){const e=this.tagValue("agent");if(e)try{return JSON.parse(e)}catch{return}}set agentConfig(e){this.removeTag("agent"),e&&this.tags.push(["agent",JSON.stringify(e)])}get templateTags(){return this.getMatchingTags("t").map(e=>e[1]).filter(Boolean)}set templateTags(e){this.tags=this.tags.filter(t=>t[0]!=="t"),e.forEach(t=>{t&&this.tags.push(["t",t])})}},y(he,"kind",30717),y(he,"kinds",[30717]),he),READ_MARKER="read",WRITE_MARKER="write",Ne,NDKRelayList=(Ne=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=10002)}static from(e){return new Ne(e.ndk,e.rawEvent())}get readRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===READ_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set readRelayUrls(e){for(const t of e)this.tags.push(["r",t,READ_MARKER])}get writeRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===WRITE_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set writeRelayUrls(e){for(const t of e)this.tags.push(["r",t,WRITE_MARKER])}get bothRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]).map(e=>e[1])}set bothRelayUrls(e){for(const t of e)this.tags.push(["r",t])}get relays(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").map(e=>e[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet(new Set(this.relays.map(e=>{var t;return(t=this.ndk)==null?void 0:t.pool.getRelay(e)}).filter(e=>!!e)),this.ndk)}},y(Ne,"kinds",[10002]),Ne);function relayListFromKind3(n,e){try{const t=JSON.parse(e.content),r=new NDKRelayList(n),s=new Set,o=new Set;for(let[a,c]of Object.entries(t)){try{a=normalizeRelayUrl(a)}catch{continue}if(!c)s.add(a),o.add(a);else{const l=c;l.write&&o.add(a),l.read&&s.add(a)}}return r.readRelayUrls=Array.from(s),r.writeRelayUrls=Array.from(o),r}catch{}}var Ce,NDKRepost=(Ce=class extends NDKEvent{constructor(){super(...arguments);y(this,"_repostedEvents")}static from(t){return new Ce(t.ndk,t.rawEvent())}async repostedEvents(t,r){const s=[];if(!this.ndk)throw new Error("NDK instance not set");if(this._repostedEvents!==void 0)return this._repostedEvents;for(const o of this.repostedEventIds()){const a=filterForId(o),c=await this.ndk.fetchEvent(a,r);c&&s.push(t?t.from(c):c)}return s}repostedEventIds(){return this.tags.filter(t=>t[0]==="e"||t[0]==="a").map(t=>t[1])}},y(Ce,"kinds",[6,16]),Ce);function filterForId(n){if(n.match(/:/)){const[e,t,r]=n.split(":");return{kinds:[Number.parseInt(e)],authors:[t],"#d":[r]}}return{ids:[n]}}var de,NDKSimpleGroupMemberList=(de=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"relaySet");y(this,"memberSet",new Set);this.kind??(this.kind=39002),this.memberSet=new Set(this.members)}static from(t){return new de(t.ndk,t)}get members(){return this.getMatchingTags("p").map(t=>t[1])}hasMember(t){return this.memberSet.has(t)}async publish(t,r,s){return t??(t=this.relaySet),super.publishReplaceable(t,r,s)}},y(de,"kind",39002),y(de,"kinds",[39002]),de),pe,NDKSimpleGroupMetadata=(pe=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=39e3)}static from(e){return new pe(e.ndk,e)}get name(){return this.tagValue("name")}get picture(){return this.tagValue("picture")}get about(){return this.tagValue("about")}get scope(){if(this.getMatchingTags("public").length>0)return"public";if(this.getMatchingTags("public").length>0)return"private"}set scope(e){this.removeTag("public"),this.removeTag("private"),e==="public"?this.tags.push(["public",""]):e==="private"&&this.tags.push(["private",""])}get access(){if(this.getMatchingTags("open").length>0)return"open";if(this.getMatchingTags("closed").length>0)return"closed"}set access(e){this.removeTag("open"),this.removeTag("closed"),e==="open"?this.tags.push(["open",""]):e==="closed"&&this.tags.push(["closed",""])}},y(pe,"kind",39e3),y(pe,"kinds",[39e3]),pe);function strToPosition(n){const[e,t]=n.split(",").map(Number);return{x:e,y:t}}function strToDimension(n){const[e,t]=n.split("x").map(Number);return{width:e,height:t}}var J,NDKStorySticker=(J=class{constructor(e){y(this,"type");y(this,"value");y(this,"position");y(this,"dimension");y(this,"properties");y(this,"hasValidDimensions",()=>typeof this.dimension.width=="number"&&typeof this.dimension.height=="number"&&!Number.isNaN(this.dimension.width)&&!Number.isNaN(this.dimension.height));y(this,"hasValidPosition",()=>typeof this.position.x=="number"&&typeof this.position.y=="number"&&!Number.isNaN(this.position.x)&&!Number.isNaN(this.position.y));if(Array.isArray(e)){const t=e;if(t[0]!=="sticker"||t.length<5)throw new Error("Invalid sticker tag");this.type=t[1],this.value=t[2],this.position=strToPosition(t[3]),this.dimension=strToDimension(t[4]);const r={};for(let s=5;s<t.length;s++){const[o,...a]=t[s].split(" ");r[o]=a.join(" ")}Object.keys(r).length>0&&(this.properties=r)}else this.type=e,this.value=void 0,this.position={x:0,y:0},this.dimension={width:0,height:0}}static fromTag(e){try{return new J(e)}catch{return null}}get style(){var e;return(e=this.properties)==null?void 0:e.style}set style(e){var t;e?this.properties={...this.properties,style:e}:(t=this.properties)==null||delete t.style}get rotation(){var e;return(e=this.properties)!=null&&e.rot?Number.parseFloat(this.properties.rot):void 0}set rotation(e){var t;e!==void 0?this.properties={...this.properties,rot:e.toString()}:(t=this.properties)==null||delete t.rot}get isValid(){return this.hasValidDimensions()&&this.hasValidPosition()}toTag(){if(!this.isValid){const r=[this.hasValidDimensions()?void 0:"dimensions is invalid",this.hasValidPosition()?void 0:"position is invalid"].filter(Boolean);throw new Error(`Invalid sticker: ${r.join(", ")}`)}let e;switch(this.type){case"event":e=this.value.tagId();break;case"pubkey":e=this.value.pubkey;break;default:e=this.value}const t=["sticker",this.type,e,coordinates(this.position),dimension(this.dimension)];if(this.properties)for(const[r,s]of Object.entries(this.properties))t.push(`${r} ${s}`);return t}},y(J,"Text","text"),y(J,"Pubkey","pubkey"),y(J,"Event","event"),y(J,"Prompt","prompt"),y(J,"Countdown","countdown"),J),ye,NDKStory=(ye=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"_imeta");y(this,"_dimensions");if(this.kind??(this.kind=23),r)for(const s of r.tags)switch(s[0]){case"imeta":this._imeta=mapImetaTag(s);break;case"dim":this.dimensions=strToDimension(s[1]);break}}static from(t){return new ye(t.ndk,t)}get isValid(){return!!this.imeta}get imeta(){return this._imeta}set imeta(t){this._imeta=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),t&&this.tags.push(imetaTagToTag(t))}get dimensions(){const t=this.tagValue("dim");if(t)return strToDimension(t)}set dimensions(t){this.removeTag("dim"),t&&this.tags.push(["dim",`${t.width}x${t.height}`])}get duration(){const t=this.tagValue("dur");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("dur"),t!==void 0&&this.tags.push(["dur",t.toString()])}get stickers(){const t=[];for(const r of this.tags){if(r[0]!=="sticker"||r.length<5)continue;const s=NDKStorySticker.fromTag(r);s&&t.push(s)}return t}addSticker(t){let r;if(t instanceof NDKStorySticker)r=t;else{const s=["sticker",t.type,typeof t.value=="string"?t.value:"",coordinates(t.position),dimension(t.dimension)];if(t.properties)for(const[o,a]of Object.entries(t.properties))s.push(`${o} ${a}`);r=new NDKStorySticker(s),r.value=t.value}r.type==="pubkey"?this.tag(r.value):r.type==="event"&&this.tag(r.value),this.tags.push(r.toTag())}removeSticker(t){const r=this.stickers;if(t<0||t>=r.length)return;let s=0;for(let o=0;o<this.tags.length;o++)if(this.tags[o][0]==="sticker"){if(s===t){this.tags.splice(o,1);break}s++}}},y(ye,"kind",23),y(ye,"kinds",[23]),ye),coordinates=n=>`${n.x},${n.y}`,dimension=n=>`${n.width}x${n.height}`,Be,NDKSubscriptionReceipt=(Be=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"debug");this.kind??(this.kind=7003),this.debug=(t==null?void 0:t.debug.extend("subscription-start"))??createDebug5("ndk:subscription-start")}static from(t){return new Be(t.ndk,t.rawEvent())}get recipient(){var s;const t=(s=this.getMatchingTags("p"))==null?void 0:s[0];return t?new NDKUser({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get subscriber(){var s;const t=(s=this.getMatchingTags("P"))==null?void 0:s[0];return t?new NDKUser({pubkey:t[1]}):void 0}set subscriber(t){this.removeTag("P"),t&&this.tags.push(["P",t.pubkey])}set subscriptionStart(t){this.debug(`before setting subscription start: ${this.rawEvent}`),this.removeTag("e"),this.tag(t,"subscription",!0),this.debug(`after setting subscription start: ${this.rawEvent}`)}get tierName(){var r;const t=(r=this.getMatchingTags("tier"))==null?void 0:r[0];return t==null?void 0:t[1]}get isValid(){const t=this.validPeriod;if(!t||t.start>t.end)return!1;const r=this.getMatchingTags("p"),s=this.getMatchingTags("P");return!(r.length!==1||s.length!==1)}get validPeriod(){var r;const t=(r=this.getMatchingTags("valid"))==null?void 0:r[0];if(t)try{return{start:new Date(Number.parseInt(t[1])*1e3),end:new Date(Number.parseInt(t[2])*1e3)}}catch{return}}set validPeriod(t){this.removeTag("valid"),t&&this.tags.push(["valid",Math.floor(t.start.getTime()/1e3).toString(),Math.floor(t.end.getTime()/1e3).toString()])}get startPeriod(){var t;return(t=this.validPeriod)==null?void 0:t.start}get endPeriod(){var t;return(t=this.validPeriod)==null?void 0:t.end}isActive(t){t??(t=new Date);const r=this.validPeriod;return!(!r||t<r.start||t>r.end)}},y(Be,"kinds",[7003]),Be),possibleIntervalFrequencies=["daily","weekly","monthly","quarterly","yearly"];function newAmount(n,e,t){return["amount",n.toString(),e,t]}function parseTagToSubscriptionAmount(n){const e=Number.parseInt(n[1]);if(Number.isNaN(e)||e===void 0||e===null||e<=0)return;const t=n[2];if(t===void 0||t==="")return;const r=n[3];if(r!==void 0&&possibleIntervalFrequencies.includes(r))return{amount:e,currency:t,term:r}}var me,NDKSubscriptionTier=(me=class extends NDKArticle{constructor(e,t){const r=(t==null?void 0:t.kind)??37001;super(e,t),this.kind=r}static from(e){return new me(e.ndk,e)}get perks(){return this.getMatchingTags("perk").map(e=>e[1]).filter(e=>e!==void 0)}addPerk(e){this.tags.push(["perk",e])}get amounts(){return this.getMatchingTags("amount").map(e=>parseTagToSubscriptionAmount(e)).filter(e=>e!==void 0)}addAmount(e,t,r){this.tags.push(newAmount(e,t,r))}set relayUrl(e){this.tags.push(["r",e])}get relayUrls(){return this.getMatchingTags("r").map(e=>e[1]).filter(e=>e!==void 0)}get verifierPubkey(){return this.tagValue("p")}set verifierPubkey(e){this.removeTag("p"),e&&this.tags.push(["p",e])}get isValid(){return this.title!==void 0&&this.amounts.length>0}},y(me,"kind",37001),y(me,"kinds",[37001]),me),Ie,NDKSubscriptionStart=(Ie=class extends NDKEvent{constructor(t,r){super(t,r);y(this,"debug");this.kind??(this.kind=7001),this.debug=(t==null?void 0:t.debug.extend("subscription-start"))??createDebug5("ndk:subscription-start")}static from(t){return new Ie(t.ndk,t.rawEvent())}get recipient(){var s;const t=(s=this.getMatchingTags("p"))==null?void 0:s[0];return t?new NDKUser({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get amount(){var r;const t=(r=this.getMatchingTags("amount"))==null?void 0:r[0];if(t)return parseTagToSubscriptionAmount(t)}set amount(t){this.removeTag("amount"),t&&this.tags.push(newAmount(t.amount,t.currency,t.term))}get tierId(){var s,o;const t=(s=this.getMatchingTags("e"))==null?void 0:s[0],r=(o=this.getMatchingTags("a"))==null?void 0:o[0];if(!(!t||!r))return t[1]??r[1]}set tier(t){this.removeTag("e"),this.removeTag("a"),this.removeTag("event"),t&&(this.tag(t),this.removeTag("p"),this.tags.push(["p",t.pubkey]),this.tags.push(["event",JSON.stringify(t.rawEvent())]))}async fetchTier(){var o;const t=this.tagValue("event");if(t)try{const a=JSON.parse(t);return new NDKSubscriptionTier(this.ndk,a)}catch{this.debug("Failed to parse event tag")}const r=this.tierId;if(!r)return;const s=await((o=this.ndk)==null?void 0:o.fetchEvent(r));if(s)return NDKSubscriptionTier.from(s)}get isValid(){return this.getMatchingTags("amount").length!==1?(this.debug("Invalid # of amount tag"),!1):this.amount?this.getMatchingTags("p").length!==1?(this.debug("Invalid # of p tag"),!1):this.recipient?!0:(this.debug("Invalid p tag"),!1):(this.debug("Invalid amount tag"),!1)}},y(Ie,"kinds",[7001]),Ie),be,NDKTask=(be=class extends NDKEvent{constructor(e,t){super(e,t),this.kind=1934}static from(e){return new be(e.ndk,e.rawEvent())}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}get title(){return this.tagValue("title")}set project(e){this.removeTag("a"),this.tags.push(e.tagReference())}get projectSlug(){var t;const e=this.getMatchingTags("a")[0];return e?(t=e[1].split(/:/))==null?void 0:t[2]:void 0}},y(be,"kind",1934),y(be,"kinds",[1934]),be),we,NDKThread=(we=class extends NDKEvent{constructor(e,t){super(e,t),this.kind??(this.kind=11)}static from(e){return new we(e.ndk,e)}get title(){return this.tagValue("title")}set title(e){this.removeTag("title"),e&&this.tags.push(["title",e])}},y(we,"kind",11),y(we,"kinds",[11]),we),Ee,NDKVideo=(Ee=class extends NDKEvent{constructor(){super(...arguments);y(this,"_imetas")}static from(t){return new Ee(t.ndk,t.rawEvent())}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get thumbnail(){var r;let t;return this.imetas&&this.imetas.length>0&&(t=(r=this.imetas[0].image)==null?void 0:r[0]),t??this.tagValue("thumb")}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag))}get url(){return this.imetas&&this.imetas.length>0?this.imetas[0].url:this.tagValue("url")}get published_at(){const t=this.tagValue("published_at");if(t)return Number.parseInt(t)}async generateTags(){var t,r;if(super.generateTags(),!this.kind&&(r=(t=this.imetas)==null?void 0:t[0])!=null&&r.dim){const[s,o]=this.imetas[0].dim.split("x"),a=s&&o&&Number.parseInt(s)<Number.parseInt(o);this.duration&&this.duration<120&&a?this.kind=22:this.kind=21}return super.generateTags()}get duration(){const t=this.tagValue("duration");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("duration"),t!==void 0&&this.tags.push(["duration",Math.floor(t).toString()])}},y(Ee,"kind",21),y(Ee,"kinds",[34235,34236,22,21]),Ee),ve,NDKWiki=(ve=class extends NDKArticle{static from(e){return new ve(e.ndk,e.rawEvent())}get isDefered(){return this.hasTag("a","defer")}get deferedId(){return this.tagValue("a","defer")}set defer(e){this.removeTag("a","defer"),this.tag(e,"defer")}},y(ve,"kind",30818),y(ve,"kinds",[30818]),ve),Pe,NDKWikiMergeRequest=(Pe=class extends NDKEvent{static from(e){return new Pe(e.ndk,e.rawEvent())}get targetId(){return this.tagValue("a")}set target(e){this.tags=this.tags.filter(t=>{if(t[0]==="a"||t[0]==="e"&&t[3]!=="source")return!0}),this.tag(e)}get sourceId(){return this.tagValue("e","source")}set source(e){this.removeTag("e","source"),this.tag(e,"source",!1,"e")}},y(Pe,"kinds",[818]),Pe),registeredEventClasses=new Set;function wrapEvent(n){const e=new Map,r=[...[NDKImage,NDKVideo,NDKCashuMintList,NDKArticle,NDKHighlight,NDKDraft,NDKWiki,NDKWikiMergeRequest,NDKNutzap,NDKProject,NDKTask,NDKProjectTemplate,NDKSimpleGroupMemberList,NDKSimpleGroupMetadata,NDKSubscriptionTier,NDKSubscriptionStart,NDKSubscriptionReceipt,NDKList,NDKRelayList,NDKStory,NDKBlossomList,NDKFollowPack,NDKThread,NDKRepost,NDKClassified,NDKAppHandlerEvent,NDKDVMJobFeedback,NDKCashuMintAnnouncement,NDKFedimintMint,NDKMintRecommendation],...registeredEventClasses];for(const o of r)for(const a of o.kinds)e.set(a,o);const s=e.get(n.kind);return s?s.from(n):n}function checkMissingKind(n,e){(n.kind===void 0||n.kind===null)&&e("event-missing-kind",`Cannot sign event without 'kind'.

📦 Event data:
   • content: ${n.content?`"${n.content.substring(0,50)}${n.content.length>50?"...":""}"`:"(empty)"}
   • tags: ${n.tags.length} tag${n.tags.length!==1?"s":""}
   • kind: ${n.kind} ❌

Set event.kind before signing.`,"Example: event.kind = 1; // for text note",!1)}function checkContentIsObject(n,e){if(typeof n.content=="object"){const t=JSON.stringify(n.content,null,2).substring(0,200);e("event-content-is-object",`Event content is an object. Content must be a string.

📦 Your content (${typeof n.content}):
${t}${JSON.stringify(n.content).length>200?"...":""}

❌ event.content = { ... }  // WRONG
✅ event.content = JSON.stringify({ ... })  // CORRECT`,"Use JSON.stringify() for structured data: event.content = JSON.stringify(data)",!1)}}function checkCreatedAtMilliseconds(n,e){if(n.created_at&&n.created_at>1e10){const t=Math.floor(n.created_at/1e3),r=new Date(n.created_at).toISOString();e("event-created-at-milliseconds",`Event created_at is in milliseconds, not seconds.

📦 Your value:
   • created_at: ${n.created_at} ❌
   • Interpreted as: ${r}
   • Should be: ${t} ✅

Nostr timestamps MUST be in seconds since Unix epoch.`,"Use Math.floor(Date.now() / 1000) instead of Date.now()",!1)}}function checkInvalidPTags(n,e){n.getMatchingTags("p").forEach((r,s)=>{if(r[1]&&!/^[0-9a-f]{64}$/i.test(r[1])){const o=JSON.stringify(r);e("tag-invalid-p-tag",`p-tag[${s}] has invalid pubkey.

📦 Your tag:
   ${o}

❌ Invalid value: "${r[1]}"
   • Length: ${r[1].length} (expected 64)
   • Format: ${r[1].startsWith("npub")?"bech32 (npub)":"unknown"}

p-tags MUST contain 64-character hex pubkeys.`,r[1].startsWith("npub")?`Use ndkUser.pubkey instead of npub:
   ✅ event.tags.push(['p', ndkUser.pubkey])
   ❌ event.tags.push(['p', 'npub1...'])`:"p-tags must contain valid hex pubkeys (64 characters, 0-9a-f)",!1)}})}function checkInvalidETags(n,e){n.getMatchingTags("e").forEach((r,s)=>{if(r[1]&&!/^[0-9a-f]{64}$/i.test(r[1])){const o=JSON.stringify(r),a=r[1].startsWith("note")||r[1].startsWith("nevent");e("tag-invalid-e-tag",`e-tag[${s}] has invalid event ID.

📦 Your tag:
   ${o}

❌ Invalid value: "${r[1]}"
   • Length: ${r[1].length} (expected 64)
   • Format: ${a?"bech32 (note/nevent)":"unknown"}

e-tags MUST contain 64-character hex event IDs.`,a?`Use event.id instead of bech32:
   ✅ event.tags.push(['e', referencedEvent.id])
   ❌ event.tags.push(['e', 'note1...'])`:"e-tags must contain valid hex event IDs (64 characters, 0-9a-f)",!1)}})}function checkManualReplyMarkers(n,e,t){if(n.kind!==1||t.has(n))return;const r=n.tags.filter(s=>s[0]==="e"&&(s[3]==="reply"||s[3]==="root"));if(r.length>0){const s=r.map((o,a)=>`   ${a+1}. ${JSON.stringify(o)}`).join(`
`);e("event-manual-reply-markers",`Event has ${r.length} e-tag(s) with manual reply/root markers.

📦 Your tags with markers:
${s}

⚠️  Manual reply markers detected! This will cause incorrect threading.`,`Reply events MUST be created using .reply():

   ✅ CORRECT:
   const replyEvent = originalEvent.reply();
   replyEvent.content = 'good point!';
   await replyEvent.publish();

   ❌ WRONG:
   event.tags.push(['e', eventId, '', 'reply']);

NDK handles all reply threading automatically - never add reply/root markers manually.`)}}function checkHashtagsWithPrefix(n,e){n.getMatchingTags("t").forEach((r,s)=>{if(r[1]&&r[1].startsWith("#")){const o=JSON.stringify(r);e("tag-hashtag-with-prefix",`t-tag[${s}] contains hashtag with # prefix.

📦 Your tag:
   ${o}

❌ Invalid value: "${r[1]}"

Hashtag tags should NOT include the # symbol.`,`Remove the # prefix from hashtag tags:
   ✅ event.tags.push(['t', 'nostr'])
   ❌ event.tags.push(['t', '#nostr'])`,!1)}})}function checkReplaceableWithOldTimestamp(n,e){if(n.kind===void 0||n.kind===null||!n.created_at||!n.isReplaceable())return;const t=Math.floor(Date.now()/1e3),r=t-n.created_at;if(r>10){const o=Math.floor(r/60),a=o>0?`${o} minute${o!==1?"s":""}`:`${r} seconds`;e("event-replaceable-old-timestamp",`Publishing a replaceable event with an old created_at timestamp.

📦 Event details:
   • kind: ${n.kind} (replaceable)
   • created_at: ${n.created_at}
   • age: ${a} old
   • current time: ${t}

⚠️  This is wrong and will be rejected by relays.`,`For replaceable events, use publishReplaceable():

   ✅ CORRECT:
   await event.publishReplaceable();
   // Automatically updates created_at to now

   ❌ WRONG:
   await event.publish();
   // Uses old created_at`)}}function signing(n,e,t,r){checkMissingKind(n,e),checkContentIsObject(n,e),checkCreatedAtMilliseconds(n,e),checkInvalidPTags(n,e),checkInvalidETags(n,e),checkHashtagsWithPrefix(n,e),checkManualReplyMarkers(n,t,r)}function publishing(n,e){checkReplaceableWithOldTimestamp(n,e)}function isNip33Pattern(n){const e=Array.isArray(n)?n:[n];if(e.length!==1)return!1;const t=e[0];return t.kinds&&Array.isArray(t.kinds)&&t.kinds.length===1&&t.authors&&Array.isArray(t.authors)&&t.authors.length===1&&t["#d"]&&Array.isArray(t["#d"])&&t["#d"].length===1}function isReplaceableEventFilter(n){const e=Array.isArray(n)?n:[n];return e.length===0?!1:e.every(t=>!t.kinds||!Array.isArray(t.kinds)||t.kinds.length===0||!t.authors||!Array.isArray(t.authors)||t.authors.length===0?!1:t.kinds.every(s=>s===0||s===3||s>=1e4&&s<=19999))}function formatFilter(n){return JSON.stringify(n,null,2).split(`
`).map((t,r)=>r===0?t:`   ${t}`).join(`
`)}function fetchingEvents(n,e,t,r,s){if(s(),(e==null?void 0:e.cacheUsage)==="ONLY_CACHE")return;const o=Array.isArray(n)?n:[n],a=o.map(formatFilter).join(`

   ---

   `);if(isNip33Pattern(n))o[0],t("fetch-events-usage",`For fetching a NIP-33 addressable event, use fetchEvent() with the naddr directly.

📦 Your filter:
   `+a+`

  ❌ BAD:  const decoded = nip19.decode(naddr);
           const events = await ndk.fetchEvents({
             kinds: [decoded.data.kind],
             authors: [decoded.data.pubkey],
             "#d": [decoded.data.identifier]
           });
           const event = Array.from(events)[0];

  ✅ GOOD: const event = await ndk.fetchEvent(naddr);
  ✅ GOOD: const event = await ndk.fetchEvent('naddr1...');

fetchEvent() handles naddr decoding automatically and returns the event directly.`);else{if(isReplaceableEventFilter(n))return;{if(!r())return;let c="";const l=o.some(h=>h.limit!==void 0),u=new Set(o.flatMap(h=>h.kinds||[])).size,f=new Set(o.flatMap(h=>h.authors||[])).size;if(l){const h=Math.max(...o.map(p=>p.limit||0));c+=`
   • Limit: ${h} event${h!==1?"s":""}`}u>0&&(c+=`
   • Kinds: ${u} type${u!==1?"s":""}`),f>0&&(c+=`
   • Authors: ${f} author${f!==1?"s":""}`),t("fetch-events-usage",`fetchEvents() is a BLOCKING operation that waits for EOSE.
In most cases, you should use subscribe() instead.

📦 Your filter`+(o.length>1?"s":"")+`:
   `+a+(c?`

📊 Filter analysis:`+c:"")+`

  ❌ BAD:  const events = await ndk.fetchEvents(filter);
  ✅ GOOD: ndk.subscribe(filter, { onEvent: (e) => ... });

Only use fetchEvents() when you MUST block until data arrives.`,"For one-time queries, use fetchEvent() instead of fetchEvents() when expecting a single result.")}}}var GuardrailCheckId={NDK_NO_CACHE:"ndk-no-cache",FILTER_BECH32_IN_ARRAY:"filter-bech32-in-array",FILTER_INVALID_HEX:"filter-invalid-hex",FILTER_ONLY_LIMIT:"filter-only-limit",FILTER_EMPTY:"filter-empty",FILTER_SINCE_AFTER_UNTIL:"filter-since-after-until",FILTER_INVALID_A_TAG:"filter-invalid-a-tag",FILTER_HASHTAG_WITH_PREFIX:"filter-hashtag-with-prefix"};function checkCachePresence(n,e){e(GuardrailCheckId.NDK_NO_CACHE)&&setTimeout(()=>{if(!n.cacheAdapter){const s=`
🤖 AI_GUARDRAILS WARNING: NDK initialized without a cache adapter. Apps perform significantly better with caching.

💡 ${typeof window<"u"?"Consider using @nostr-dev-kit/ndk-cache-dexie or @nostr-dev-kit/ndk-cache-sqlite-wasm":"Consider using @nostr-dev-kit/ndk-cache-redis or @nostr-dev-kit/ndk-cache-sqlite"}

🔇 To disable this check:
   ndk.aiGuardrails.skip('${GuardrailCheckId.NDK_NO_CACHE}')
   or set: ndk.aiGuardrails = { skip: new Set(['${GuardrailCheckId.NDK_NO_CACHE}']) }`;console.warn(s)}},2500)}var AIGuardrails=class{constructor(n=!1){y(this,"enabled",!1);y(this,"skipSet",new Set);y(this,"extensions",new Map);y(this,"_nextCallDisabled",null);y(this,"_replyEvents",new WeakSet);y(this,"_fetchEventsCount",0);y(this,"_subscribeCount",0);y(this,"ndk",{fetchingEvents:(n,e)=>{this.enabled&&fetchingEvents(n,e,this.warn.bind(this),this.shouldWarnAboutFetchEventsRatio.bind(this),this.incrementFetchEventsCount.bind(this))}});y(this,"event",{signing:n=>{this.enabled&&signing(n,this.error.bind(this),this.warn.bind(this),this._replyEvents)},publishing:n=>{this.enabled&&publishing(n,this.warn.bind(this))},received:(n,e)=>{this.enabled},creatingReply:n=>{this.enabled&&this._replyEvents.add(n)}});y(this,"subscription",{created:(n,e)=>{this.enabled&&this.incrementSubscribeCount()}});y(this,"relay",{connected:n=>{this.enabled}});this.setMode(n)}register(n,e){this.extensions.has(n)&&console.warn(`AIGuardrails: Extension '${n}' already registered, overwriting`);const t={};for(const[r,s]of Object.entries(e))typeof s=="function"&&(t[r]=(...o)=>{this.enabled&&s(...o,this.shouldCheck.bind(this),this.error.bind(this),this.warn.bind(this))});this.extensions.set(n,t),this[n]=t}setMode(n){typeof n=="boolean"?(this.enabled=n,this.skipSet.clear()):n&&typeof n=="object"&&(this.enabled=!0,this.skipSet=n.skip||new Set)}isEnabled(){return this.enabled}shouldCheck(n){return!(!this.enabled||this.skipSet.has(n)||this._nextCallDisabled==="all"||this._nextCallDisabled&&this._nextCallDisabled.has(n))}skip(n){this.skipSet.add(n)}enable(n){this.skipSet.delete(n)}getSkipped(){return Array.from(this.skipSet)}captureAndClearNextCallDisabled(){const n=this._nextCallDisabled;return this._nextCallDisabled=null,n}incrementFetchEventsCount(){this._fetchEventsCount++}incrementSubscribeCount(){this._subscribeCount++}shouldWarnAboutFetchEventsRatio(){const n=this._fetchEventsCount+this._subscribeCount;return n<=6?!1:this._fetchEventsCount/n>.5}error(n,e,t,r=!0){if(!this.shouldCheck(n))return;const s=this.formatMessage(n,"ERROR",e,t,r);throw console.error(s),new Error(s)}warn(n,e,t){if(!this.shouldCheck(n))return;const r=this.formatMessage(n,"WARNING",e,t,!0);throw console.error(r),new Error(r)}formatMessage(n,e,t,r,s=!0){let o=`
🤖 AI_GUARDRAILS ${e}: ${t}`;return r&&(o+=`

💡 ${r}`),s&&(o+=`

🔇 To disable this check:
   ndk.guardrailOff('${n}').yourMethod()  // For one call`,o+=`
   ndk.aiGuardrails.skip('${n}')  // Permanently`,o+=`
   or set: ndk.aiGuardrails = { skip: new Set(['${n}']) }`),o}ndkInstantiated(n){this.enabled&&checkCachePresence(n,this.shouldCheck.bind(this))}};function processFilters(n,e="validate",t,r){if(e==="ignore")return n;const s=[],o=n.map((a,c)=>(r!=null&&r.aiGuardrails.isEnabled()&&runAIGuardrailsForFilter(a,c,r),processFilter(a,e,c,s,t)));if(e==="validate"&&s.length>0)throw new Error(`Invalid filter(s) detected:
${s.join(`
`)}`);return o}function processFilter(n,e,t,r,s){const o=e==="validate",a=o?n:{...n};if(n.ids){const c=[];n.ids.forEach((l,u)=>{l===void 0?o?r.push(`Filter[${t}].ids[${u}] is undefined`):s==null||s(`Fixed: Removed undefined value at ids[${u}]`):typeof l!="string"?o?r.push(`Filter[${t}].ids[${u}] is not a string (got ${typeof l})`):s==null||s(`Fixed: Removed non-string value at ids[${u}] (was ${typeof l})`):isValidHex64(l)?c.push(l):o?r.push(`Filter[${t}].ids[${u}] is not a valid 64-char hex string: "${l}"`):s==null||s(`Fixed: Removed invalid hex string at ids[${u}]`)}),o||(a.ids=c.length>0?c:void 0)}if(n.authors){const c=[];n.authors.forEach((l,u)=>{l===void 0?o?r.push(`Filter[${t}].authors[${u}] is undefined`):s==null||s(`Fixed: Removed undefined value at authors[${u}]`):typeof l!="string"?o?r.push(`Filter[${t}].authors[${u}] is not a string (got ${typeof l})`):s==null||s(`Fixed: Removed non-string value at authors[${u}] (was ${typeof l})`):isValidHex64(l)?c.push(l):o?r.push(`Filter[${t}].authors[${u}] is not a valid 64-char hex pubkey: "${l}"`):s==null||s(`Fixed: Removed invalid hex pubkey at authors[${u}]`)}),o||(a.authors=c.length>0?c:void 0)}if(n.kinds){const c=[];n.kinds.forEach((l,u)=>{l===void 0?o?r.push(`Filter[${t}].kinds[${u}] is undefined`):s==null||s(`Fixed: Removed undefined value at kinds[${u}]`):typeof l!="number"?o?r.push(`Filter[${t}].kinds[${u}] is not a number (got ${typeof l})`):s==null||s(`Fixed: Removed non-number value at kinds[${u}] (was ${typeof l})`):Number.isInteger(l)?l<0||l>65535?o?r.push(`Filter[${t}].kinds[${u}] is out of valid range (0-65535): ${l}`):s==null||s(`Fixed: Removed out-of-range kind at kinds[${u}]: ${l}`):c.push(l):o?r.push(`Filter[${t}].kinds[${u}] is not an integer: ${l}`):s==null||s(`Fixed: Removed non-integer value at kinds[${u}]: ${l}`)}),o||(a.kinds=c.length>0?c:void 0)}for(const c in n)if(c.startsWith("#")&&c.length===2){const l=n[c];if(Array.isArray(l)){const u=[];l.forEach((f,h)=>{f===void 0?o?r.push(`Filter[${t}].${c}[${h}] is undefined`):s==null||s(`Fixed: Removed undefined value at ${c}[${h}]`):typeof f!="string"?o?r.push(`Filter[${t}].${c}[${h}] is not a string (got ${typeof f})`):s==null||s(`Fixed: Removed non-string value at ${c}[${h}] (was ${typeof f})`):(c==="#e"||c==="#p")&&!isValidHex64(f)?o?r.push(`Filter[${t}].${c}[${h}] is not a valid 64-char hex string: "${f}"`):s==null||s(`Fixed: Removed invalid hex string at ${c}[${h}]`):u.push(f)}),o||(a[c]=u.length>0?u:void 0)}}return o||Object.keys(a).forEach(c=>{a[c]===void 0&&delete a[c]}),a}function runAIGuardrailsForFilter(n,e,t){const r=t.aiGuardrails,s=JSON.stringify(n,null,2);if(Object.keys(n).length===1&&n.limit!==void 0&&r.error(GuardrailCheckId.FILTER_ONLY_LIMIT,`Filter[${e}] contains only 'limit' without any filtering criteria.

📦 Your filter:
${s}

⚠️  This will fetch random events from relays without any criteria.`,`Add filtering criteria:
   ✅ { kinds: [1], limit: 10 }
   ✅ { authors: [pubkey], limit: 10 }
   ❌ { limit: 10 }`),Object.keys(n).length===0&&r.error(GuardrailCheckId.FILTER_EMPTY,`Filter[${e}] is empty.

📦 Your filter:
${s}

⚠️  This will request ALL events from relays, which is never what you want.`,"Add filtering criteria like 'kinds', 'authors', or tags.",!1),n.since!==void 0&&n.until!==void 0&&n.since>n.until){const a=new Date(n.since*1e3).toISOString(),c=new Date(n.until*1e3).toISOString();r.error(GuardrailCheckId.FILTER_SINCE_AFTER_UNTIL,`Filter[${e}] has 'since' AFTER 'until'.

📦 Your filter:
${s}

❌ since: ${n.since} (${a})
❌ until: ${n.until} (${c})

No events can match this time range!`,"'since' must be BEFORE 'until'. Both are Unix timestamps in seconds.",!1)}const o=/^n(addr|event|ote|pub|profile)1/;n.ids&&n.ids.forEach((a,c)=>{typeof a=="string"&&(o.test(a)?r.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${e}].ids[${c}] contains bech32: "${a}". IDs must be hex, not bech32.`,'Use filterFromId() to decode bech32 first: import { filterFromId } from "@nostr-dev-kit/ndk"',!1):isValidHex64(a)||r.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${e}].ids[${c}] is not a valid 64-char hex string: "${a}"`,`Event IDs must be 64-character hexadecimal strings. Invalid IDs often come from corrupted data in user-generated lists. Always validate hex strings before using them in filters:

   const validIds = ids.filter(id => /^[0-9a-f]{64}$/i.test(id));`,!1))}),n.authors&&n.authors.forEach((a,c)=>{typeof a=="string"&&(o.test(a)?r.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${e}].authors[${c}] contains bech32: "${a}". Authors must be hex pubkeys, not npub.`,"Use ndkUser.pubkey instead. Example: { authors: [ndkUser.pubkey] }",!1):isValidHex64(a)||r.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${e}].authors[${c}] is not a valid 64-char hex pubkey: "${a}"`,`Kind:3 follow lists can contain invalid entries like labels ("Follow List"), partial strings ("highlig"), or other corrupted data. You MUST validate all pubkeys before using them in filters.

   Example:
   const validPubkeys = pubkeys.filter(p => /^[0-9a-f]{64}$/i.test(p));
   ndk.subscribe({ authors: validPubkeys, kinds: [1] });`,!1))});for(const a in n)if(a.startsWith("#")&&a.length===2){const c=n[a];Array.isArray(c)&&c.forEach((l,u)=>{typeof l=="string"&&(a==="#e"||a==="#p")&&(o.test(l)?r.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${e}].${a}[${u}] contains bech32: "${l}". Tag values must be decoded.`,"Use filterFromId() or nip19.decode() to get the hex value first.",!1):isValidHex64(l)||r.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${e}].${a}[${u}] is not a valid 64-char hex string: "${l}"`,`${a==="#e"?"Event IDs":"Public keys"} in tag filters must be 64-character hexadecimal strings. Kind:3 follow lists and other user-generated content can contain invalid data. Always filter before using:

   const validValues = values.filter(v => /^[0-9a-f]{64}$/i.test(v));`,!1))})}if(n["#a"]){const a=n["#a"];a==null||a.forEach((c,l)=>{if(typeof c=="string")if(!/^\d+:[0-9a-f]{64}:.*$/.test(c))r.error(GuardrailCheckId.FILTER_INVALID_A_TAG,`Filter[${e}].#a[${l}] has invalid format: "${c}". Must be "kind:pubkey:d-tag".`,'Example: "30023:fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52:my-article"',!1);else{const u=Number.parseInt(c.split(":")[0],10);(u<3e4||u>39999)&&r.error(GuardrailCheckId.FILTER_INVALID_A_TAG,`Filter[${e}].#a[${l}] uses non-addressable kind ${u}: "${c}". #a filters are only for addressable events (kinds 30000-39999).`,`Addressable events include:
   • 30000-30039: Parameterized Replaceable Events (profiles, settings, etc.)
   • 30040-39999: Other addressable events

For regular events (kind ${u}), use:
   • #e filter for specific event IDs
   • kinds + authors filters for event queries`,!1)}})}if(n["#t"]){const a=n["#t"];a==null||a.forEach((c,l)=>{typeof c=="string"&&c.startsWith("#")&&r.error(GuardrailCheckId.FILTER_HASHTAG_WITH_PREFIX,`Filter[${e}].#t[${l}] contains hashtag with # prefix: "${c}". Hashtag values should NOT include the # symbol.`,`Remove the # prefix from hashtag filters:
   ✅ { "#t": ["nostr"] }
   ❌ { "#t": ["#nostr"] }`,!1)})}}function queryFullyFilled(n){return!!(filterIncludesIds(n.filter)&&resultHasAllRequestedIds(n))}function filterIncludesIds(n){return!!n.ids}function resultHasAllRequestedIds(n){const e=n.filter.ids;return!!e&&e.length===n.eventFirstSeen.size}function filterFromId(n){let e;if(n.match(NIP33_A_REGEX)){const[t,r,s]=n.split(":"),o={authors:[r],kinds:[Number.parseInt(t)]};return s&&(o["#d"]=[s]),o}if(n.match(BECH32_REGEX))try{switch(e=nip19_exports$1.decode(n),e.type){case"nevent":{const t={ids:[e.data.id]};return e.data.author&&(t.authors=[e.data.author]),e.data.kind&&(t.kinds=[e.data.kind]),t}case"note":return{ids:[e.data]};case"naddr":{const t={authors:[e.data.pubkey],kinds:[e.data.kind]};return e.data.identifier&&(t["#d"]=[e.data.identifier]),t}}}catch(t){console.error("Error decoding",n,t)}return{ids:[n]}}function isNip33AValue(n){return n.match(NIP33_A_REGEX)!==null}var NIP33_A_REGEX=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32(n,e){try{const t=nip19_exports$1.decode(n);if(["naddr","nevent"].includes(t==null?void 0:t.type)){const r=t.data;if(r!=null&&r.relays)return r.relays.map(s=>new NDKRelay(s,e.relayAuthDefaultPolicy,e))}}catch{}return[]}var defaultOpts={closeOnEose:!1,cacheUsage:"CACHE_FIRST",dontSaveToCache:!1,groupable:!0,groupableDelay:100,groupableDelayType:"at-most",cacheUnconstrainFilter:["limit","since","until"],includeMuted:!1},NDKSubscription=class extends lib$1.EventEmitter{constructor(e,t,r,s){super();y(this,"subId");y(this,"filters");y(this,"opts");y(this,"pool");y(this,"skipVerification",!1);y(this,"skipValidation",!1);y(this,"exclusiveRelay",!1);y(this,"relayFilters");y(this,"relaySet");y(this,"ndk");y(this,"debug");y(this,"eventFirstSeen",new Map);y(this,"eosesSeen",new Set);y(this,"lastEventReceivedAt");y(this,"mostRecentCacheEventTimestamp");y(this,"internalId");y(this,"closeOnEose");y(this,"poolMonitor");y(this,"skipOptimisticPublishEvent",!1);y(this,"cacheUnconstrainFilter");y(this,"onStopped");y(this,"eoseTimeout");y(this,"eosed",!1);this.ndk=e,this.opts={...defaultOpts,...r||{}},this.pool=this.opts.pool||e.pool;const o=Array.isArray(t)?t:[t],a=e.filterValidationMode==="validate"?"validate":e.filterValidationMode==="fix"?"fix":"ignore";if(this.filters=processFilters(o,a,e.debug,e),this.filters.length===0)throw new Error("Subscription must have at least one filter");this.subId=s||this.opts.subId,this.internalId=Math.random().toString(36).substring(7),this.debug=e.debug.extend(`subscription[${this.opts.subId??this.internalId}]`),this.opts.relaySet?this.relaySet=this.opts.relaySet:this.opts.relayUrls&&(this.relaySet=NDKRelaySet.fromRelayUrls(this.opts.relayUrls,this.ndk)),this.skipVerification=this.opts.skipVerification||!1,this.skipValidation=this.opts.skipValidation||!1,this.closeOnEose=this.opts.closeOnEose||!1,this.skipOptimisticPublishEvent=this.opts.skipOptimisticPublishEvent||!1,this.cacheUnconstrainFilter=this.opts.cacheUnconstrainFilter,this.exclusiveRelay=this.opts.exclusiveRelay||!1,this.opts.onEvent&&this.on("event",this.opts.onEvent),this.opts.onEose&&this.on("eose",this.opts.onEose),this.opts.onClose&&this.on("close",this.opts.onClose)}relaysMissingEose(){var t;return this.relayFilters?Array.from((t=this.relayFilters)==null?void 0:t.keys()).filter(r=>!this.eosesSeen.has(this.pool.getRelay(r,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){var e;if(this.isGroupable())return(e=this.opts)==null?void 0:e.groupableDelay}get groupableDelayType(){var e;return((e=this.opts)==null?void 0:e.groupableDelayType)||"at-most"}isGroupable(){var e;return((e=this.opts)==null?void 0:e.groupable)||!1}shouldQueryCache(){var t;return this.opts.addSinceFromCache?!0:((t=this.opts)==null?void 0:t.cacheUsage)==="ONLY_RELAY"?!1:(this.filters.some(r=>{var s;return(s=r.kinds)==null?void 0:s.some(o=>kindIsEphemeral(o))}),!0)}shouldQueryRelays(){var e;return((e=this.opts)==null?void 0:e.cacheUsage)!=="ONLY_CACHE"}shouldWaitForCache(){var e;return this.opts.addSinceFromCache?!0:!!this.opts.closeOnEose&&!!((e=this.ndk.cacheAdapter)!=null&&e.locking)&&this.opts.cacheUsage!=="PARALLEL"}start(e=!0){let t;const r=o=>{for(const a of o)a.created_at&&(!this.mostRecentCacheEventTimestamp||a.created_at>this.mostRecentCacheEventTimestamp)&&(this.mostRecentCacheEventTimestamp=a.created_at),this.eventReceived(a,void 0,!0,!1);e||(t=o)},s=()=>{this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)};return this.shouldQueryCache()?(t=this.startWithCache(),t instanceof Promise?this.shouldWaitForCache()?(t.then(o=>{if(r(o),queryFullyFilled(this)){this.emit("eose",this);return}s()}),null):(t.then(o=>{r(o),this.shouldQueryRelays()||this.emit("eose",this)}),this.shouldQueryRelays()&&s(),null):(r(t),queryFullyFilled(this)?this.emit("eose",this):s(),t)):(s(),null)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=e=>{var r,s;if((r=this.relayFilters)!=null&&r.has(e.url))return;calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor).get(e.url)&&((s=this.relayFilters)==null||s.set(e.url,this.filters),e.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}stop(){var e;this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),(e=this.onStopped)==null||e.call(this)}hasAuthorsFilter(){return this.filters.some(e=>{var t;return(t=e.authors)==null?void 0:t.length})}startWithCache(){var e;return(e=this.ndk.cacheAdapter)!=null&&e.query?this.ndk.cacheAdapter.query(this):[]}startWithRelays(){let e=this.filters;if(this.opts.addSinceFromCache&&this.mostRecentCacheEventTimestamp){const t=this.mostRecentCacheEventTimestamp+1;e=e.map(r=>({...r,since:Math.max(r.since||0,t)}))}if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters(this.ndk,e,this.pool,this.opts.relayGoalPerAuthor);else{this.relayFilters=new Map;for(const t of this.relaySet.relays)this.relayFilters.set(t.url,e)}for(const[t,r]of this.relayFilters)this.pool.getRelay(t,!0,!0,r).subscribe(this,r)}refreshRelayConnections(){var t,r;if(this.relaySet&&this.relaySet.relays.size>0)return;const e=calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor);for(const[s,o]of e)(t=this.relayFilters)!=null&&t.has(s)||((r=this.relayFilters)==null||r.set(s,o),this.pool.getRelay(s,!0,!0,o).subscribe(this,o))}eventReceived(e,t,r=!1,s=!1){var l,u,f;const o=e.id,a=this.eventFirstSeen.has(o);let c;if(e instanceof NDKEvent&&(c=e),a){const h=Date.now()-(this.eventFirstSeen.get(o)||0);if(this.emit("event:dup",e,t,h,this,r,s),(u=this.opts)!=null&&u.onEventDup&&this.opts.onEventDup(e,t,h,this,r,s),!r&&!s&&t&&((f=this.ndk.cacheAdapter)!=null&&f.setEventDup)&&!this.opts.dontSaveToCache&&(c??(c=e instanceof NDKEvent?e:new NDKEvent(this.ndk,e)),this.ndk.cacheAdapter.setEventDup(c,t)),t){const p=verifiedSignatures.get(o);if(p&&typeof p=="string")if(e.sig===p)t.addValidatedEvent();else{const g=e instanceof NDKEvent?e:new NDKEvent(this.ndk,e);this.ndk.reportInvalidSignature(g,t)}}}else{if(c??(c=new NDKEvent(this.ndk,e)),c.ndk=this.ndk,c.relay=t,!r&&!s){if(!this.skipValidation&&!c.isValid){this.debug("Event failed validation %s from relay %s",o,t==null?void 0:t.url);return}if(t)if(t.shouldValidateEvent()&&!this.skipVerification)if(c.relay=t,this.ndk.asyncSigVerification)c.verifySignature(!0);else{if(!c.verifySignature(!0)){this.debug("Event failed signature validation",e),this.ndk.reportInvalidSignature(c,t);return}t.addValidatedEvent()}else t.addNonValidatedEvent();this.ndk.cacheAdapter&&!this.opts.dontSaveToCache&&this.ndk.cacheAdapter.setEvent(c,this.filters,t)}if(!this.opts.includeMuted&&this.ndk.muteFilter&&this.ndk.muteFilter(c)){this.debug("Event muted, skipping");return}(!s||this.skipOptimisticPublishEvent!==!0)&&(this.emitEvent(((l=this.opts)==null?void 0:l.wrap)??!1,c,t,r,s),this.eventFirstSeen.set(o,Date.now()))}this.lastEventReceivedAt=Date.now()}emitEvent(e,t,r,s,o){const a=e?wrapEvent(t):t;a instanceof Promise?a.then(c=>this.emitEvent(!1,c,r,s,o)):a&&this.emit("event",a,r,this,s,o)}closedReceived(e,t){this.emit("closed",e,t)}eoseReceived(e){var a;this.debug("EOSE received from %s",e.url),this.eosesSeen.add(e);let t=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const r=this.eosesSeen.size===((a=this.relayFilters)==null?void 0:a.size),s=queryFullyFilled(this),o=c=>{var l;this.debug("Performing EOSE: %s %d",c,this.eosed),!this.eosed&&(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,(l=this.opts)!=null&&l.closeOnEose&&this.stop())};if(s||r)o("query filled or seen all");else if(this.relayFilters){let c=1e3;const l=new Set(this.pool.connectedRelays().map(h=>h.url)),u=Array.from(this.relayFilters.keys()).filter(h=>l.has(h));if(u.length===0){this.debug("No connected relays, waiting for all relays to connect",Array.from(this.relayFilters.keys()).join(", "));return}const f=this.eosesSeen.size/u.length;if(this.debug("Percentage of relays that have sent EOSE",{subId:this.subId,percentageOfRelaysThatHaveSentEose:f,seen:this.eosesSeen.size,total:u.length}),this.eosesSeen.size>=2&&f>=.5){if(c=c*(1-f),c===0){o("time to wait was 0");return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const h=()=>{t=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,t!==void 0&&t<20?this.eoseTimeout=setTimeout(h,c):o(`send eose timeout: ${c}`)};this.eoseTimeout=setTimeout(h,c)}}}},kindIsEphemeral=n=>n>=2e4&&n<3e4;async function follows(n,e,t=3){var s,o;if(!this.ndk)throw new Error("NDK not set");const r=await this.ndk.fetchEvent({kinds:[t],authors:[this.pubkey]},n||{groupable:!1});if(r){const a=new Set;return r.tags.forEach(c=>{c[0]==="p"&&c[1]&&isValidPubkey(c[1])&&a.add(c[1])}),e&&((o=(s=this.ndk)==null?void 0:s.outboxTracker)==null||o.trackUsers(Array.from(a))),[...a].reduce((c,l)=>{const u=new NDKUser({pubkey:l});return u.ndk=this.ndk,c.add(u),c},new Set)}return new Set}var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For(n,e,t=fetch,r={}){return await n.queuesNip05.add({id:e,func:async()=>{var l,u,f;if((l=n.cacheAdapter)!=null&&l.loadNip05){const h=await n.cacheAdapter.loadNip05(e);if(h!=="missing"){if(h){const p=new NDKUser({pubkey:h.pubkey,relayUrls:h.relays,nip46Urls:h.nip46});return p.ndk=n,p}if(r.cache!=="no-cache")return null}}const s=e.match(NIP05_REGEX);if(!s)return null;const[o,a="_",c]=s;try{const h=await t(`https://${c}/.well-known/nostr.json?name=${a}`,r),{names:p,relays:g,nip46:b}=parseNIP05Result(await h.json()),m=p[a.toLowerCase()];let E=null;return m&&(E={pubkey:m,relays:g==null?void 0:g[m],nip46:b==null?void 0:b[m]}),(u=n==null?void 0:n.cacheAdapter)!=null&&u.saveNip05&&n.cacheAdapter.saveNip05(e,E),E}catch(h){return(f=n==null?void 0:n.cacheAdapter)!=null&&f.saveNip05&&(n==null||n.cacheAdapter.saveNip05(e,null)),console.error("Failed to fetch NIP05 for",e,h),null}}})}function parseNIP05Result(n){const e={names:{}};for(const[t,r]of Object.entries(n.names))typeof t=="string"&&typeof r=="string"&&(e.names[t.toLowerCase()]=r);if(n.relays){e.relays={};for(const[t,r]of Object.entries(n.relays))typeof t=="string"&&Array.isArray(r)&&(e.relays[t]=r.filter(s=>typeof s=="string"))}if(n.nip46){e.nip46={};for(const[t,r]of Object.entries(n.nip46))typeof t=="string"&&Array.isArray(r)&&(e.nip46[t]=r.filter(s=>typeof s=="string"))}return e}function profileFromEvent(n){const e={};let t;try{t=JSON.parse(n.content)}catch(r){throw new Error(`Failed to parse profile event: ${r}`)}e.profileEvent=JSON.stringify(n.rawEvent());for(const r of Object.keys(t))switch(r){case"name":e.name=t.name;break;case"display_name":e.displayName=t.display_name;break;case"image":case"picture":e.picture=t.picture||t.image,e.image=e.picture;break;case"banner":e.banner=t.banner;break;case"bio":e.bio=t.bio;break;case"nip05":e.nip05=t.nip05;break;case"lud06":e.lud06=t.lud06;break;case"lud16":e.lud16=t.lud16;break;case"about":e.about=t.about;break;case"website":e.website=t.website;break;default:e[r]=t[r];break}return e.created_at=n.created_at,e}function serializeProfile(n){const e={};for(const[t,r]of Object.entries(n))switch(t){case"username":case"name":e.name=r;break;case"displayName":e.display_name=r;break;case"image":case"picture":e.picture=r;break;case"bio":case"about":e.about=r;break;default:e[t]=r;break}return JSON.stringify(e)}var NDKUser=class Oe{constructor(e){y(this,"ndk");y(this,"profile");y(this,"profileEvent");y(this,"_npub");y(this,"_pubkey");y(this,"relayUrls",[]);y(this,"nip46Urls",[]);y(this,"follows",follows.bind(this));if(e.npub&&(this._npub=e.npub),e.hexpubkey&&(this._pubkey=e.hexpubkey),e.pubkey&&(this._pubkey=e.pubkey),e.relayUrls&&(this.relayUrls=e.relayUrls),e.nip46Urls&&(this.nip46Urls=e.nip46Urls),e.nprofile)try{const t=nip19_exports$1.decode(e.nprofile);t.type==="nprofile"&&(this._pubkey=t.data.pubkey,t.data.relays&&t.data.relays.length>0&&this.relayUrls.push(...t.data.relays))}catch(t){console.error("Failed to decode nprofile",t)}}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports$1.npubEncode(this.pubkey)}return this._npub}get nprofile(){var t,r;const e=(r=(t=this.profileEvent)==null?void 0:t.onRelays)==null?void 0:r.map(s=>s.url);return nip19_exports$1.nprofileEncode({pubkey:this.pubkey,relays:e})}set npub(e){this._npub=e}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports$1.decode(this.npub).data}return this._pubkey}set pubkey(e){this._pubkey=e}filter(){return{"#p":[this.pubkey]}}async getZapInfo(e){if(!this.ndk)throw new Error("No NDK instance found");const t=async a=>{if(!e)return a;let c;const l=new Promise((u,f)=>{c=setTimeout(()=>f(new Error("Timeout")),e)});try{const u=await Promise.race([a,l]);return c&&clearTimeout(c),u}catch(u){if(u instanceof Error&&u.message==="Timeout")try{return await a}catch{return}return}},[r,s]=await Promise.all([t(this.fetchProfile()),t(this.ndk.fetchEvent({kinds:[10019],authors:[this.pubkey]}))]),o=new Map;if(s){const a=NDKCashuMintList.from(s);a.mints.length>0&&o.set("nip61",{mints:a.mints,relays:a.relays,p2pk:a.p2pk})}if(r){const{lud06:a,lud16:c}=r;o.set("nip57",{lud06:a,lud16:c})}return o}static async fromNip05(e,t,r=!1){if(!t)throw new Error("No NDK instance found");const s={};r&&(s.cache="no-cache");const o=await getNip05For(t,e,t==null?void 0:t.httpFetch,s);if(o){const a=new Oe({pubkey:o.pubkey,relayUrls:o.relays,nip46Urls:o.nip46});return a.ndk=t,a}}async fetchProfile(e,t=!1){if(!this.ndk)throw new Error("NDK not set");let r=null;if(this.ndk.cacheAdapter&&(this.ndk.cacheAdapter.fetchProfile||this.ndk.cacheAdapter.fetchProfileSync)&&(e==null?void 0:e.cacheUsage)!=="ONLY_RELAY"){let s=null;if(this.ndk.cacheAdapter.fetchProfileSync?s=this.ndk.cacheAdapter.fetchProfileSync(this.pubkey):this.ndk.cacheAdapter.fetchProfile&&(s=await this.ndk.cacheAdapter.fetchProfile(this.pubkey)),s)return this.profile=s,s}return e??(e={}),e.cacheUsage??(e.cacheUsage="ONLY_RELAY"),e.closeOnEose??(e.closeOnEose=!0),e.groupable??(e.groupable=!0),e.groupableDelay??(e.groupableDelay=250),r||(r=await this.ndk.fetchEvent({kinds:[0],authors:[this.pubkey]},e)),r?(this.profile=profileFromEvent(r),t&&this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile):null}async followSet(e,t,r=3){const s=await this.follows(e,t,r);return new Set(Array.from(s).map(o=>o.pubkey))}tagReference(){return["p",this.pubkey]}referenceTags(e){const t=[["p",this.pubkey]];return e&&t[0].push("",e),t}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent(this.ndk,{kind:0,content:serializeProfile(this.profile)}).publish()}async follow(e,t,r=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),t||(t=await this.follows(void 0,void 0,r));const s=typeof e=="string"?e:e.pubkey;if(Array.from(t).some(c=>typeof c=="string"?c===s:c.pubkey===s))return!1;t.add(e);const a=new NDKEvent(this.ndk,{kind:r});for(const c of t)typeof c=="string"?a.tags.push(["p",c]):a.tag(c);return await a.publish(),!0}async unfollow(e,t,r=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),t||(t=await this.follows(void 0,void 0,r));const s=typeof e=="string"?e:e.pubkey,o=new Set;let a=!1;for(const l of t)(typeof l=="string"?l:l.pubkey)!==s?o.add(l):a=!0;if(!a)return!1;const c=new NDKEvent(this.ndk,{kind:r});for(const l of o)typeof l=="string"?c.tags.push(["p",l]):c.tag(l);return await c.publish()}async validateNip05(e){if(!this.ndk)throw new Error("No NDK instance found");const t=await getNip05For(this.ndk,e);return t===null?null:t.pubkey===this.pubkey}},signerRegistry=new Map;function registerSigner(n,e){signerRegistry.set(n,e)}var NDKPrivateKeySigner=class Le{constructor(e,t){y(this,"_user");y(this,"_privateKey");y(this,"_pubkey");if(typeof e=="string")if(e.startsWith("nsec1")){const{type:r,data:s}=nip19_exports$1.decode(e);if(r==="nsec")this._privateKey=s;else throw new Error("Invalid private key provided.")}else if(e.length===64)this._privateKey=hexToBytes(e);else throw new Error("Invalid private key provided.");else this._privateKey=e;this._pubkey=getPublicKey(this._privateKey),t&&(this._user=t.getUser({pubkey:this._pubkey})),this._user??(this._user=new NDKUser({pubkey:this._pubkey}))}get privateKey(){if(!this._privateKey)throw new Error("Not ready");return bytesToHex(this._privateKey)}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}get nsec(){if(!this._privateKey)throw new Error("Not ready");return nip19_exports$1.nsecEncode(this._privateKey)}get npub(){if(!this._pubkey)throw new Error("Not ready");return nip19_exports$1.npubEncode(this._pubkey)}encryptToNcryptsec(e,t=16,r=2){if(!this._privateKey)throw new Error("Private key not available");return encrypt$1(this._privateKey,e,t,r)}static generate(){const e=generateSecretKey();return new Le(e)}static fromNcryptsec(e,t,r){const s=decrypt$1(e,t);return new Le(s,r)}async blockUntilReady(){return this._user}async user(){return this._user}get userSync(){return this._user}async sign(e){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent(e,this._privateKey).sig}async encryptionEnabled(e){const t=[];return(!e||e==="nip04")&&t.push("nip04"),(!e||e==="nip44")&&t.push("nip44"),t}async encrypt(e,t,r){if(!this._privateKey||!this.privateKey)throw Error("Attempted to encrypt without a private key");const s=e.pubkey;if(r==="nip44"){const o=nip44_exports.v2.utils.getConversationKey(this._privateKey,s);return await nip44_exports.v2.encrypt(t,o)}return await nip04_exports.encrypt(this._privateKey,s,t)}async decrypt(e,t,r){if(!this._privateKey||!this.privateKey)throw Error("Attempted to decrypt without a private key");const s=e.pubkey;if(r==="nip44"){const o=nip44_exports.v2.utils.getConversationKey(this._privateKey,s);return await nip44_exports.v2.decrypt(t,o)}return await nip04_exports.decrypt(this._privateKey,s,t)}toPayload(){if(!this._privateKey)throw new Error("Private key not available");const e={type:"private-key",payload:this.privateKey};return JSON.stringify(e)}static async fromPayload(e,t){const r=JSON.parse(e);if(r.type!=="private-key")throw new Error(`Invalid payload type: expected 'private-key', got ${r.type}`);if(!r.payload||typeof r.payload!="string")throw new Error("Invalid payload content for private-key signer");return new Le(r.payload,t)}};registerSigner("private-key",NDKPrivateKeySigner);function dedup(n,e){return n.created_at>e.created_at?n:e}async function getRelayListForUser(n,e){return(await getRelayListForUsers([n],e)).get(n)}async function getRelayListForUsers(n,e,t=!1,r=1e3,s){var p;const o=e.outboxPool||e.pool,a=new Set;for(const g of o.relays.values())a.add(g);if(s)for(const g of s.values())for(const b of g){const m=o.getRelay(b,!0,!0);m&&a.add(m)}const c=new Map,l=new Map,u=new NDKRelaySet(a,e);if((p=e.cacheAdapter)!=null&&p.locking&&!t){const g=await e.fetchEvents({kinds:[3,10002],authors:Array.from(new Set(n))},{cacheUsage:"ONLY_CACHE",subId:"ndk-relay-list-fetch"});for(const b of g)b.kind===10002&&c.set(b.pubkey,NDKRelayList.from(b));for(const b of g)if(b.kind===3){if(c.has(b.pubkey))continue;const m=relayListFromKind3(e,b);m&&l.set(b.pubkey,m)}n=n.filter(b=>!c.has(b)&&!l.has(b))}if(n.length===0)return c;const f=new Map,h=new Map;return new Promise(g=>{let b=!1;(async()=>{const E={closeOnEose:!0,pool:o,groupable:!0,subId:"ndk-relay-list-fetch",addSinceFromCache:!0,relaySet:u};u&&(E.relaySet=u),e.subscribe({kinds:[3,10002],authors:n},E,{onEvent:P=>{if(P.kind===10002){const M=f.get(P.pubkey);if(M&&M.created_at>P.created_at)return;f.set(P.pubkey,P)}else if(P.kind===3){const M=h.get(P.pubkey);if(M&&M.created_at>P.created_at)return;h.set(P.pubkey,P)}},onEose:()=>{if(!b){b=!0,e.debug(`[getRelayListForUsers] EOSE - relayListEvents: ${f.size}, contactListEvents: ${h.size}`);for(const P of f.values())c.set(P.pubkey,NDKRelayList.from(P));for(const P of n){if(c.has(P))continue;const M=h.get(P);if(!M)continue;const L=relayListFromKind3(e,M);L&&c.set(P,L)}e.debug(`[getRelayListForUsers] Returning ${c.size} relay lists for ${n.length} pubkeys`),g(c)}}});const _=Array.from(a).some(P=>P.status<=2),C=Array.from(a).some(P=>P.status===4);let I=r;(_||C)&&(I=r+3e3),e.debug(`[getRelayListForUsers] Setting fallback timeout to ${I}ms (disconnected: ${_}, connecting: ${C})`,{pubkeys:n}),setTimeout(()=>{b||(b=!0,e.debug(`[getRelayListForUsers] Timeout reached, returning ${c.size} relay lists`),g(c))},I)})()})}var OutboxItem=class{constructor(n){y(this,"type");y(this,"relayUrlScores");y(this,"readRelays");y(this,"writeRelays");this.type=n,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker=class extends lib$1.EventEmitter{constructor(e){super();y(this,"data");y(this,"ndk");y(this,"debug");this.ndk=e,this.debug=e.debug.extend("outbox-tracker"),this.data=new dist.LRUCache({maxSize:1e5,entryExpirationTimeInMS:2*60*1e3})}async trackUsers(e,t=!1){const r=[];for(let s=0;s<e.length;s+=400){const o=e.slice(s,s+400),a=o.map(l=>getKeyFromItem(l)).filter(l=>!this.data.has(l));if(a.length===0)continue;for(const l of a)this.data.set(l,new OutboxItem("user"));const c=new Map;for(const l of o)l instanceof NDKUser&&l.relayUrls.length>0&&c.set(l.pubkey,l.relayUrls);r.push(new Promise(l=>{getRelayListForUsers(a,this.ndk,t,1e3,c).then(u=>{this.debug(`Received relay lists for ${u.size} pubkeys out of ${a.length} requested`);for(const[f,h]of u){let p=this.data.get(f);if(p??(p=new OutboxItem("user")),h){if(p.readRelays=new Set(normalize(h.readRelayUrls)),p.writeRelays=new Set(normalize(h.writeRelayUrls)),this.ndk.relayConnectionFilter){for(const g of p.readRelays)this.ndk.relayConnectionFilter(g)||p.readRelays.delete(g);for(const g of p.writeRelays)this.ndk.relayConnectionFilter(g)||p.writeRelays.delete(g)}this.data.set(f,p),this.emit("user:relay-list-updated",f,p),this.debug(`Adding ${p.readRelays.size} read relays and ${p.writeRelays.size} write relays for ${f}`,h==null?void 0:h.rawEvent())}}}).finally(l)}))}return Promise.all(r)}track(e,t,r=!0){const s=getKeyFromItem(e);t??(t=getTypeFromItem(e));let o=this.data.get(s);return o||(o=new OutboxItem(t),e instanceof NDKUser&&this.trackUsers([e])),o}};function getKeyFromItem(n){return n instanceof NDKUser?n.pubkey:n}function getTypeFromItem(n){return n instanceof NDKUser?"user":"kind"}function correctRelaySet(n,e){const t=e.connectedRelays();if(!Array.from(n.relays).some(s=>t.map(o=>o.url).includes(s.url)))for(const s of t)n.addRelay(s);if(t.length===0)for(const s of e.relays.values())n.addRelay(s);return n}var NDKSubscriptionManager=class{constructor(){y(this,"subscriptions");y(this,"seenEvents",new dist.LRUCache({maxSize:1e4,entryExpirationTimeInMS:5*60*1e3}));this.subscriptions=new Map}add(n){this.subscriptions.set(n.internalId,n),n.onStopped,n.onStopped=()=>{this.subscriptions.delete(n.internalId)},n.on("close",()=>{this.subscriptions.delete(n.internalId)})}seenEvent(n,e){const t=this.seenEvents.get(n)||[];t.some(r=>r.url===e.url)||t.push(e),this.seenEvents.set(n,t)}dispatchEvent(n,e,t=!1){e&&this.seenEvent(n.id,e);const r=this.subscriptions.values(),s=[];for(const o of r)matchFilters(o.filters,n)&&s.push(o);for(const o of s){if(o.exclusiveRelay&&o.relaySet){let a=!1;if(t?a=!o.skipOptimisticPublishEvent:e?a=o.relaySet.relays.has(e):a=(this.seenEvents.get(n.id)||[]).some(l=>o.relaySet.relays.has(l)),!a){o.debug.extend("exclusive-relay")("Rejected event %s from %s (relay not in exclusive set)",n.id,(e==null?void 0:e.url)||(t?"optimistic":"cache"));continue}}o.eventReceived(n,e,!1,t)}}},debug6=createDebug5("ndk:active-user");async function getUserRelayList(n){if(!this.autoConnectUserRelays)return;const e=await getRelayListForUser(n.pubkey,this);if(e){for(const t of e.relays){let r=this.pool.relays.get(t);r||(r=new NDKRelay(t,this.relayAuthDefaultPolicy,this),this.pool.addRelay(r))}return debug6("Connected to %d user relays",e.relays.length),e}}async function setActiveUser(n){if(!this.autoConnectUserRelays)return;const e=this.outboxPool||this.pool;e.connectedRelays.length>0?await getUserRelayList.call(this,n):e.once("connect",async()=>{await getUserRelayList.call(this,n)})}function getEntity(n){try{const e=nip19_exports$1.decode(n);return e.type==="npub"?npub(this,e.data):e.type==="nprofile"?nprofile(this,e.data):e}catch{return null}}function npub(n,e){return n.getUser({pubkey:e})}function nprofile(n,e){const t=n.getUser({pubkey:e.pubkey});return e.relays&&(t.relayUrls=e.relays),t}function isValidHint(n){if(!n||n==="")return!1;try{return new URL(n),!0}catch{return!1}}async function fetchEventFromTag(n,e,t,r={type:"timeout"}){const s=this.debug.extend("fetch-event-from-tag"),[o,a,c]=n;t={},s("fetching event from tag",n,t,r);const l=getRelaysForSync(this,e.pubkey);if(l&&l.size>0){s("fetching event from author relays %o",Array.from(l));const m=NDKRelaySet.fromRelayUrls(Array.from(l),this),E=await this.fetchEvent(a,t,m);if(E)return E}else s("no author relays found for %s",e.pubkey,e);const u=calculateRelaySetsFromFilters(this,[{ids:[a]}],this.pool);s("fetching event without relay hint",u);const f=await this.fetchEvent(a,t);if(f)return f;if(c&&c!==""){const m=await this.fetchEvent(a,t,this.pool.getRelay(c,!0,!0,[{ids:[a]}]));if(m)return m}let h;const p=isValidHint(c)?this.pool.getRelay(c,!1,!0,[{ids:[a]}]):void 0,g=new Promise(m=>{this.fetchEvent(a,t,p).then(m)});if(!isValidHint(c)||r.type==="none")return g;const b=new Promise(async m=>{const E=r.relaySet,_=r.timeout??1500,C=new Promise(I=>setTimeout(I,_));if(r.type==="timeout"&&await C,h)m(h);else{s("fallback fetch triggered");const I=await this.fetchEvent(a,t,E);m(I)}});switch(r.type){case"timeout":return Promise.race([g,b]);case"eose":return h=await g,h||b}}var Queue=class{constructor(n,e){y(this,"queue",[]);y(this,"maxConcurrency");y(this,"processing",new Set);y(this,"promises",new Map);this.maxConcurrency=e}add(n){if(this.promises.has(n.id))return this.promises.get(n.id);const e=new Promise((t,r)=>{this.queue.push({...n,func:()=>n.func().then(s=>(t(s),s),s=>{throw r(s),s})}),this.process()});return this.promises.set(n.id,e),e.finally(()=>{this.promises.delete(n.id),this.processing.delete(n.id),this.process()}),e}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const n=this.queue.shift();!n||this.processing.has(n.id)||(this.processing.add(n.id),n.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},DEFAULT_OUTBOX_RELAYS=["wss://purplepag.es/","wss://nos.lol/"],NDK=class extends lib$1.EventEmitter{constructor(e={}){super();y(this,"_explicitRelayUrls");y(this,"pool");y(this,"outboxPool");y(this,"_signer");y(this,"_activeUser");y(this,"cacheAdapter");y(this,"debug");y(this,"devWriteRelaySet");y(this,"outboxTracker");y(this,"muteFilter");y(this,"relayConnectionFilter");y(this,"clientName");y(this,"clientNip89");y(this,"queuesZapConfig");y(this,"queuesNip05");y(this,"asyncSigVerification",!1);y(this,"initialValidationRatio",1);y(this,"lowestValidationRatio",.1);y(this,"validationRatioFn");y(this,"filterValidationMode","validate");y(this,"subManager");y(this,"aiGuardrails");y(this,"_signatureVerificationFunction");y(this,"_signatureVerificationWorker");y(this,"signatureVerificationTimeMs",0);y(this,"publishingFailureHandled",!1);y(this,"pools",[]);y(this,"relayAuthDefaultPolicy");y(this,"httpFetch");y(this,"netDebug");y(this,"autoConnectUserRelays",!0);y(this,"_wallet");y(this,"walletConfig");y(this,"fetchEventFromTag",fetchEventFromTag.bind(this));y(this,"getEntity",getEntity.bind(this));this.debug=e.debug||createDebug5("ndk"),this.netDebug=e.netDebug,this._explicitRelayUrls=e.explicitRelayUrls||[],this.subManager=new NDKSubscriptionManager,this.pool=new NDKPool(e.explicitRelayUrls||[],this),this.pool.name="Main",this.pool.on("relay:auth",async(t,r)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(t,r)}),this.autoConnectUserRelays=e.autoConnectUserRelays??!0,this.clientName=e.clientName,this.clientNip89=e.clientNip89,this.relayAuthDefaultPolicy=e.relayAuthDefaultPolicy,e.enableOutboxModel!==!1&&(this.outboxPool=new NDKPool(e.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS,this,{debug:this.debug.extend("outbox-pool"),name:"Outbox Pool"}),this.outboxTracker=new OutboxTracker(this),this.outboxTracker.on("user:relay-list-updated",(t,r)=>{this.debug(`Outbox relay list updated for ${t}`);for(const s of this.subManager.subscriptions.values())s.filters.some(a=>{var c;return(c=a.authors)==null?void 0:c.includes(t)})&&typeof s.refreshRelayConnections=="function"&&(this.debug(`Refreshing relay connections for subscription ${s.internalId}`),s.refreshRelayConnections())})),this.signer=e.signer,this.cacheAdapter=e.cacheAdapter,this.muteFilter=e.muteFilter,this.relayConnectionFilter=e.relayConnectionFilter,e.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet.fromRelayUrls(e.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue("zaps",3),this.queuesNip05=new Queue("nip05",10),e.signatureVerificationWorker&&(this.signatureVerificationWorker=e.signatureVerificationWorker),e.signatureVerificationFunction&&(this.signatureVerificationFunction=e.signatureVerificationFunction),this.initialValidationRatio=e.initialValidationRatio||1,this.lowestValidationRatio=e.lowestValidationRatio||.1,this.validationRatioFn=e.validationRatioFn||this.defaultValidationRatioFn,this.filterValidationMode=e.filterValidationMode||"validate",this.aiGuardrails=new AIGuardrails(e.aiGuardrails||!1),this.aiGuardrails.ndkInstantiated(this);try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(e){this._explicitRelayUrls=e.map(normalizeRelayUrl),this.pool.relayUrls=e}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(e){this._signatureVerificationWorker=e,e?(signatureVerificationInit(e),this.asyncSigVerification=!0):this.asyncSigVerification=!1}set signatureVerificationFunction(e){this._signatureVerificationFunction=e,this.asyncSigVerification=!!e}get signatureVerificationFunction(){return this._signatureVerificationFunction}addExplicitRelay(e,t,r=!0){var o;let s;return typeof e=="string"?s=new NDKRelay(e,t,this):s=e,this.pool.addRelay(s,r),(o=this.explicitRelayUrls)==null||o.push(s.url),s}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(e){var r;const t=((r=this._activeUser)==null?void 0:r.pubkey)!==(e==null?void 0:e.pubkey);this._activeUser=e,t&&this.emit("activeUser:change",e),e&&t&&setActiveUser.call(this,e)}get signer(){return this._signer}set signer(e){this._signer=e,e&&this.emit("signer:ready",e),e==null||e.user().then(t=>{t.ndk=this,this.activeUser=t})}async connect(e){var r,s,o;this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await((s=(r=this._signer).relays)==null?void 0:s.call(r,this))),this._signer.relays&&(await this._signer.relays(this)).forEach(c=>this.pool.addRelay(c)));const t=[this.pool.connect(e)];return this.outboxPool&&t.push(this.outboxPool.connect(e)),(o=this.cacheAdapter)!=null&&o.initializeAsync&&t.push(this.cacheAdapter.initializeAsync(this)),Promise.allSettled(t).then(()=>{})}reportInvalidSignature(e,t){this.debug(`Invalid signature detected for event ${e.id}${t?` from relay ${t.url}`:""}`),this.emit("event:invalid-sig",e,t)}defaultValidationRatioFn(e,t,r){if(t<10)return this.initialValidationRatio;const s=Math.min(t/100,1),o=this.initialValidationRatio*(1-s)+this.lowestValidationRatio*s;return Math.max(o,this.lowestValidationRatio)}getUser(e){if(typeof e=="string")if(e.startsWith("npub1")){const{type:r,data:s}=nip19_exports$1.decode(e);if(r!=="npub")throw new Error(`Invalid npub: ${e}`);return this.getUser({pubkey:s})}else if(e.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$1.decode(e);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${e}`);return this.getUser({pubkey:s.pubkey,relayUrls:s.relays})}else return this.getUser({pubkey:e});const t=new NDKUser(e);return t.ndk=this,t}async getUserFromNip05(e,t=!1){return NDKUser.fromNip05(e,this,t)}async fetchUser(e,t=!1){if(isValidNip05(e))return NDKUser.fromNip05(e,this,t);if(e.startsWith("npub1")){const{type:r,data:s}=nip19_exports$1.decode(e);if(r!=="npub")throw new Error(`Invalid npub: ${e}`);const o=new NDKUser({pubkey:s});return o.ndk=this,o}else if(e.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$1.decode(e);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${e}`);const o=new NDKUser({pubkey:s.pubkey,relayUrls:s.relays});return o.ndk=this,o}else{const r=new NDKUser({pubkey:e});return r.ndk=this,r}}subscribe(e,t,r=!0,s=!0){var h,p,g;let o=t==null?void 0:t.relaySet,a=s;r instanceof NDKRelaySet?(console.warn("relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0"),o=r,a=s):(typeof r=="boolean"||typeof r=="object")&&(a=r);let c;const l={relaySet:o,...t};a&&typeof a=="object"&&(a.onEvent&&(l.onEvent=a.onEvent),a.onEose&&(l.onEose=a.onEose),a.onClose&&(l.onClose=a.onClose),a.onEvents&&(c=a.onEvents));const u=new NDKSubscription(this,e,l);this.subManager.add(u),(p=(h=this.aiGuardrails)==null?void 0:h.subscription)==null||p.created(Array.isArray(e)?e:[e],l);const f=u.pool;if(u.relaySet)for(const b of u.relaySet.relays)f.useTemporaryRelay(b,void 0,u.filters);if(this.outboxPool&&u.hasAuthorsFilter()){const b=u.filters.filter(m=>{var E;return m.authors&&((E=m.authors)==null?void 0:E.length)>0}).flatMap(m=>m.authors);(g=this.outboxTracker)==null||g.trackUsers(b)}return a&&setTimeout(async()=>{var m;(m=this.cacheAdapter)!=null&&m.initializeAsync&&!this.cacheAdapter.ready&&await this.cacheAdapter.initializeAsync(this);const b=u.start(!c);b&&b.length>0&&c&&c(b)},0),u}fetchEventSync(e){if(!this.cacheAdapter)throw new Error("Cache adapter not set");let t;typeof e=="string"?t=[filterFromId(e)]:t=e;const r=new NDKSubscription(this,t),s=this.cacheAdapter.query(r);if(s instanceof Promise)throw new Error("Cache adapter is async");return s.map(o=>(o.ndk=this,o))}async fetchEvent(e,t,r){var a,c;let s,o;if(r instanceof NDKRelay?o=new NDKRelaySet(new Set([r]),this):r instanceof NDKRelaySet&&(o=r),!r&&typeof e=="string"&&!isNip33AValue(e)){const l=relaysFromBech32(e,this);l.length>0&&(o=new NDKRelaySet(new Set(l),this),o=correctRelaySet(o,this.pool))}if(typeof e=="string"?s=[filterFromId(e)]:Array.isArray(e)?s=e:s=[e],typeof e!="string"&&((c=(a=this.aiGuardrails)==null?void 0:a.ndk)==null||c.fetchingEvents(s)),s.length===0)throw new Error(`Invalid filter: ${JSON.stringify(e)}`);return new Promise((l,u)=>{let f=null;const h={...t||{},closeOnEose:!0};o&&(h.relaySet=o);const p=setTimeout(()=>{g.stop(),this.aiGuardrails._nextCallDisabled=null,l(f)},1e4),g=this.subscribe(s,h,{onEvent:b=>{b.ndk=this,b.isReplaceable()?(!f||f.created_at<b.created_at)&&(f=b):(clearTimeout(p),this.aiGuardrails._nextCallDisabled=null,l(b))},onEose:()=>{clearTimeout(p),this.aiGuardrails._nextCallDisabled=null,l(f)}})})}async fetchEvents(e,t,r){var s,o;return(o=(s=this.aiGuardrails)==null?void 0:s.ndk)==null||o.fetchingEvents(e,t),new Promise(a=>{const c=new Map,l={...t||{},closeOnEose:!0};r&&(l.relaySet=r);const u=f=>{let h;f instanceof NDKEvent?h=f:h=new NDKEvent(void 0,f);const p=h.deduplicationKey(),g=c.get(p);g&&(h=dedup(g,h)),h.ndk=this,c.set(p,h)};this.subscribe(e,{...l,onEvent:u,onEose:()=>{this.aiGuardrails._nextCallDisabled=null,a(new Set(c.values()))}})})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}guardrailOff(e){return e?typeof e=="string"?this.aiGuardrails._nextCallDisabled=new Set([e]):this.aiGuardrails._nextCallDisabled=new Set(e):this.aiGuardrails._nextCallDisabled="all",this}set wallet(e){var t,r;if(!e){this._wallet=void 0,this.walletConfig=void 0;return}this._wallet=e,this.walletConfig??(this.walletConfig={}),this.walletConfig.lnPay=(t=e==null?void 0:e.lnPay)==null?void 0:t.bind(e),this.walletConfig.cashuPay=(r=e==null?void 0:e.cashuPay)==null?void 0:r.bind(e)}get wallet(){return this._wallet}},nip19_exports={};__reExport(nip19_exports,nip19_star);var nip49_exports={};__reExport(nip49_exports,nip49_star);function disconnect(n,e){return e??(e=createDebug5("ndk:relay:auth-policies:disconnect")),async t=>{e==null||e(`Relay ${t.url} requested authentication, disconnecting`),n.removeRelay(t.url)}}async function signAndAuth(n,e,t,r,s,o){try{await n.sign(t),s(n)}catch(a){r==null||r(`Failed to publish auth event to relay ${e.url}`,a),o(n)}}function signIn({ndk:n,signer:e,debug:t}={}){return t??(t=createDebug5("ndk:auth-policies:signIn")),async(r,s)=>{t==null||t(`Relay ${r.url} requested authentication, signing in`);const o=new NDKEvent(n);return o.kind=22242,o.tags=[["relay",r.url],["challenge",s]],e??(e=n==null?void 0:n.signer),new Promise(async(a,c)=>{e?await signAndAuth(o,r,e,t,a,c):n==null||n.once("signer:ready",async l=>{await signAndAuth(o,r,l,t,a,c)})})}}var NDKRelayAuthPolicies={disconnect,signIn};async function ndkSignerFromPayload(n,e){let t;try{t=JSON.parse(n)}catch(s){console.error("Failed to parse signer payload string",n,s);return}if(!t||typeof t.type!="string"){console.error("Failed to parse signer payload string",n,new Error("Missing type field"));return}const r=signerRegistry.get(t.type);if(!r)throw new Error(`Unknown signer type: ${t.type}`);try{return await r.fromPayload(n,e)}catch(s){const o=s instanceof Error?s.message:String(s);throw new Error(`Failed to deserialize signer type ${t.type}: ${o}`)}}var NDKNip07Signer=class He{constructor(e=1e3,t){y(this,"_userPromise");y(this,"encryptionQueue",[]);y(this,"encryptionProcessing",!1);y(this,"debug");y(this,"waitTimeout");y(this,"_pubkey");y(this,"ndk");y(this,"_user");this.debug=createDebug5("ndk:nip07"),this.waitTimeout=e,this.ndk=t}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}async blockUntilReady(){var r;await this.waitForExtension();const e=await((r=window.nostr)==null?void 0:r.getPublicKey());if(!e)throw new Error("User rejected access");this._pubkey=e;let t;return this.ndk?t=this.ndk.getUser({pubkey:e}):t=new NDKUser({pubkey:e}),this._user=t,t}async user(){return this._userPromise||(this._userPromise=this.blockUntilReady()),this._userPromise}get userSync(){if(!this._user)throw new Error("User not ready");return this._user}async sign(e){var r;await this.waitForExtension();const t=await((r=window.nostr)==null?void 0:r.signEvent(e));if(!t)throw new Error("Failed to sign event");return t.sig}async relays(e){var s,o;await this.waitForExtension();const t=await((o=(s=window.nostr)==null?void 0:s.getRelays)==null?void 0:o.call(s))||{},r=[];for(const a of Object.keys(t))t[a].read&&t[a].write&&r.push(a);return r.map(a=>new NDKRelay(a,e==null?void 0:e.relayAuthDefaultPolicy,e))}async encryptionEnabled(e){var r,s;const t=[];return(!e||e==="nip04")&&((r=window.nostr)!=null&&r.nip04)&&t.push("nip04"),(!e||e==="nip44")&&((s=window.nostr)!=null&&s.nip44)&&t.push("nip44"),t}async encrypt(e,t,r="nip04"){if(!await this.encryptionEnabled(r))throw new Error(`${r}encryption is not available from your browser extension`);await this.waitForExtension();const s=e.pubkey;return this.queueEncryption(r,"encrypt",s,t)}async decrypt(e,t,r="nip04"){if(!await this.encryptionEnabled(r))throw new Error(`${r}encryption is not available from your browser extension`);await this.waitForExtension();const s=e.pubkey;return this.queueEncryption(r,"decrypt",s,t)}async queueEncryption(e,t,r,s){return new Promise((o,a)=>{this.encryptionQueue.push({scheme:e,method:t,counterpartyHexpubkey:r,value:s,resolve:o,reject:a}),this.encryptionProcessing||this.processEncryptionQueue()})}async processEncryptionQueue(e,t=0){var f,h;if(!e&&this.encryptionQueue.length===0){this.encryptionProcessing=!1;return}this.encryptionProcessing=!0;const r=e||this.encryptionQueue.shift();if(!r){this.encryptionProcessing=!1;return}const{scheme:s,method:o,counterpartyHexpubkey:a,value:c,resolve:l,reject:u}=r;this.debug("Processing encryption queue item",{method:o,counterpartyHexpubkey:a,value:c});try{const p=await((h=(f=window.nostr)==null?void 0:f[s])==null?void 0:h[o](a,c));if(!p)throw new Error("Failed to encrypt/decrypt");l(p)}catch(p){const g=p instanceof Error?p.message:String(p);if(g.includes("call already executing")&&t<5){this.debug("Retrying encryption queue item",{method:o,counterpartyHexpubkey:a,value:c,retries:t}),setTimeout(()=>{this.processEncryptionQueue(r,t+1)},50*t);return}u(p instanceof Error?p:new Error(g))}this.processEncryptionQueue()}waitForExtension(){return new Promise((e,t)=>{if(window.nostr){e();return}let r;const s=setInterval(()=>{window.nostr&&(clearTimeout(r),clearInterval(s),e())},100);r=setTimeout(()=>{clearInterval(s),t(new Error("NIP-07 extension not available"))},this.waitTimeout)})}toPayload(){return JSON.stringify({type:"nip07",payload:""})}static async fromPayload(e,t){const r=JSON.parse(e);if(r.type!=="nip07")throw new Error(`Invalid payload type: expected 'nip07', got ${r.type}`);return new He(void 0,t)}};registerSigner("nip07",NDKNip07Signer);var NDKNostrRpc=class extends lib$1.EventEmitter{constructor(e,t,r,s){super();y(this,"ndk");y(this,"signer");y(this,"relaySet");y(this,"debug");y(this,"encryptionType","nip04");y(this,"pool");if(this.ndk=e,this.signer=t,s){this.pool=new NDKPool(s,e,{debug:r.extend("rpc-pool"),name:"Nostr RPC"}),this.relaySet=new NDKRelaySet(new Set,e,this.pool);for(const o of s){const a=this.pool.getRelay(o,!1,!1);a.authPolicy=NDKRelayAuthPolicies.signIn({ndk:e,signer:t,debug:r}),this.relaySet.addRelay(a),a.connect()}}this.debug=r.extend("rpc")}subscribe(e){return new Promise(t=>{const r=this.ndk.subscribe(e,{closeOnEose:!1,groupable:!1,cacheUsage:"ONLY_RELAY",pool:this.pool,relaySet:this.relaySet,onEvent:async s=>{try{const o=await this.parseEvent(s);o.method?this.emit("request",o):(this.emit(`response-${o.id}`,o),this.emit("response",o))}catch(o){this.debug("error parsing event",o,s.rawEvent())}},onEose:()=>{this.debug("eosed"),t(r)}})})}async parseEvent(e){this.encryptionType==="nip44"&&e.content.includes("?iv=")?this.encryptionType="nip04":this.encryptionType==="nip04"&&!e.content.includes("?iv=")&&(this.encryptionType="nip44");const t=this.ndk.getUser({pubkey:e.pubkey});t.ndk=this.ndk;let r;try{r=await this.signer.decrypt(t,e.content,this.encryptionType)}catch{const h=this.encryptionType==="nip04"?"nip44":"nip04";r=await this.signer.decrypt(t,e.content,h),this.encryptionType=h}const s=JSON.parse(r),{id:o,method:a,params:c,result:l,error:u}=s;return a?{id:o,pubkey:e.pubkey,method:a,params:c,event:e}:{id:o,result:l,error:u,event:e}}async sendResponse(e,t,r,s=24133,o){const a={id:e,result:r};o&&(a.error=o);const c=await this.signer.user(),l=this.ndk.getUser({pubkey:t}),u=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(a),tags:[["p",t]],pubkey:c.pubkey});u.content=await this.signer.encrypt(l,u.content,this.encryptionType),await u.sign(this.signer),await u.publish(this.relaySet)}async sendRequest(e,t,r=[],s=24133,o){const a=Math.random().toString(36).substring(7),c=await this.signer.user(),l=this.ndk.getUser({pubkey:e}),u={id:a,method:t,params:r},f=new Promise(()=>{const p=g=>{g.result==="auth_url"?(this.once(`response-${a}`,p),this.emit("authUrl",g.error)):o&&o(g)};this.once(`response-${a}`,p)}),h=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(u),tags:[["p",e]],pubkey:c.pubkey});return h.content=await this.signer.encrypt(l,h.content,this.encryptionType),await h.sign(this.signer),await h.publish(this.relaySet),f}};function nostrConnectGenerateSecret(){return Math.random().toString(36).substring(2,15)}function generateNostrConnectUri(n,e,t,r){const s={name:r!=null&&r.name?encodeURIComponent(r.name):"",url:r!=null&&r.url?encodeURIComponent(r.url):"",image:r!=null&&r.image?encodeURIComponent(r.image):"",perms:r!=null&&r.perms?encodeURIComponent(r.perms):""};let o=`nostrconnect://${n}?image=${s.image}&url=${s.url}&name=${s.name}&perms=${s.perms}&secret=${encodeURIComponent(e)}`;return t&&(o+=`&relay=${encodeURIComponent(t)}`),o}var NDKNip46Signer=class Ue extends lib$1.EventEmitter{constructor(t,r,s,o,a){super();y(this,"ndk");y(this,"_user");y(this,"bunkerPubkey");y(this,"userPubkey");y(this,"secret");y(this,"localSigner");y(this,"nip05");y(this,"rpc");y(this,"debug");y(this,"relayUrls");y(this,"subscription");y(this,"nostrConnectUri");y(this,"nostrConnectSecret");this.ndk=t,this.debug=t.debug.extend("nip46:signer"),this.relayUrls=o,s?typeof s=="string"?this.localSigner=new NDKPrivateKeySigner(s):this.localSigner=s:this.localSigner=NDKPrivateKeySigner.generate(),r===!1||(r?r.startsWith("bunker://")?this.bunkerFlowInit(r):this.nip05Init(r):this.nostrconnectFlowInit(a)),this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls)}get pubkey(){if(!this.userPubkey)throw new Error("Not ready");return this.userPubkey}static bunker(t,r,s){return new Ue(t,r,s)}static nostrconnect(t,r,s,o){return new Ue(t,void 0,s,[r],o)}nostrconnectFlowInit(t){var s;this.nostrConnectSecret=nostrConnectGenerateSecret();const r=this.localSigner.pubkey;this.nostrConnectUri=generateNostrConnectUri(r,this.nostrConnectSecret,(s=this.relayUrls)==null?void 0:s[0],t)}bunkerFlowInit(t){const r=new URL(t),s=r.hostname||r.pathname.replace(/^\/\//,""),o=r.searchParams.get("pubkey"),a=r.searchParams.getAll("relay"),c=r.searchParams.get("secret");this.bunkerPubkey=s,this.userPubkey=o,this.relayUrls=a,this.secret=c}nip05Init(t){this.nip05=t}async startListening(){if(this.subscription)return;const t=await this.localSigner.user();if(!t)throw new Error("Local signer not ready");this.subscription=await this.rpc.subscribe({kinds:[24133],"#p":[t.pubkey]})}async user(){return this._user?this._user:this.blockUntilReady()}get userSync(){if(!this._user)throw new Error("Remote user not ready synchronously");return this._user}async blockUntilReadyNostrConnect(){return new Promise((t,r)=>{const s=o=>{o.result===this.nostrConnectSecret&&(this._user=o.event.author,this.userPubkey=o.event.pubkey,this.bunkerPubkey=o.event.pubkey,this.rpc.off("response",s),t(this._user))};this.startListening(),this.rpc.on("response",s)})}async blockUntilReady(){if(!this.bunkerPubkey&&!this.nostrConnectSecret&&!this.nip05)throw new Error("Bunker pubkey not set");if(this.nostrConnectSecret)return this.blockUntilReadyNostrConnect();if(this.nip05&&!this.userPubkey){const t=await NDKUser.fromNip05(this.nip05,this.ndk);t&&(this._user=t,this.userPubkey=t.pubkey,this.relayUrls=t.nip46Urls,this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls))}if(!this.bunkerPubkey&&this.userPubkey)this.bunkerPubkey=this.userPubkey;else if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");return await this.startListening(),this.rpc.on("authUrl",(...t)=>{this.emit("authUrl",...t)}),new Promise((t,r)=>{const s=[this.userPubkey??""];if(this.secret&&s.push(this.secret),!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"connect",s,24133,o=>{o.result==="ack"?this.getPublicKey().then(a=>{this.userPubkey=a,this._user=this.ndk.getUser({pubkey:a}),t(this._user)}):r(o.error)})})}stop(){var t;(t=this.subscription)==null||t.stop(),this.subscription=void 0}async getPublicKey(){return this.userPubkey?this.userPubkey:new Promise((t,r)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"get_public_key",[],24133,s=>{t(s.result)})})}async encryptionEnabled(t){return t?[t]:Promise.resolve(["nip04","nip44"])}async encrypt(t,r,s="nip04"){return this.encryption(t,r,s,"encrypt")}async decrypt(t,r,s="nip04"){return this.encryption(t,r,s,"decrypt")}async encryption(t,r,s,o){return new Promise((c,l)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,`${s}_${o}`,[t.pubkey,r],24133,u=>{u.error?l(u.error):c(u.result)})})}async sign(t){return new Promise((s,o)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"sign_event",[JSON.stringify(t)],24133,a=>{if(a.error)o(a.error);else{const c=JSON.parse(a.result);s(c.sig)}})})}async createAccount(t,r,s){await this.startListening();const o=[];return t&&o.push(t),r&&o.push(r),s&&o.push(s),new Promise((a,c)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"create_account",o,24133,l=>{if(l.error)c(l.error);else{const u=l.result;a(u)}})})}toPayload(){if(!this.bunkerPubkey||!this.userPubkey)throw new Error("NIP-46 signer is not fully initialized for serialization");const t={type:"nip46",payload:{bunkerPubkey:this.bunkerPubkey,userPubkey:this.userPubkey,relayUrls:this.relayUrls,secret:this.secret,localSignerPayload:this.localSigner.toPayload(),nip05:this.nip05||null}};return JSON.stringify(t)}static async fromPayload(t,r){if(!r)throw new Error("NDK instance is required to deserialize NIP-46 signer");const s=JSON.parse(t);if(s.type!=="nip46")throw new Error(`Invalid payload type: expected 'nip46', got ${s.type}`);const o=s.payload;if(!o||typeof o!="object"||!o.localSignerPayload)throw new Error("Invalid payload content for nip46 signer");const a=await ndkSignerFromPayload(o.localSignerPayload,r);if(!a)throw new Error("Failed to deserialize local signer for NIP-46");if(!(a instanceof NDKPrivateKeySigner))throw new Error("Local signer must be an instance of NDKPrivateKeySigner");let c;return c=new Ue(r,!1,a,o.relayUrls),c.userPubkey=o.userPubkey,c.bunkerPubkey=o.bunkerPubkey,c.relayUrls=o.relayUrls,c.secret=o.secret,o.userPubkey&&(c._user=new NDKUser({pubkey:o.userPubkey}),c._user&&(c._user.ndk=r)),c}};registerSigner("nip46",NDKNip46Signer);createDebug5("ndk:zapper:ln");createDebug5("ndk:zapper");const version="0.0.1",packageJson={version};let ndk=null,userPubkey=null,currentUser=null,followingList=[],selectedUsers=new Set,userMetadata=new Map,followsBackStatus=new Map,relays=["wss://relay.nostr.band","wss://relay.damus.io"];const CACHE_EXPIRY_MS=24*60*60*1e3,STORAGE_PREFIX="unfollowstr_";function saveMetadataToCache(n,e){try{const t={metadata:e,timestamp:Date.now()};localStorage.setItem(STORAGE_PREFIX+"profile_"+n,JSON.stringify(t))}catch(t){console.warn("Failed to save metadata to cache:",t)}}function loadMetadataFromCache(n){try{const e=localStorage.getItem(STORAGE_PREFIX+"profile_"+n);if(!e)return null;const t=JSON.parse(e);return Date.now()-t.timestamp>CACHE_EXPIRY_MS?(localStorage.removeItem(STORAGE_PREFIX+"profile_"+n),null):t.metadata}catch(e){return console.warn("Failed to load metadata from cache:",e),null}}function clearExpiredCache(){try{const n=Object.keys(localStorage);let e=0;n.forEach(t=>{if(t.startsWith(STORAGE_PREFIX+"profile_"))try{const r=localStorage.getItem(t);if(r){const s=JSON.parse(r);Date.now()-s.timestamp>CACHE_EXPIRY_MS&&(localStorage.removeItem(t),e++)}}catch{localStorage.removeItem(t),e++}}),e>0&&console.log(`🧹 Cleared ${e} expired cache entries`)}catch(n){console.warn("Failed to clear expired cache:",n)}}window.addEventListener("DOMContentLoaded",async()=>{var e,t,r,s,o,a;const n=document.querySelector(".version");n&&(n.textContent=`v${packageJson.version}`),clearExpiredCache(),(e=document.getElementById("loginBtn"))==null||e.addEventListener("click",login),(t=document.getElementById("logoutBtn"))==null||t.addEventListener("click",logout),(r=document.getElementById("userMenuButton"))==null||r.addEventListener("click",toggleUserMenu),(s=document.getElementById("selectAllCheckbox"))==null||s.addEventListener("change",toggleSelectAll),(o=document.getElementById("filterNonFollowers"))==null||o.addEventListener("change",applyFilter),(a=document.getElementById("unfollowBtn"))==null||a.addEventListener("click",unfollowSelected),document.addEventListener("click",c=>{const l=document.getElementById("dropdownMenu"),u=document.getElementById("userMenuButton");l&&u&&!l.contains(c.target)&&!u.contains(c.target)&&closeUserMenu()}),console.log("🚀 Initializing NDK..."),ndk=new NDK({explicitRelayUrls:relays});try{await ndk.connect(),console.log("✓ NDK connected to relays:",relays)}catch(c){console.error("❌ Failed to connect to relays:",c)}});function toggleUserMenu(){const n=document.getElementById("dropdownMenu"),e=document.getElementById("userMenuButton");n.classList.toggle("active"),e.classList.toggle("active")}function closeUserMenu(){const n=document.getElementById("dropdownMenu"),e=document.getElementById("userMenuButton");n.classList.remove("active"),e.classList.remove("active")}function updateUserMenuDisplay(){const n=document.getElementById("userMenuButton"),e=document.getElementById("userMenuAvatar"),t=document.getElementById("dropdownUserName"),r=document.getElementById("dropdownUserPubkey");if(userPubkey){const s=userMetadata.get(userPubkey),o=(s==null?void 0:s.display_name)||(s==null?void 0:s.name)||"Anonymous",a=(s==null?void 0:s.picture)||`https://api.dicebear.com/7.x/identicon/svg?seed=${userPubkey}`;let c;try{const l=nip19_exports$1.npubEncode(userPubkey);c=l.substring(0,12)+"..."+l.substring(l.length-8)}catch(l){console.error("Error encoding npub:",l),c=userPubkey.substring(0,8)+"..."+userPubkey.substring(userPubkey.length-8)}e.src=a,e.onerror=()=>{e.src=`https://api.dicebear.com/7.x/identicon/svg?seed=${userPubkey}`},t.textContent=o,r.textContent=c,n.style.display="flex"}else n.style.display="none"}async function login(){if(!window.nostr){alert("Please install a Nostr browser extension like nos2x or Alby");return}if(!ndk){alert("NDK is still loading, please try again in a moment");return}try{const n=new NDKNip07Signer;ndk.signer=n,currentUser=await n.user(),userPubkey=currentUser.pubkey,console.log("🔑 Logged in with pubkey:",userPubkey),console.log("👤 Current user:",currentUser);try{const e=loadMetadataFromCache(userPubkey);if(e)userMetadata.set(userPubkey,e);else{const t=await currentUser.fetchProfile();if(t){const r={name:t.name,display_name:t.displayName,picture:t.image,about:t.about,nip05:t.nip05,created_at:t.created_at||Date.now()/1e3};userMetadata.set(userPubkey,r),saveMetadataToCache(userPubkey,r)}}}catch(e){console.warn("Could not fetch user profile:",e)}document.getElementById("loginSection").style.display="none",document.getElementById("appSection").style.display="block",updateUserMenuDisplay(),await loadFollowData()}catch(n){console.error("Login error:",n),alert("Failed to connect: "+n.message)}}function logout(){userPubkey=null,currentUser=null,followingList=[],selectedUsers.clear(),userMetadata.clear(),followsBackStatus.clear(),ndk&&(ndk.signer=void 0),closeUserMenu(),updateUserMenuDisplay(),document.getElementById("loginSection").style.display="block",document.getElementById("appSection").style.display="none"}async function loadFollowData(){document.getElementById("loadingSection").style.display="block",document.getElementById("dataSection").style.display="none";try{if(console.log("Starting to fetch follow list..."),document.getElementById("statusText").textContent="Fetching your following list...",followingList=await fetchFollowList(userPubkey),console.log("Following list fetched:",followingList.length,"users"),followingList.length===0){displayResults();return}followingList.forEach(n=>{followsBackStatus.set(n,"checking")}),displayResults(),console.log("Starting background metadata and follow-back checks..."),fetchMetadataInBackground(followingList),checkFollowsBackInBackground(followingList)}catch(n){console.error("Load data error:",n),document.getElementById("statusText").textContent="Error: "+n.message}}async function fetchFollowList(n){console.log("📋 Fetching follow list from relays:",relays);try{const e={kinds:[3],authors:[n],limit:1},t=await ndk.fetchEvents(e);if(t.size===0)return console.log("No follow list found"),[];const r=Array.from(t)[0];console.log("📋 FOLLOW LIST EVENT (Kind 3):",r.rawEvent());const s=r.tags.filter(o=>o[0]==="p").map(o=>o[1]).filter(o=>!o||typeof o!="string"||o.length!==64?(console.warn("⚠️ Skipping invalid pubkey in follow list:",o),!1):/^[0-9a-f]{64}$/i.test(o)?!0:(console.warn("⚠️ Skipping non-hex pubkey in follow list:",o),!1));return console.log("✓ Found",s.length,"valid follows"),s}catch(e){return console.error("❌ Error fetching follow list:",e),[]}}async function checkFollowsBackInBackground(n){console.log("🔄 Starting follow-back check for",n.length,"users from",relays.length,"relay(s)");const e=100,t=[];for(let o=0;o<n.length;o+=e)t.push(n.slice(o,o+e));console.log("   Split into",t.length,"batch(es) of max",e,"users each");let r=0,s=0;t.forEach((o,a)=>{console.log(`   📦 Starting follow-back batch ${a+1}/${t.length} (${o.length} users)`);const c={kinds:[3],authors:o,"#p":[userPubkey]},l=ndk.subscribe(c,{closeOnEose:!1},{onEvent:u=>{r++,r<=5?console.log("🔄 FOLLOW-BACK CHECK EVENT (Kind 3):",u.rawEvent()):r===6&&console.log("🔄 ... (suppressing further follow-back logs)");const f=u.pubkey;followsBackStatus.set(f,"yes"),r<=5&&console.log("✓ Follows back:",f.substring(0,8)),updateUserBadge(f)},onEose:()=>{if(s++,console.log(`   ✓ Follow-back batch ${a+1}/${t.length} complete (EOSE)`),l.stop(),s===t.length){n.forEach(f=>{followsBackStatus.get(f)==="checking"&&(followsBackStatus.set(f,"no"),updateUserBadge(f))}),updateStats();const u=n.length-r;console.log(`✅ All follow-back batches complete. ${r}/${n.length} follow back, ${u} don't`)}}})})}async function fetchMetadataInBackground(n){console.log("📋 Fetching metadata for",n.length,"users from",relays.length,"relay(s)");let e=0,t=0,r=0;n.forEach(o=>{const a=loadMetadataFromCache(o);a&&(t++,userMetadata.set(o,a),updateUserDisplay(o))}),t>0&&console.log(`💾 Loaded ${t} profiles from cache`);const s=n.map(async(o,a)=>{try{if(userMetadata.has(o))return;r++;const l=await ndk.getUser({pubkey:o}).fetchProfile();if(l){e++,e<=5?console.log("👤 Fetched profile:",{pubkey:o.substring(0,8),profile:l}):e===6&&console.log("👤 ... (suppressing further metadata logs)");const u={name:l.name,display_name:l.displayName,picture:l.image,about:l.about,nip05:l.nip05,created_at:l.created_at||Date.now()/1e3};userMetadata.set(o,u),saveMetadataToCache(o,u),updateUserDisplay(o)}}catch{e<5&&console.debug("No profile found for:",o.substring(0,8))}});await Promise.allSettled(s),console.log(`✅ Metadata fetching complete. Cache hits: ${t}, Network fetches: ${e}/${r} (${r>0?Math.round(e/r*100):0}%)`)}function displayResults(){document.getElementById("loadingSection").style.display="none",document.getElementById("dataSection").style.display="block",updateStats();const n=document.getElementById("userList");if(followingList.length===0){n.innerHTML=`
                <div class="empty-state">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                    </svg>
                    <h3>No Follows Yet</h3>
                    <p>You're not following anyone yet. Use a Nostr client to follow some people first!</p>
                    <p style="margin-top: 10px; font-size: 0.9em;">Try <a href="https://primal.net/" target="_blank" style="color: #667eea;">Primal</a> or <a href="https://nostrudel.ninja/" target="_blank" style="color: #667eea;">Nostrudel</a></p>
                </div>
            `,document.getElementById("unfollowBtn").disabled=!0;return}n.innerHTML=followingList.map(e=>renderUserItem(e)).join(""),setupUserListEventDelegation()}function setupUserListEventDelegation(){const n=document.getElementById("userList");n.replaceWith(n.cloneNode(!0));const e=document.getElementById("userList");e.addEventListener("click",t=>{const r=t.target.closest(".user-item");if(!r||t.target.classList.contains("user-checkbox")||t.target.classList.contains("user-avatar"))return;const s=r.dataset.pubkey;s&&copyNpubToClipboard(t,s)}),e.addEventListener("change",t=>{t.target.classList.contains("user-checkbox")&&updateSelection()})}function renderUserItem(n){if(!n||typeof n!="string"||n.length!==64)return console.warn("Invalid pubkey format:",n),"";const e=userMetadata.get(n),t=followsBackStatus.get(n)||"checking",r=(e==null?void 0:e.display_name)||(e==null?void 0:e.name)||"Unknown",s=(e==null?void 0:e.picture)||`https://api.dicebear.com/7.x/identicon/svg?seed=${n}`;let o;try{const c=nip19_exports$1.npubEncode(n);o=c.substring(0,10)+"..."+c.substring(c.length-8)}catch(c){console.error("Error encoding npub for pubkey:",n,c),o=n.substring(0,8)+"..."+n.substring(n.length-8)}let a="";return t==="checking"?a='<span class="badge badge-checking">Checking...</span>':t==="yes"?a='<span class="badge badge-success">✓ Follows Back</span>':a=`<span class="badge badge-warning">⚠ Doesn't Follow Back</span>`,`
            <div class="user-item" data-pubkey="${n}" style="cursor: pointer;" title="Click to copy npub">
                <input type="checkbox" class="user-checkbox" data-pubkey="${n}">
                <img src="${s}" class="user-avatar" onerror="this.src='https://api.dicebear.com/7.x/identicon/svg?seed=${n}'">
                <div class="user-info">
                    <div class="user-name">${escapeHtml(r)}</div>
                    <div class="user-pubkey">${o}</div>
                </div>
                <div class="badge-container">
                    ${a}
                </div>
            </div>
        `}function escapeHtml(n){const e=document.createElement("div");return e.textContent=n,e.innerHTML}async function copyNpubToClipboard(n,e){n.preventDefault();try{const t=nip19_exports$1.npubEncode(e);await navigator.clipboard.writeText(t);const r=n.currentTarget||n.target.closest(".user-item");if(r){const o=r.style.backgroundColor;r.style.backgroundColor="#d4edda",r.style.transition="background-color 0.3s",setTimeout(()=>{r.style.backgroundColor=o},1500)}const s=document.createElement("div");s.textContent="✓ npub copied to clipboard!",s.style.cssText=`
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #28a745;
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 10000;
                    animation: slideIn 0.3s ease-out;
                `,document.body.appendChild(s),setTimeout(()=>{s.style.animation="slideOut 0.3s ease-in",setTimeout(()=>s.remove(),300)},1500),console.log("📋 Copied to clipboard:",t)}catch(t){console.error("Failed to copy npub:",t),alert("Failed to copy npub to clipboard")}}function updateUserDisplay(n){const e=document.querySelector(`.user-item[data-pubkey="${n}"]`);if(e){const t=e.querySelector(".user-checkbox"),r=(t==null?void 0:t.checked)||!1,s=renderUserItem(n);e.outerHTML=s;const o=document.querySelector(`.user-checkbox[data-pubkey="${n}"]`);o&&(o.checked=r)}}function updateUserBadge(n){const e=document.querySelector(`.user-item[data-pubkey="${n}"]`);if(e){const t=followsBackStatus.get(n)||"checking",r=e.querySelector(".badge-container");if(r){let s="";t==="checking"?s='<span class="badge badge-checking">Checking...</span>':t==="yes"?s='<span class="badge badge-success">✓ Follows Back</span>':s=`<span class="badge badge-warning">⚠ Doesn't Follow Back</span>`,r.innerHTML=s,applyFilter()}}}function updateStats(){const n=followingList.filter(e=>followsBackStatus.get(e)==="no").length;document.getElementById("followingCount").textContent=followingList.length,document.getElementById("notFollowingBackCount").textContent=n,document.getElementById("selectedCount").textContent=selectedUsers.size}function applyFilter(){const n=document.getElementById("filterNonFollowers").checked;document.querySelectorAll(".user-item").forEach(t=>{const r=t.dataset.pubkey,s=followsBackStatus.get(r);n?t.style.display=s==="no"?"flex":"none":t.style.display="flex"})}function toggleSelectAll(){const n=document.getElementById("selectAllCheckbox").checked;document.querySelectorAll(".user-item").forEach(e=>{if(e.style.display!=="none"){const t=e.querySelector(".user-checkbox");t&&(t.checked=n,n?selectedUsers.add(t.dataset.pubkey):selectedUsers.delete(t.dataset.pubkey))}}),updateSelection()}function updateSelection(){selectedUsers.clear(),document.querySelectorAll(".user-checkbox:checked").forEach(e=>{selectedUsers.add(e.dataset.pubkey)}),document.getElementById("selectedCount").textContent=selectedUsers.size,document.getElementById("unfollowBtn").disabled=selectedUsers.size===0;const n=document.querySelectorAll(".user-checkbox").length===selectedUsers.size;document.getElementById("selectAllCheckbox").checked=n&&selectedUsers.size>0}async function unfollowSelected(){if(selectedUsers.size===0||!confirm(`Are you sure you want to unfollow ${selectedUsers.size} user(s)?`))return;const n=document.getElementById("unfollowBtn");n.disabled=!0,n.textContent="Unfollowing...";try{const e=followingList.filter(s=>!selectedUsers.has(s)),t=new NDKEvent(ndk,{kind:3,created_at:Math.floor(Date.now()/1e3),tags:e.map(s=>["p",s]),content:""});console.log("📝 UNFOLLOW EVENT (before signing):",t.rawEvent()),await t.sign(),console.log("✍️ SIGNED UNFOLLOW EVENT:",t.rawEvent()),console.log("📤 Publishing unfollow event to",relays.length,"relay(s)");const r=await t.publish();console.log("✅ Event published to",r.size,"relay(s)"),alert("Successfully unfollowed selected users!"),await loadFollowData(),selectedUsers.clear()}catch(e){console.error("❌ Error unfollowing users:",e),alert("Error unfollowing users: "+e.message),n.disabled=!1,n.textContent="Unfollow Selected"}}
